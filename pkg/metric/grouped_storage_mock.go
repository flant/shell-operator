// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package metric

//go:generate minimock -i github.com/flant/shell-operator/pkg/metric.GroupedStorage -o grouped_storage_mock.go -n GroupedStorageMock -p metric

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/prometheus/client_golang/prometheus"
)

// GroupedStorageMock implements GroupedStorage
type GroupedStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCounterAdd          func(group string, name string, value float64, labels map[string]string)
	funcCounterAddOrigin    string
	inspectFuncCounterAdd   func(group string, name string, value float64, labels map[string]string)
	afterCounterAddCounter  uint64
	beforeCounterAddCounter uint64
	CounterAddMock          mGroupedStorageMockCounterAdd

	funcExpireGroupMetricByName          func(group string, name string)
	funcExpireGroupMetricByNameOrigin    string
	inspectFuncExpireGroupMetricByName   func(group string, name string)
	afterExpireGroupMetricByNameCounter  uint64
	beforeExpireGroupMetricByNameCounter uint64
	ExpireGroupMetricByNameMock          mGroupedStorageMockExpireGroupMetricByName

	funcExpireGroupMetrics          func(group string)
	funcExpireGroupMetricsOrigin    string
	inspectFuncExpireGroupMetrics   func(group string)
	afterExpireGroupMetricsCounter  uint64
	beforeExpireGroupMetricsCounter uint64
	ExpireGroupMetricsMock          mGroupedStorageMockExpireGroupMetrics

	funcGaugeSet          func(group string, name string, value float64, labels map[string]string)
	funcGaugeSetOrigin    string
	inspectFuncGaugeSet   func(group string, name string, value float64, labels map[string]string)
	afterGaugeSetCounter  uint64
	beforeGaugeSetCounter uint64
	GaugeSetMock          mGroupedStorageMockGaugeSet

	funcGetOrCreateCounterCollector          func(name string, labelNames []string) (cp1 *ConstCounterCollector, err error)
	funcGetOrCreateCounterCollectorOrigin    string
	inspectFuncGetOrCreateCounterCollector   func(name string, labelNames []string)
	afterGetOrCreateCounterCollectorCounter  uint64
	beforeGetOrCreateCounterCollectorCounter uint64
	GetOrCreateCounterCollectorMock          mGroupedStorageMockGetOrCreateCounterCollector

	funcGetOrCreateGaugeCollector          func(name string, labelNames []string) (cp1 *ConstGaugeCollector, err error)
	funcGetOrCreateGaugeCollectorOrigin    string
	inspectFuncGetOrCreateGaugeCollector   func(name string, labelNames []string)
	afterGetOrCreateGaugeCollectorCounter  uint64
	beforeGetOrCreateGaugeCollectorCounter uint64
	GetOrCreateGaugeCollectorMock          mGroupedStorageMockGetOrCreateGaugeCollector

	funcRegisterer          func() (r1 prometheus.Registerer)
	funcRegistererOrigin    string
	inspectFuncRegisterer   func()
	afterRegistererCounter  uint64
	beforeRegistererCounter uint64
	RegistererMock          mGroupedStorageMockRegisterer
}

// NewGroupedStorageMock returns a mock for GroupedStorage
func NewGroupedStorageMock(t minimock.Tester) *GroupedStorageMock {
	m := &GroupedStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CounterAddMock = mGroupedStorageMockCounterAdd{mock: m}
	m.CounterAddMock.callArgs = []*GroupedStorageMockCounterAddParams{}

	m.ExpireGroupMetricByNameMock = mGroupedStorageMockExpireGroupMetricByName{mock: m}
	m.ExpireGroupMetricByNameMock.callArgs = []*GroupedStorageMockExpireGroupMetricByNameParams{}

	m.ExpireGroupMetricsMock = mGroupedStorageMockExpireGroupMetrics{mock: m}
	m.ExpireGroupMetricsMock.callArgs = []*GroupedStorageMockExpireGroupMetricsParams{}

	m.GaugeSetMock = mGroupedStorageMockGaugeSet{mock: m}
	m.GaugeSetMock.callArgs = []*GroupedStorageMockGaugeSetParams{}

	m.GetOrCreateCounterCollectorMock = mGroupedStorageMockGetOrCreateCounterCollector{mock: m}
	m.GetOrCreateCounterCollectorMock.callArgs = []*GroupedStorageMockGetOrCreateCounterCollectorParams{}

	m.GetOrCreateGaugeCollectorMock = mGroupedStorageMockGetOrCreateGaugeCollector{mock: m}
	m.GetOrCreateGaugeCollectorMock.callArgs = []*GroupedStorageMockGetOrCreateGaugeCollectorParams{}

	m.RegistererMock = mGroupedStorageMockRegisterer{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mGroupedStorageMockCounterAdd struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockCounterAddExpectation
	expectations       []*GroupedStorageMockCounterAddExpectation

	callArgs []*GroupedStorageMockCounterAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockCounterAddExpectation specifies expectation struct of the GroupedStorage.CounterAdd
type GroupedStorageMockCounterAddExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockCounterAddParams
	paramPtrs          *GroupedStorageMockCounterAddParamPtrs
	expectationOrigins GroupedStorageMockCounterAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// GroupedStorageMockCounterAddParams contains parameters of the GroupedStorage.CounterAdd
type GroupedStorageMockCounterAddParams struct {
	group  string
	name   string
	value  float64
	labels map[string]string
}

// GroupedStorageMockCounterAddParamPtrs contains pointers to parameters of the GroupedStorage.CounterAdd
type GroupedStorageMockCounterAddParamPtrs struct {
	group  *string
	name   *string
	value  *float64
	labels *map[string]string
}

// GroupedStorageMockCounterAddOrigins contains origins of expectations of the GroupedStorage.CounterAdd
type GroupedStorageMockCounterAddExpectationOrigins struct {
	origin       string
	originGroup  string
	originName   string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Optional() *mGroupedStorageMockCounterAdd {
	mmCounterAdd.optional = true
	return mmCounterAdd
}

// Expect sets up expected params for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Expect(group string, name string, value float64, labels map[string]string) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.paramPtrs != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by ExpectParams functions")
	}

	mmCounterAdd.defaultExpectation.params = &GroupedStorageMockCounterAddParams{group, name, value, labels}
	mmCounterAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounterAdd.expectations {
		if minimock.Equal(e.params, mmCounterAdd.defaultExpectation.params) {
			mmCounterAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounterAdd.defaultExpectation.params)
		}
	}

	return mmCounterAdd
}

// ExpectGroupParam1 sets up expected param group for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) ExpectGroupParam1(group string) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &GroupedStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.group = &group
	mmCounterAdd.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectNameParam2 sets up expected param name for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) ExpectNameParam2(name string) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &GroupedStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.name = &name
	mmCounterAdd.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectValueParam3 sets up expected param value for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) ExpectValueParam3(value float64) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &GroupedStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.value = &value
	mmCounterAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectLabelsParam4 sets up expected param labels for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) ExpectLabelsParam4(labels map[string]string) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &GroupedStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.labels = &labels
	mmCounterAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounterAdd
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Inspect(f func(group string, name string, value float64, labels map[string]string)) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.inspectFuncCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.CounterAdd")
	}

	mmCounterAdd.mock.inspectFuncCounterAdd = f

	return mmCounterAdd
}

// Return sets up results that will be returned by GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Return() *GroupedStorageMock {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{mock: mmCounterAdd.mock}
	}

	mmCounterAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// Set uses given function f to mock the GroupedStorage.CounterAdd method
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Set(f func(group string, name string, value float64, labels map[string]string)) *GroupedStorageMock {
	if mmCounterAdd.defaultExpectation != nil {
		mmCounterAdd.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.CounterAdd method")
	}

	if len(mmCounterAdd.expectations) > 0 {
		mmCounterAdd.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.CounterAdd method")
	}

	mmCounterAdd.mock.funcCounterAdd = f
	mmCounterAdd.mock.funcCounterAddOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// When sets expectation for the GroupedStorage.CounterAdd which will trigger the result defined by the following
// Then helper
func (mmCounterAdd *mGroupedStorageMockCounterAdd) When(group string, name string, value float64, labels map[string]string) *GroupedStorageMockCounterAddExpectation {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	expectation := &GroupedStorageMockCounterAddExpectation{
		mock:               mmCounterAdd.mock,
		params:             &GroupedStorageMockCounterAddParams{group, name, value, labels},
		expectationOrigins: GroupedStorageMockCounterAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCounterAdd.expectations = append(mmCounterAdd.expectations, expectation)
	return expectation
}

// Then sets up GroupedStorage.CounterAdd return parameters for the expectation previously defined by the When method

func (e *GroupedStorageMockCounterAddExpectation) Then() *GroupedStorageMock {
	return e.mock
}

// Times sets number of times GroupedStorage.CounterAdd should be invoked
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Times(n uint64) *mGroupedStorageMockCounterAdd {
	if n == 0 {
		mmCounterAdd.mock.t.Fatalf("Times of GroupedStorageMock.CounterAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounterAdd.expectedInvocations, n)
	mmCounterAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounterAdd
}

func (mmCounterAdd *mGroupedStorageMockCounterAdd) invocationsDone() bool {
	if len(mmCounterAdd.expectations) == 0 && mmCounterAdd.defaultExpectation == nil && mmCounterAdd.mock.funcCounterAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounterAdd.mock.afterCounterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounterAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CounterAdd implements GroupedStorage
func (mmCounterAdd *GroupedStorageMock) CounterAdd(group string, name string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmCounterAdd.beforeCounterAddCounter, 1)
	defer mm_atomic.AddUint64(&mmCounterAdd.afterCounterAddCounter, 1)

	mmCounterAdd.t.Helper()

	if mmCounterAdd.inspectFuncCounterAdd != nil {
		mmCounterAdd.inspectFuncCounterAdd(group, name, value, labels)
	}

	mm_params := GroupedStorageMockCounterAddParams{group, name, value, labels}

	// Record call args
	mmCounterAdd.CounterAddMock.mutex.Lock()
	mmCounterAdd.CounterAddMock.callArgs = append(mmCounterAdd.CounterAddMock.callArgs, &mm_params)
	mmCounterAdd.CounterAddMock.mutex.Unlock()

	for _, e := range mmCounterAdd.CounterAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCounterAdd.CounterAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounterAdd.CounterAddMock.defaultExpectation.Counter, 1)
		mm_want := mmCounterAdd.CounterAddMock.defaultExpectation.params
		mm_want_ptrs := mmCounterAdd.CounterAddMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockCounterAddParams{group, name, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCounterAdd.funcCounterAdd != nil {
		mmCounterAdd.funcCounterAdd(group, name, value, labels)
		return
	}
	mmCounterAdd.t.Fatalf("Unexpected call to GroupedStorageMock.CounterAdd. %v %v %v %v", group, name, value, labels)

}

// CounterAddAfterCounter returns a count of finished GroupedStorageMock.CounterAdd invocations
func (mmCounterAdd *GroupedStorageMock) CounterAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.afterCounterAddCounter)
}

// CounterAddBeforeCounter returns a count of GroupedStorageMock.CounterAdd invocations
func (mmCounterAdd *GroupedStorageMock) CounterAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.beforeCounterAddCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.CounterAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Calls() []*GroupedStorageMockCounterAddParams {
	mmCounterAdd.mutex.RLock()

	argCopy := make([]*GroupedStorageMockCounterAddParams, len(mmCounterAdd.callArgs))
	copy(argCopy, mmCounterAdd.callArgs)

	mmCounterAdd.mutex.RUnlock()

	return argCopy
}

// MinimockCounterAddDone returns true if the count of the CounterAdd invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockCounterAddDone() bool {
	if m.CounterAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterAddMock.invocationsDone()
}

// MinimockCounterAddInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockCounterAddInspect() {
	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.CounterAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterAddCounter := mm_atomic.LoadUint64(&m.afterCounterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterAddMock.defaultExpectation != nil && afterCounterAddCounter < 1 {
		if m.CounterAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.CounterAdd at\n%s", m.CounterAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.CounterAdd at\n%s with params: %#v", m.CounterAddMock.defaultExpectation.expectationOrigins.origin, *m.CounterAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounterAdd != nil && afterCounterAddCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.CounterAdd at\n%s", m.funcCounterAddOrigin)
	}

	if !m.CounterAddMock.invocationsDone() && afterCounterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.CounterAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterAddMock.expectedInvocations), m.CounterAddMock.expectedInvocationsOrigin, afterCounterAddCounter)
	}
}

type mGroupedStorageMockExpireGroupMetricByName struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockExpireGroupMetricByNameExpectation
	expectations       []*GroupedStorageMockExpireGroupMetricByNameExpectation

	callArgs []*GroupedStorageMockExpireGroupMetricByNameParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockExpireGroupMetricByNameExpectation specifies expectation struct of the GroupedStorage.ExpireGroupMetricByName
type GroupedStorageMockExpireGroupMetricByNameExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockExpireGroupMetricByNameParams
	paramPtrs          *GroupedStorageMockExpireGroupMetricByNameParamPtrs
	expectationOrigins GroupedStorageMockExpireGroupMetricByNameExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// GroupedStorageMockExpireGroupMetricByNameParams contains parameters of the GroupedStorage.ExpireGroupMetricByName
type GroupedStorageMockExpireGroupMetricByNameParams struct {
	group string
	name  string
}

// GroupedStorageMockExpireGroupMetricByNameParamPtrs contains pointers to parameters of the GroupedStorage.ExpireGroupMetricByName
type GroupedStorageMockExpireGroupMetricByNameParamPtrs struct {
	group *string
	name  *string
}

// GroupedStorageMockExpireGroupMetricByNameOrigins contains origins of expectations of the GroupedStorage.ExpireGroupMetricByName
type GroupedStorageMockExpireGroupMetricByNameExpectationOrigins struct {
	origin      string
	originGroup string
	originName  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) Optional() *mGroupedStorageMockExpireGroupMetricByName {
	mmExpireGroupMetricByName.optional = true
	return mmExpireGroupMetricByName
}

// Expect sets up expected params for GroupedStorage.ExpireGroupMetricByName
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) Expect(group string, name string) *mGroupedStorageMockExpireGroupMetricByName {
	if mmExpireGroupMetricByName.mock.funcExpireGroupMetricByName != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetricByName mock is already set by Set")
	}

	if mmExpireGroupMetricByName.defaultExpectation == nil {
		mmExpireGroupMetricByName.defaultExpectation = &GroupedStorageMockExpireGroupMetricByNameExpectation{}
	}

	if mmExpireGroupMetricByName.defaultExpectation.paramPtrs != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetricByName mock is already set by ExpectParams functions")
	}

	mmExpireGroupMetricByName.defaultExpectation.params = &GroupedStorageMockExpireGroupMetricByNameParams{group, name}
	mmExpireGroupMetricByName.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExpireGroupMetricByName.expectations {
		if minimock.Equal(e.params, mmExpireGroupMetricByName.defaultExpectation.params) {
			mmExpireGroupMetricByName.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpireGroupMetricByName.defaultExpectation.params)
		}
	}

	return mmExpireGroupMetricByName
}

// ExpectGroupParam1 sets up expected param group for GroupedStorage.ExpireGroupMetricByName
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) ExpectGroupParam1(group string) *mGroupedStorageMockExpireGroupMetricByName {
	if mmExpireGroupMetricByName.mock.funcExpireGroupMetricByName != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetricByName mock is already set by Set")
	}

	if mmExpireGroupMetricByName.defaultExpectation == nil {
		mmExpireGroupMetricByName.defaultExpectation = &GroupedStorageMockExpireGroupMetricByNameExpectation{}
	}

	if mmExpireGroupMetricByName.defaultExpectation.params != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetricByName mock is already set by Expect")
	}

	if mmExpireGroupMetricByName.defaultExpectation.paramPtrs == nil {
		mmExpireGroupMetricByName.defaultExpectation.paramPtrs = &GroupedStorageMockExpireGroupMetricByNameParamPtrs{}
	}
	mmExpireGroupMetricByName.defaultExpectation.paramPtrs.group = &group
	mmExpireGroupMetricByName.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmExpireGroupMetricByName
}

// ExpectNameParam2 sets up expected param name for GroupedStorage.ExpireGroupMetricByName
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) ExpectNameParam2(name string) *mGroupedStorageMockExpireGroupMetricByName {
	if mmExpireGroupMetricByName.mock.funcExpireGroupMetricByName != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetricByName mock is already set by Set")
	}

	if mmExpireGroupMetricByName.defaultExpectation == nil {
		mmExpireGroupMetricByName.defaultExpectation = &GroupedStorageMockExpireGroupMetricByNameExpectation{}
	}

	if mmExpireGroupMetricByName.defaultExpectation.params != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetricByName mock is already set by Expect")
	}

	if mmExpireGroupMetricByName.defaultExpectation.paramPtrs == nil {
		mmExpireGroupMetricByName.defaultExpectation.paramPtrs = &GroupedStorageMockExpireGroupMetricByNameParamPtrs{}
	}
	mmExpireGroupMetricByName.defaultExpectation.paramPtrs.name = &name
	mmExpireGroupMetricByName.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmExpireGroupMetricByName
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.ExpireGroupMetricByName
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) Inspect(f func(group string, name string)) *mGroupedStorageMockExpireGroupMetricByName {
	if mmExpireGroupMetricByName.mock.inspectFuncExpireGroupMetricByName != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.ExpireGroupMetricByName")
	}

	mmExpireGroupMetricByName.mock.inspectFuncExpireGroupMetricByName = f

	return mmExpireGroupMetricByName
}

// Return sets up results that will be returned by GroupedStorage.ExpireGroupMetricByName
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) Return() *GroupedStorageMock {
	if mmExpireGroupMetricByName.mock.funcExpireGroupMetricByName != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetricByName mock is already set by Set")
	}

	if mmExpireGroupMetricByName.defaultExpectation == nil {
		mmExpireGroupMetricByName.defaultExpectation = &GroupedStorageMockExpireGroupMetricByNameExpectation{mock: mmExpireGroupMetricByName.mock}
	}

	mmExpireGroupMetricByName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExpireGroupMetricByName.mock
}

// Set uses given function f to mock the GroupedStorage.ExpireGroupMetricByName method
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) Set(f func(group string, name string)) *GroupedStorageMock {
	if mmExpireGroupMetricByName.defaultExpectation != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.ExpireGroupMetricByName method")
	}

	if len(mmExpireGroupMetricByName.expectations) > 0 {
		mmExpireGroupMetricByName.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.ExpireGroupMetricByName method")
	}

	mmExpireGroupMetricByName.mock.funcExpireGroupMetricByName = f
	mmExpireGroupMetricByName.mock.funcExpireGroupMetricByNameOrigin = minimock.CallerInfo(1)
	return mmExpireGroupMetricByName.mock
}

// When sets expectation for the GroupedStorage.ExpireGroupMetricByName which will trigger the result defined by the following
// Then helper
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) When(group string, name string) *GroupedStorageMockExpireGroupMetricByNameExpectation {
	if mmExpireGroupMetricByName.mock.funcExpireGroupMetricByName != nil {
		mmExpireGroupMetricByName.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetricByName mock is already set by Set")
	}

	expectation := &GroupedStorageMockExpireGroupMetricByNameExpectation{
		mock:               mmExpireGroupMetricByName.mock,
		params:             &GroupedStorageMockExpireGroupMetricByNameParams{group, name},
		expectationOrigins: GroupedStorageMockExpireGroupMetricByNameExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExpireGroupMetricByName.expectations = append(mmExpireGroupMetricByName.expectations, expectation)
	return expectation
}

// Then sets up GroupedStorage.ExpireGroupMetricByName return parameters for the expectation previously defined by the When method

func (e *GroupedStorageMockExpireGroupMetricByNameExpectation) Then() *GroupedStorageMock {
	return e.mock
}

// Times sets number of times GroupedStorage.ExpireGroupMetricByName should be invoked
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) Times(n uint64) *mGroupedStorageMockExpireGroupMetricByName {
	if n == 0 {
		mmExpireGroupMetricByName.mock.t.Fatalf("Times of GroupedStorageMock.ExpireGroupMetricByName mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpireGroupMetricByName.expectedInvocations, n)
	mmExpireGroupMetricByName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExpireGroupMetricByName
}

func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) invocationsDone() bool {
	if len(mmExpireGroupMetricByName.expectations) == 0 && mmExpireGroupMetricByName.defaultExpectation == nil && mmExpireGroupMetricByName.mock.funcExpireGroupMetricByName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpireGroupMetricByName.mock.afterExpireGroupMetricByNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpireGroupMetricByName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExpireGroupMetricByName implements GroupedStorage
func (mmExpireGroupMetricByName *GroupedStorageMock) ExpireGroupMetricByName(group string, name string) {
	mm_atomic.AddUint64(&mmExpireGroupMetricByName.beforeExpireGroupMetricByNameCounter, 1)
	defer mm_atomic.AddUint64(&mmExpireGroupMetricByName.afterExpireGroupMetricByNameCounter, 1)

	mmExpireGroupMetricByName.t.Helper()

	if mmExpireGroupMetricByName.inspectFuncExpireGroupMetricByName != nil {
		mmExpireGroupMetricByName.inspectFuncExpireGroupMetricByName(group, name)
	}

	mm_params := GroupedStorageMockExpireGroupMetricByNameParams{group, name}

	// Record call args
	mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.mutex.Lock()
	mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.callArgs = append(mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.callArgs, &mm_params)
	mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.mutex.Unlock()

	for _, e := range mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.defaultExpectation.Counter, 1)
		mm_want := mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.defaultExpectation.params
		mm_want_ptrs := mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockExpireGroupMetricByNameParams{group, name}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmExpireGroupMetricByName.t.Errorf("GroupedStorageMock.ExpireGroupMetricByName got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmExpireGroupMetricByName.t.Errorf("GroupedStorageMock.ExpireGroupMetricByName got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpireGroupMetricByName.t.Errorf("GroupedStorageMock.ExpireGroupMetricByName got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExpireGroupMetricByName.ExpireGroupMetricByNameMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmExpireGroupMetricByName.funcExpireGroupMetricByName != nil {
		mmExpireGroupMetricByName.funcExpireGroupMetricByName(group, name)
		return
	}
	mmExpireGroupMetricByName.t.Fatalf("Unexpected call to GroupedStorageMock.ExpireGroupMetricByName. %v %v", group, name)

}

// ExpireGroupMetricByNameAfterCounter returns a count of finished GroupedStorageMock.ExpireGroupMetricByName invocations
func (mmExpireGroupMetricByName *GroupedStorageMock) ExpireGroupMetricByNameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpireGroupMetricByName.afterExpireGroupMetricByNameCounter)
}

// ExpireGroupMetricByNameBeforeCounter returns a count of GroupedStorageMock.ExpireGroupMetricByName invocations
func (mmExpireGroupMetricByName *GroupedStorageMock) ExpireGroupMetricByNameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpireGroupMetricByName.beforeExpireGroupMetricByNameCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.ExpireGroupMetricByName.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpireGroupMetricByName *mGroupedStorageMockExpireGroupMetricByName) Calls() []*GroupedStorageMockExpireGroupMetricByNameParams {
	mmExpireGroupMetricByName.mutex.RLock()

	argCopy := make([]*GroupedStorageMockExpireGroupMetricByNameParams, len(mmExpireGroupMetricByName.callArgs))
	copy(argCopy, mmExpireGroupMetricByName.callArgs)

	mmExpireGroupMetricByName.mutex.RUnlock()

	return argCopy
}

// MinimockExpireGroupMetricByNameDone returns true if the count of the ExpireGroupMetricByName invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockExpireGroupMetricByNameDone() bool {
	if m.ExpireGroupMetricByNameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireGroupMetricByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireGroupMetricByNameMock.invocationsDone()
}

// MinimockExpireGroupMetricByNameInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockExpireGroupMetricByNameInspect() {
	for _, e := range m.ExpireGroupMetricByNameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetricByName at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExpireGroupMetricByNameCounter := mm_atomic.LoadUint64(&m.afterExpireGroupMetricByNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireGroupMetricByNameMock.defaultExpectation != nil && afterExpireGroupMetricByNameCounter < 1 {
		if m.ExpireGroupMetricByNameMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetricByName at\n%s", m.ExpireGroupMetricByNameMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetricByName at\n%s with params: %#v", m.ExpireGroupMetricByNameMock.defaultExpectation.expectationOrigins.origin, *m.ExpireGroupMetricByNameMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpireGroupMetricByName != nil && afterExpireGroupMetricByNameCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetricByName at\n%s", m.funcExpireGroupMetricByNameOrigin)
	}

	if !m.ExpireGroupMetricByNameMock.invocationsDone() && afterExpireGroupMetricByNameCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.ExpireGroupMetricByName at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireGroupMetricByNameMock.expectedInvocations), m.ExpireGroupMetricByNameMock.expectedInvocationsOrigin, afterExpireGroupMetricByNameCounter)
	}
}

type mGroupedStorageMockExpireGroupMetrics struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockExpireGroupMetricsExpectation
	expectations       []*GroupedStorageMockExpireGroupMetricsExpectation

	callArgs []*GroupedStorageMockExpireGroupMetricsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockExpireGroupMetricsExpectation specifies expectation struct of the GroupedStorage.ExpireGroupMetrics
type GroupedStorageMockExpireGroupMetricsExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockExpireGroupMetricsParams
	paramPtrs          *GroupedStorageMockExpireGroupMetricsParamPtrs
	expectationOrigins GroupedStorageMockExpireGroupMetricsExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// GroupedStorageMockExpireGroupMetricsParams contains parameters of the GroupedStorage.ExpireGroupMetrics
type GroupedStorageMockExpireGroupMetricsParams struct {
	group string
}

// GroupedStorageMockExpireGroupMetricsParamPtrs contains pointers to parameters of the GroupedStorage.ExpireGroupMetrics
type GroupedStorageMockExpireGroupMetricsParamPtrs struct {
	group *string
}

// GroupedStorageMockExpireGroupMetricsOrigins contains origins of expectations of the GroupedStorage.ExpireGroupMetrics
type GroupedStorageMockExpireGroupMetricsExpectationOrigins struct {
	origin      string
	originGroup string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Optional() *mGroupedStorageMockExpireGroupMetrics {
	mmExpireGroupMetrics.optional = true
	return mmExpireGroupMetrics
}

// Expect sets up expected params for GroupedStorage.ExpireGroupMetrics
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Expect(group string) *mGroupedStorageMockExpireGroupMetrics {
	if mmExpireGroupMetrics.mock.funcExpireGroupMetrics != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by Set")
	}

	if mmExpireGroupMetrics.defaultExpectation == nil {
		mmExpireGroupMetrics.defaultExpectation = &GroupedStorageMockExpireGroupMetricsExpectation{}
	}

	if mmExpireGroupMetrics.defaultExpectation.paramPtrs != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by ExpectParams functions")
	}

	mmExpireGroupMetrics.defaultExpectation.params = &GroupedStorageMockExpireGroupMetricsParams{group}
	mmExpireGroupMetrics.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExpireGroupMetrics.expectations {
		if minimock.Equal(e.params, mmExpireGroupMetrics.defaultExpectation.params) {
			mmExpireGroupMetrics.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpireGroupMetrics.defaultExpectation.params)
		}
	}

	return mmExpireGroupMetrics
}

// ExpectGroupParam1 sets up expected param group for GroupedStorage.ExpireGroupMetrics
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) ExpectGroupParam1(group string) *mGroupedStorageMockExpireGroupMetrics {
	if mmExpireGroupMetrics.mock.funcExpireGroupMetrics != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by Set")
	}

	if mmExpireGroupMetrics.defaultExpectation == nil {
		mmExpireGroupMetrics.defaultExpectation = &GroupedStorageMockExpireGroupMetricsExpectation{}
	}

	if mmExpireGroupMetrics.defaultExpectation.params != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by Expect")
	}

	if mmExpireGroupMetrics.defaultExpectation.paramPtrs == nil {
		mmExpireGroupMetrics.defaultExpectation.paramPtrs = &GroupedStorageMockExpireGroupMetricsParamPtrs{}
	}
	mmExpireGroupMetrics.defaultExpectation.paramPtrs.group = &group
	mmExpireGroupMetrics.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmExpireGroupMetrics
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.ExpireGroupMetrics
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Inspect(f func(group string)) *mGroupedStorageMockExpireGroupMetrics {
	if mmExpireGroupMetrics.mock.inspectFuncExpireGroupMetrics != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.ExpireGroupMetrics")
	}

	mmExpireGroupMetrics.mock.inspectFuncExpireGroupMetrics = f

	return mmExpireGroupMetrics
}

// Return sets up results that will be returned by GroupedStorage.ExpireGroupMetrics
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Return() *GroupedStorageMock {
	if mmExpireGroupMetrics.mock.funcExpireGroupMetrics != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by Set")
	}

	if mmExpireGroupMetrics.defaultExpectation == nil {
		mmExpireGroupMetrics.defaultExpectation = &GroupedStorageMockExpireGroupMetricsExpectation{mock: mmExpireGroupMetrics.mock}
	}

	mmExpireGroupMetrics.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExpireGroupMetrics.mock
}

// Set uses given function f to mock the GroupedStorage.ExpireGroupMetrics method
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Set(f func(group string)) *GroupedStorageMock {
	if mmExpireGroupMetrics.defaultExpectation != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.ExpireGroupMetrics method")
	}

	if len(mmExpireGroupMetrics.expectations) > 0 {
		mmExpireGroupMetrics.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.ExpireGroupMetrics method")
	}

	mmExpireGroupMetrics.mock.funcExpireGroupMetrics = f
	mmExpireGroupMetrics.mock.funcExpireGroupMetricsOrigin = minimock.CallerInfo(1)
	return mmExpireGroupMetrics.mock
}

// When sets expectation for the GroupedStorage.ExpireGroupMetrics which will trigger the result defined by the following
// Then helper
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) When(group string) *GroupedStorageMockExpireGroupMetricsExpectation {
	if mmExpireGroupMetrics.mock.funcExpireGroupMetrics != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by Set")
	}

	expectation := &GroupedStorageMockExpireGroupMetricsExpectation{
		mock:               mmExpireGroupMetrics.mock,
		params:             &GroupedStorageMockExpireGroupMetricsParams{group},
		expectationOrigins: GroupedStorageMockExpireGroupMetricsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmExpireGroupMetrics.expectations = append(mmExpireGroupMetrics.expectations, expectation)
	return expectation
}

// Then sets up GroupedStorage.ExpireGroupMetrics return parameters for the expectation previously defined by the When method

func (e *GroupedStorageMockExpireGroupMetricsExpectation) Then() *GroupedStorageMock {
	return e.mock
}

// Times sets number of times GroupedStorage.ExpireGroupMetrics should be invoked
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Times(n uint64) *mGroupedStorageMockExpireGroupMetrics {
	if n == 0 {
		mmExpireGroupMetrics.mock.t.Fatalf("Times of GroupedStorageMock.ExpireGroupMetrics mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpireGroupMetrics.expectedInvocations, n)
	mmExpireGroupMetrics.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExpireGroupMetrics
}

func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) invocationsDone() bool {
	if len(mmExpireGroupMetrics.expectations) == 0 && mmExpireGroupMetrics.defaultExpectation == nil && mmExpireGroupMetrics.mock.funcExpireGroupMetrics == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpireGroupMetrics.mock.afterExpireGroupMetricsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpireGroupMetrics.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExpireGroupMetrics implements GroupedStorage
func (mmExpireGroupMetrics *GroupedStorageMock) ExpireGroupMetrics(group string) {
	mm_atomic.AddUint64(&mmExpireGroupMetrics.beforeExpireGroupMetricsCounter, 1)
	defer mm_atomic.AddUint64(&mmExpireGroupMetrics.afterExpireGroupMetricsCounter, 1)

	mmExpireGroupMetrics.t.Helper()

	if mmExpireGroupMetrics.inspectFuncExpireGroupMetrics != nil {
		mmExpireGroupMetrics.inspectFuncExpireGroupMetrics(group)
	}

	mm_params := GroupedStorageMockExpireGroupMetricsParams{group}

	// Record call args
	mmExpireGroupMetrics.ExpireGroupMetricsMock.mutex.Lock()
	mmExpireGroupMetrics.ExpireGroupMetricsMock.callArgs = append(mmExpireGroupMetrics.ExpireGroupMetricsMock.callArgs, &mm_params)
	mmExpireGroupMetrics.ExpireGroupMetricsMock.mutex.Unlock()

	for _, e := range mmExpireGroupMetrics.ExpireGroupMetricsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.Counter, 1)
		mm_want := mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.params
		mm_want_ptrs := mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockExpireGroupMetricsParams{group}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmExpireGroupMetrics.t.Errorf("GroupedStorageMock.ExpireGroupMetrics got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpireGroupMetrics.t.Errorf("GroupedStorageMock.ExpireGroupMetrics got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmExpireGroupMetrics.funcExpireGroupMetrics != nil {
		mmExpireGroupMetrics.funcExpireGroupMetrics(group)
		return
	}
	mmExpireGroupMetrics.t.Fatalf("Unexpected call to GroupedStorageMock.ExpireGroupMetrics. %v", group)

}

// ExpireGroupMetricsAfterCounter returns a count of finished GroupedStorageMock.ExpireGroupMetrics invocations
func (mmExpireGroupMetrics *GroupedStorageMock) ExpireGroupMetricsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpireGroupMetrics.afterExpireGroupMetricsCounter)
}

// ExpireGroupMetricsBeforeCounter returns a count of GroupedStorageMock.ExpireGroupMetrics invocations
func (mmExpireGroupMetrics *GroupedStorageMock) ExpireGroupMetricsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpireGroupMetrics.beforeExpireGroupMetricsCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.ExpireGroupMetrics.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Calls() []*GroupedStorageMockExpireGroupMetricsParams {
	mmExpireGroupMetrics.mutex.RLock()

	argCopy := make([]*GroupedStorageMockExpireGroupMetricsParams, len(mmExpireGroupMetrics.callArgs))
	copy(argCopy, mmExpireGroupMetrics.callArgs)

	mmExpireGroupMetrics.mutex.RUnlock()

	return argCopy
}

// MinimockExpireGroupMetricsDone returns true if the count of the ExpireGroupMetrics invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockExpireGroupMetricsDone() bool {
	if m.ExpireGroupMetricsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireGroupMetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireGroupMetricsMock.invocationsDone()
}

// MinimockExpireGroupMetricsInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockExpireGroupMetricsInspect() {
	for _, e := range m.ExpireGroupMetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetrics at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExpireGroupMetricsCounter := mm_atomic.LoadUint64(&m.afterExpireGroupMetricsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireGroupMetricsMock.defaultExpectation != nil && afterExpireGroupMetricsCounter < 1 {
		if m.ExpireGroupMetricsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetrics at\n%s", m.ExpireGroupMetricsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetrics at\n%s with params: %#v", m.ExpireGroupMetricsMock.defaultExpectation.expectationOrigins.origin, *m.ExpireGroupMetricsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpireGroupMetrics != nil && afterExpireGroupMetricsCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetrics at\n%s", m.funcExpireGroupMetricsOrigin)
	}

	if !m.ExpireGroupMetricsMock.invocationsDone() && afterExpireGroupMetricsCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.ExpireGroupMetrics at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireGroupMetricsMock.expectedInvocations), m.ExpireGroupMetricsMock.expectedInvocationsOrigin, afterExpireGroupMetricsCounter)
	}
}

type mGroupedStorageMockGaugeSet struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockGaugeSetExpectation
	expectations       []*GroupedStorageMockGaugeSetExpectation

	callArgs []*GroupedStorageMockGaugeSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockGaugeSetExpectation specifies expectation struct of the GroupedStorage.GaugeSet
type GroupedStorageMockGaugeSetExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockGaugeSetParams
	paramPtrs          *GroupedStorageMockGaugeSetParamPtrs
	expectationOrigins GroupedStorageMockGaugeSetExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// GroupedStorageMockGaugeSetParams contains parameters of the GroupedStorage.GaugeSet
type GroupedStorageMockGaugeSetParams struct {
	group  string
	name   string
	value  float64
	labels map[string]string
}

// GroupedStorageMockGaugeSetParamPtrs contains pointers to parameters of the GroupedStorage.GaugeSet
type GroupedStorageMockGaugeSetParamPtrs struct {
	group  *string
	name   *string
	value  *float64
	labels *map[string]string
}

// GroupedStorageMockGaugeSetOrigins contains origins of expectations of the GroupedStorage.GaugeSet
type GroupedStorageMockGaugeSetExpectationOrigins struct {
	origin       string
	originGroup  string
	originName   string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Optional() *mGroupedStorageMockGaugeSet {
	mmGaugeSet.optional = true
	return mmGaugeSet
}

// Expect sets up expected params for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Expect(group string, name string, value float64, labels map[string]string) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.paramPtrs != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by ExpectParams functions")
	}

	mmGaugeSet.defaultExpectation.params = &GroupedStorageMockGaugeSetParams{group, name, value, labels}
	mmGaugeSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeSet.expectations {
		if minimock.Equal(e.params, mmGaugeSet.defaultExpectation.params) {
			mmGaugeSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeSet.defaultExpectation.params)
		}
	}

	return mmGaugeSet
}

// ExpectGroupParam1 sets up expected param group for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) ExpectGroupParam1(group string) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &GroupedStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.group = &group
	mmGaugeSet.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectNameParam2 sets up expected param name for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) ExpectNameParam2(name string) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &GroupedStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.name = &name
	mmGaugeSet.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectValueParam3 sets up expected param value for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) ExpectValueParam3(value float64) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &GroupedStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.value = &value
	mmGaugeSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectLabelsParam4 sets up expected param labels for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) ExpectLabelsParam4(labels map[string]string) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &GroupedStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeSet.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeSet
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Inspect(f func(group string, name string, value float64, labels map[string]string)) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.inspectFuncGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.GaugeSet")
	}

	mmGaugeSet.mock.inspectFuncGaugeSet = f

	return mmGaugeSet
}

// Return sets up results that will be returned by GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Return() *GroupedStorageMock {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{mock: mmGaugeSet.mock}
	}

	mmGaugeSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// Set uses given function f to mock the GroupedStorage.GaugeSet method
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Set(f func(group string, name string, value float64, labels map[string]string)) *GroupedStorageMock {
	if mmGaugeSet.defaultExpectation != nil {
		mmGaugeSet.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.GaugeSet method")
	}

	if len(mmGaugeSet.expectations) > 0 {
		mmGaugeSet.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.GaugeSet method")
	}

	mmGaugeSet.mock.funcGaugeSet = f
	mmGaugeSet.mock.funcGaugeSetOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// When sets expectation for the GroupedStorage.GaugeSet which will trigger the result defined by the following
// Then helper
func (mmGaugeSet *mGroupedStorageMockGaugeSet) When(group string, name string, value float64, labels map[string]string) *GroupedStorageMockGaugeSetExpectation {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	expectation := &GroupedStorageMockGaugeSetExpectation{
		mock:               mmGaugeSet.mock,
		params:             &GroupedStorageMockGaugeSetParams{group, name, value, labels},
		expectationOrigins: GroupedStorageMockGaugeSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGaugeSet.expectations = append(mmGaugeSet.expectations, expectation)
	return expectation
}

// Then sets up GroupedStorage.GaugeSet return parameters for the expectation previously defined by the When method

func (e *GroupedStorageMockGaugeSetExpectation) Then() *GroupedStorageMock {
	return e.mock
}

// Times sets number of times GroupedStorage.GaugeSet should be invoked
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Times(n uint64) *mGroupedStorageMockGaugeSet {
	if n == 0 {
		mmGaugeSet.mock.t.Fatalf("Times of GroupedStorageMock.GaugeSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeSet.expectedInvocations, n)
	mmGaugeSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeSet
}

func (mmGaugeSet *mGroupedStorageMockGaugeSet) invocationsDone() bool {
	if len(mmGaugeSet.expectations) == 0 && mmGaugeSet.defaultExpectation == nil && mmGaugeSet.mock.funcGaugeSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeSet.mock.afterGaugeSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeSet implements GroupedStorage
func (mmGaugeSet *GroupedStorageMock) GaugeSet(group string, name string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeSet.beforeGaugeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeSet.afterGaugeSetCounter, 1)

	mmGaugeSet.t.Helper()

	if mmGaugeSet.inspectFuncGaugeSet != nil {
		mmGaugeSet.inspectFuncGaugeSet(group, name, value, labels)
	}

	mm_params := GroupedStorageMockGaugeSetParams{group, name, value, labels}

	// Record call args
	mmGaugeSet.GaugeSetMock.mutex.Lock()
	mmGaugeSet.GaugeSetMock.callArgs = append(mmGaugeSet.GaugeSetMock.callArgs, &mm_params)
	mmGaugeSet.GaugeSetMock.mutex.Unlock()

	for _, e := range mmGaugeSet.GaugeSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeSet.GaugeSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeSet.GaugeSetMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeSet.GaugeSetMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeSet.GaugeSetMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockGaugeSetParams{group, name, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeSet.funcGaugeSet != nil {
		mmGaugeSet.funcGaugeSet(group, name, value, labels)
		return
	}
	mmGaugeSet.t.Fatalf("Unexpected call to GroupedStorageMock.GaugeSet. %v %v %v %v", group, name, value, labels)

}

// GaugeSetAfterCounter returns a count of finished GroupedStorageMock.GaugeSet invocations
func (mmGaugeSet *GroupedStorageMock) GaugeSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.afterGaugeSetCounter)
}

// GaugeSetBeforeCounter returns a count of GroupedStorageMock.GaugeSet invocations
func (mmGaugeSet *GroupedStorageMock) GaugeSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.beforeGaugeSetCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.GaugeSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Calls() []*GroupedStorageMockGaugeSetParams {
	mmGaugeSet.mutex.RLock()

	argCopy := make([]*GroupedStorageMockGaugeSetParams, len(mmGaugeSet.callArgs))
	copy(argCopy, mmGaugeSet.callArgs)

	mmGaugeSet.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeSetDone returns true if the count of the GaugeSet invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockGaugeSetDone() bool {
	if m.GaugeSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeSetMock.invocationsDone()
}

// MinimockGaugeSetInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockGaugeSetInspect() {
	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.GaugeSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeSetCounter := mm_atomic.LoadUint64(&m.afterGaugeSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeSetMock.defaultExpectation != nil && afterGaugeSetCounter < 1 {
		if m.GaugeSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.GaugeSet at\n%s", m.GaugeSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.GaugeSet at\n%s with params: %#v", m.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *m.GaugeSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeSet != nil && afterGaugeSetCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.GaugeSet at\n%s", m.funcGaugeSetOrigin)
	}

	if !m.GaugeSetMock.invocationsDone() && afterGaugeSetCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.GaugeSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeSetMock.expectedInvocations), m.GaugeSetMock.expectedInvocationsOrigin, afterGaugeSetCounter)
	}
}

type mGroupedStorageMockGetOrCreateCounterCollector struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockGetOrCreateCounterCollectorExpectation
	expectations       []*GroupedStorageMockGetOrCreateCounterCollectorExpectation

	callArgs []*GroupedStorageMockGetOrCreateCounterCollectorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockGetOrCreateCounterCollectorExpectation specifies expectation struct of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockGetOrCreateCounterCollectorParams
	paramPtrs          *GroupedStorageMockGetOrCreateCounterCollectorParamPtrs
	expectationOrigins GroupedStorageMockGetOrCreateCounterCollectorExpectationOrigins
	results            *GroupedStorageMockGetOrCreateCounterCollectorResults
	returnOrigin       string
	Counter            uint64
}

// GroupedStorageMockGetOrCreateCounterCollectorParams contains parameters of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorParams struct {
	name       string
	labelNames []string
}

// GroupedStorageMockGetOrCreateCounterCollectorParamPtrs contains pointers to parameters of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorParamPtrs struct {
	name       *string
	labelNames *[]string
}

// GroupedStorageMockGetOrCreateCounterCollectorResults contains results of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorResults struct {
	cp1 *ConstCounterCollector
	err error
}

// GroupedStorageMockGetOrCreateCounterCollectorOrigins contains origins of expectations of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorExpectationOrigins struct {
	origin           string
	originName       string
	originLabelNames string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Optional() *mGroupedStorageMockGetOrCreateCounterCollector {
	mmGetOrCreateCounterCollector.optional = true
	return mmGetOrCreateCounterCollector
}

// Expect sets up expected params for GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Expect(name string, labelNames []string) *mGroupedStorageMockGetOrCreateCounterCollector {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation == nil {
		mmGetOrCreateCounterCollector.defaultExpectation = &GroupedStorageMockGetOrCreateCounterCollectorExpectation{}
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by ExpectParams functions")
	}

	mmGetOrCreateCounterCollector.defaultExpectation.params = &GroupedStorageMockGetOrCreateCounterCollectorParams{name, labelNames}
	mmGetOrCreateCounterCollector.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrCreateCounterCollector.expectations {
		if minimock.Equal(e.params, mmGetOrCreateCounterCollector.defaultExpectation.params) {
			mmGetOrCreateCounterCollector.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrCreateCounterCollector.defaultExpectation.params)
		}
	}

	return mmGetOrCreateCounterCollector
}

// ExpectNameParam1 sets up expected param name for GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) ExpectNameParam1(name string) *mGroupedStorageMockGetOrCreateCounterCollector {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation == nil {
		mmGetOrCreateCounterCollector.defaultExpectation = &GroupedStorageMockGetOrCreateCounterCollectorExpectation{}
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.params != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Expect")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs == nil {
		mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs = &GroupedStorageMockGetOrCreateCounterCollectorParamPtrs{}
	}
	mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs.name = &name
	mmGetOrCreateCounterCollector.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGetOrCreateCounterCollector
}

// ExpectLabelNamesParam2 sets up expected param labelNames for GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) ExpectLabelNamesParam2(labelNames []string) *mGroupedStorageMockGetOrCreateCounterCollector {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation == nil {
		mmGetOrCreateCounterCollector.defaultExpectation = &GroupedStorageMockGetOrCreateCounterCollectorExpectation{}
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.params != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Expect")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs == nil {
		mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs = &GroupedStorageMockGetOrCreateCounterCollectorParamPtrs{}
	}
	mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs.labelNames = &labelNames
	mmGetOrCreateCounterCollector.defaultExpectation.expectationOrigins.originLabelNames = minimock.CallerInfo(1)

	return mmGetOrCreateCounterCollector
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Inspect(f func(name string, labelNames []string)) *mGroupedStorageMockGetOrCreateCounterCollector {
	if mmGetOrCreateCounterCollector.mock.inspectFuncGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.GetOrCreateCounterCollector")
	}

	mmGetOrCreateCounterCollector.mock.inspectFuncGetOrCreateCounterCollector = f

	return mmGetOrCreateCounterCollector
}

// Return sets up results that will be returned by GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Return(cp1 *ConstCounterCollector, err error) *GroupedStorageMock {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation == nil {
		mmGetOrCreateCounterCollector.defaultExpectation = &GroupedStorageMockGetOrCreateCounterCollectorExpectation{mock: mmGetOrCreateCounterCollector.mock}
	}
	mmGetOrCreateCounterCollector.defaultExpectation.results = &GroupedStorageMockGetOrCreateCounterCollectorResults{cp1, err}
	mmGetOrCreateCounterCollector.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateCounterCollector.mock
}

// Set uses given function f to mock the GroupedStorage.GetOrCreateCounterCollector method
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Set(f func(name string, labelNames []string) (cp1 *ConstCounterCollector, err error)) *GroupedStorageMock {
	if mmGetOrCreateCounterCollector.defaultExpectation != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.GetOrCreateCounterCollector method")
	}

	if len(mmGetOrCreateCounterCollector.expectations) > 0 {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.GetOrCreateCounterCollector method")
	}

	mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector = f
	mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollectorOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateCounterCollector.mock
}

// When sets expectation for the GroupedStorage.GetOrCreateCounterCollector which will trigger the result defined by the following
// Then helper
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) When(name string, labelNames []string) *GroupedStorageMockGetOrCreateCounterCollectorExpectation {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	expectation := &GroupedStorageMockGetOrCreateCounterCollectorExpectation{
		mock:               mmGetOrCreateCounterCollector.mock,
		params:             &GroupedStorageMockGetOrCreateCounterCollectorParams{name, labelNames},
		expectationOrigins: GroupedStorageMockGetOrCreateCounterCollectorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrCreateCounterCollector.expectations = append(mmGetOrCreateCounterCollector.expectations, expectation)
	return expectation
}

// Then sets up GroupedStorage.GetOrCreateCounterCollector return parameters for the expectation previously defined by the When method
func (e *GroupedStorageMockGetOrCreateCounterCollectorExpectation) Then(cp1 *ConstCounterCollector, err error) *GroupedStorageMock {
	e.results = &GroupedStorageMockGetOrCreateCounterCollectorResults{cp1, err}
	return e.mock
}

// Times sets number of times GroupedStorage.GetOrCreateCounterCollector should be invoked
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Times(n uint64) *mGroupedStorageMockGetOrCreateCounterCollector {
	if n == 0 {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("Times of GroupedStorageMock.GetOrCreateCounterCollector mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrCreateCounterCollector.expectedInvocations, n)
	mmGetOrCreateCounterCollector.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateCounterCollector
}

func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) invocationsDone() bool {
	if len(mmGetOrCreateCounterCollector.expectations) == 0 && mmGetOrCreateCounterCollector.defaultExpectation == nil && mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrCreateCounterCollector.mock.afterGetOrCreateCounterCollectorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrCreateCounterCollector.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrCreateCounterCollector implements GroupedStorage
func (mmGetOrCreateCounterCollector *GroupedStorageMock) GetOrCreateCounterCollector(name string, labelNames []string) (cp1 *ConstCounterCollector, err error) {
	mm_atomic.AddUint64(&mmGetOrCreateCounterCollector.beforeGetOrCreateCounterCollectorCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrCreateCounterCollector.afterGetOrCreateCounterCollectorCounter, 1)

	mmGetOrCreateCounterCollector.t.Helper()

	if mmGetOrCreateCounterCollector.inspectFuncGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.inspectFuncGetOrCreateCounterCollector(name, labelNames)
	}

	mm_params := GroupedStorageMockGetOrCreateCounterCollectorParams{name, labelNames}

	// Record call args
	mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.mutex.Lock()
	mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.callArgs = append(mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.callArgs, &mm_params)
	mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.mutex.Unlock()

	for _, e := range mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockGetOrCreateCounterCollectorParams{name, labelNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetOrCreateCounterCollector.t.Errorf("GroupedStorageMock.GetOrCreateCounterCollector got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.labelNames != nil && !minimock.Equal(*mm_want_ptrs.labelNames, mm_got.labelNames) {
				mmGetOrCreateCounterCollector.t.Errorf("GroupedStorageMock.GetOrCreateCounterCollector got unexpected parameter labelNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.expectationOrigins.originLabelNames, *mm_want_ptrs.labelNames, mm_got.labelNames, minimock.Diff(*mm_want_ptrs.labelNames, mm_got.labelNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrCreateCounterCollector.t.Errorf("GroupedStorageMock.GetOrCreateCounterCollector got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrCreateCounterCollector.t.Fatal("No results are set for the GroupedStorageMock.GetOrCreateCounterCollector")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetOrCreateCounterCollector.funcGetOrCreateCounterCollector != nil {
		return mmGetOrCreateCounterCollector.funcGetOrCreateCounterCollector(name, labelNames)
	}
	mmGetOrCreateCounterCollector.t.Fatalf("Unexpected call to GroupedStorageMock.GetOrCreateCounterCollector. %v %v", name, labelNames)
	return
}

// GetOrCreateCounterCollectorAfterCounter returns a count of finished GroupedStorageMock.GetOrCreateCounterCollector invocations
func (mmGetOrCreateCounterCollector *GroupedStorageMock) GetOrCreateCounterCollectorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreateCounterCollector.afterGetOrCreateCounterCollectorCounter)
}

// GetOrCreateCounterCollectorBeforeCounter returns a count of GroupedStorageMock.GetOrCreateCounterCollector invocations
func (mmGetOrCreateCounterCollector *GroupedStorageMock) GetOrCreateCounterCollectorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreateCounterCollector.beforeGetOrCreateCounterCollectorCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.GetOrCreateCounterCollector.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Calls() []*GroupedStorageMockGetOrCreateCounterCollectorParams {
	mmGetOrCreateCounterCollector.mutex.RLock()

	argCopy := make([]*GroupedStorageMockGetOrCreateCounterCollectorParams, len(mmGetOrCreateCounterCollector.callArgs))
	copy(argCopy, mmGetOrCreateCounterCollector.callArgs)

	mmGetOrCreateCounterCollector.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrCreateCounterCollectorDone returns true if the count of the GetOrCreateCounterCollector invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockGetOrCreateCounterCollectorDone() bool {
	if m.GetOrCreateCounterCollectorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrCreateCounterCollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrCreateCounterCollectorMock.invocationsDone()
}

// MinimockGetOrCreateCounterCollectorInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockGetOrCreateCounterCollectorInspect() {
	for _, e := range m.GetOrCreateCounterCollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateCounterCollector at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrCreateCounterCollectorCounter := mm_atomic.LoadUint64(&m.afterGetOrCreateCounterCollectorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrCreateCounterCollectorMock.defaultExpectation != nil && afterGetOrCreateCounterCollectorCounter < 1 {
		if m.GetOrCreateCounterCollectorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateCounterCollector at\n%s", m.GetOrCreateCounterCollectorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateCounterCollector at\n%s with params: %#v", m.GetOrCreateCounterCollectorMock.defaultExpectation.expectationOrigins.origin, *m.GetOrCreateCounterCollectorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrCreateCounterCollector != nil && afterGetOrCreateCounterCollectorCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateCounterCollector at\n%s", m.funcGetOrCreateCounterCollectorOrigin)
	}

	if !m.GetOrCreateCounterCollectorMock.invocationsDone() && afterGetOrCreateCounterCollectorCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.GetOrCreateCounterCollector at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrCreateCounterCollectorMock.expectedInvocations), m.GetOrCreateCounterCollectorMock.expectedInvocationsOrigin, afterGetOrCreateCounterCollectorCounter)
	}
}

type mGroupedStorageMockGetOrCreateGaugeCollector struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockGetOrCreateGaugeCollectorExpectation
	expectations       []*GroupedStorageMockGetOrCreateGaugeCollectorExpectation

	callArgs []*GroupedStorageMockGetOrCreateGaugeCollectorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockGetOrCreateGaugeCollectorExpectation specifies expectation struct of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockGetOrCreateGaugeCollectorParams
	paramPtrs          *GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs
	expectationOrigins GroupedStorageMockGetOrCreateGaugeCollectorExpectationOrigins
	results            *GroupedStorageMockGetOrCreateGaugeCollectorResults
	returnOrigin       string
	Counter            uint64
}

// GroupedStorageMockGetOrCreateGaugeCollectorParams contains parameters of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorParams struct {
	name       string
	labelNames []string
}

// GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs contains pointers to parameters of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs struct {
	name       *string
	labelNames *[]string
}

// GroupedStorageMockGetOrCreateGaugeCollectorResults contains results of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorResults struct {
	cp1 *ConstGaugeCollector
	err error
}

// GroupedStorageMockGetOrCreateGaugeCollectorOrigins contains origins of expectations of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorExpectationOrigins struct {
	origin           string
	originName       string
	originLabelNames string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Optional() *mGroupedStorageMockGetOrCreateGaugeCollector {
	mmGetOrCreateGaugeCollector.optional = true
	return mmGetOrCreateGaugeCollector
}

// Expect sets up expected params for GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Expect(name string, labelNames []string) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation = &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{}
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by ExpectParams functions")
	}

	mmGetOrCreateGaugeCollector.defaultExpectation.params = &GroupedStorageMockGetOrCreateGaugeCollectorParams{name, labelNames}
	mmGetOrCreateGaugeCollector.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrCreateGaugeCollector.expectations {
		if minimock.Equal(e.params, mmGetOrCreateGaugeCollector.defaultExpectation.params) {
			mmGetOrCreateGaugeCollector.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrCreateGaugeCollector.defaultExpectation.params)
		}
	}

	return mmGetOrCreateGaugeCollector
}

// ExpectNameParam1 sets up expected param name for GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) ExpectNameParam1(name string) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation = &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{}
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.params != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Expect")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs = &GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs{}
	}
	mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs.name = &name
	mmGetOrCreateGaugeCollector.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGetOrCreateGaugeCollector
}

// ExpectLabelNamesParam2 sets up expected param labelNames for GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) ExpectLabelNamesParam2(labelNames []string) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation = &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{}
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.params != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Expect")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs = &GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs{}
	}
	mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs.labelNames = &labelNames
	mmGetOrCreateGaugeCollector.defaultExpectation.expectationOrigins.originLabelNames = minimock.CallerInfo(1)

	return mmGetOrCreateGaugeCollector
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Inspect(f func(name string, labelNames []string)) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if mmGetOrCreateGaugeCollector.mock.inspectFuncGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.GetOrCreateGaugeCollector")
	}

	mmGetOrCreateGaugeCollector.mock.inspectFuncGetOrCreateGaugeCollector = f

	return mmGetOrCreateGaugeCollector
}

// Return sets up results that will be returned by GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Return(cp1 *ConstGaugeCollector, err error) *GroupedStorageMock {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation = &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{mock: mmGetOrCreateGaugeCollector.mock}
	}
	mmGetOrCreateGaugeCollector.defaultExpectation.results = &GroupedStorageMockGetOrCreateGaugeCollectorResults{cp1, err}
	mmGetOrCreateGaugeCollector.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateGaugeCollector.mock
}

// Set uses given function f to mock the GroupedStorage.GetOrCreateGaugeCollector method
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Set(f func(name string, labelNames []string) (cp1 *ConstGaugeCollector, err error)) *GroupedStorageMock {
	if mmGetOrCreateGaugeCollector.defaultExpectation != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.GetOrCreateGaugeCollector method")
	}

	if len(mmGetOrCreateGaugeCollector.expectations) > 0 {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.GetOrCreateGaugeCollector method")
	}

	mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector = f
	mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollectorOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateGaugeCollector.mock
}

// When sets expectation for the GroupedStorage.GetOrCreateGaugeCollector which will trigger the result defined by the following
// Then helper
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) When(name string, labelNames []string) *GroupedStorageMockGetOrCreateGaugeCollectorExpectation {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	expectation := &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{
		mock:               mmGetOrCreateGaugeCollector.mock,
		params:             &GroupedStorageMockGetOrCreateGaugeCollectorParams{name, labelNames},
		expectationOrigins: GroupedStorageMockGetOrCreateGaugeCollectorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrCreateGaugeCollector.expectations = append(mmGetOrCreateGaugeCollector.expectations, expectation)
	return expectation
}

// Then sets up GroupedStorage.GetOrCreateGaugeCollector return parameters for the expectation previously defined by the When method
func (e *GroupedStorageMockGetOrCreateGaugeCollectorExpectation) Then(cp1 *ConstGaugeCollector, err error) *GroupedStorageMock {
	e.results = &GroupedStorageMockGetOrCreateGaugeCollectorResults{cp1, err}
	return e.mock
}

// Times sets number of times GroupedStorage.GetOrCreateGaugeCollector should be invoked
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Times(n uint64) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if n == 0 {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("Times of GroupedStorageMock.GetOrCreateGaugeCollector mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrCreateGaugeCollector.expectedInvocations, n)
	mmGetOrCreateGaugeCollector.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateGaugeCollector
}

func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) invocationsDone() bool {
	if len(mmGetOrCreateGaugeCollector.expectations) == 0 && mmGetOrCreateGaugeCollector.defaultExpectation == nil && mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrCreateGaugeCollector.mock.afterGetOrCreateGaugeCollectorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrCreateGaugeCollector.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrCreateGaugeCollector implements GroupedStorage
func (mmGetOrCreateGaugeCollector *GroupedStorageMock) GetOrCreateGaugeCollector(name string, labelNames []string) (cp1 *ConstGaugeCollector, err error) {
	mm_atomic.AddUint64(&mmGetOrCreateGaugeCollector.beforeGetOrCreateGaugeCollectorCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrCreateGaugeCollector.afterGetOrCreateGaugeCollectorCounter, 1)

	mmGetOrCreateGaugeCollector.t.Helper()

	if mmGetOrCreateGaugeCollector.inspectFuncGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.inspectFuncGetOrCreateGaugeCollector(name, labelNames)
	}

	mm_params := GroupedStorageMockGetOrCreateGaugeCollectorParams{name, labelNames}

	// Record call args
	mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.mutex.Lock()
	mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.callArgs = append(mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.callArgs, &mm_params)
	mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.mutex.Unlock()

	for _, e := range mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockGetOrCreateGaugeCollectorParams{name, labelNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetOrCreateGaugeCollector.t.Errorf("GroupedStorageMock.GetOrCreateGaugeCollector got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.labelNames != nil && !minimock.Equal(*mm_want_ptrs.labelNames, mm_got.labelNames) {
				mmGetOrCreateGaugeCollector.t.Errorf("GroupedStorageMock.GetOrCreateGaugeCollector got unexpected parameter labelNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.expectationOrigins.originLabelNames, *mm_want_ptrs.labelNames, mm_got.labelNames, minimock.Diff(*mm_want_ptrs.labelNames, mm_got.labelNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrCreateGaugeCollector.t.Errorf("GroupedStorageMock.GetOrCreateGaugeCollector got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrCreateGaugeCollector.t.Fatal("No results are set for the GroupedStorageMock.GetOrCreateGaugeCollector")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetOrCreateGaugeCollector.funcGetOrCreateGaugeCollector != nil {
		return mmGetOrCreateGaugeCollector.funcGetOrCreateGaugeCollector(name, labelNames)
	}
	mmGetOrCreateGaugeCollector.t.Fatalf("Unexpected call to GroupedStorageMock.GetOrCreateGaugeCollector. %v %v", name, labelNames)
	return
}

// GetOrCreateGaugeCollectorAfterCounter returns a count of finished GroupedStorageMock.GetOrCreateGaugeCollector invocations
func (mmGetOrCreateGaugeCollector *GroupedStorageMock) GetOrCreateGaugeCollectorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreateGaugeCollector.afterGetOrCreateGaugeCollectorCounter)
}

// GetOrCreateGaugeCollectorBeforeCounter returns a count of GroupedStorageMock.GetOrCreateGaugeCollector invocations
func (mmGetOrCreateGaugeCollector *GroupedStorageMock) GetOrCreateGaugeCollectorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreateGaugeCollector.beforeGetOrCreateGaugeCollectorCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.GetOrCreateGaugeCollector.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Calls() []*GroupedStorageMockGetOrCreateGaugeCollectorParams {
	mmGetOrCreateGaugeCollector.mutex.RLock()

	argCopy := make([]*GroupedStorageMockGetOrCreateGaugeCollectorParams, len(mmGetOrCreateGaugeCollector.callArgs))
	copy(argCopy, mmGetOrCreateGaugeCollector.callArgs)

	mmGetOrCreateGaugeCollector.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrCreateGaugeCollectorDone returns true if the count of the GetOrCreateGaugeCollector invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockGetOrCreateGaugeCollectorDone() bool {
	if m.GetOrCreateGaugeCollectorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrCreateGaugeCollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrCreateGaugeCollectorMock.invocationsDone()
}

// MinimockGetOrCreateGaugeCollectorInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockGetOrCreateGaugeCollectorInspect() {
	for _, e := range m.GetOrCreateGaugeCollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrCreateGaugeCollectorCounter := mm_atomic.LoadUint64(&m.afterGetOrCreateGaugeCollectorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrCreateGaugeCollectorMock.defaultExpectation != nil && afterGetOrCreateGaugeCollectorCounter < 1 {
		if m.GetOrCreateGaugeCollectorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s", m.GetOrCreateGaugeCollectorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s with params: %#v", m.GetOrCreateGaugeCollectorMock.defaultExpectation.expectationOrigins.origin, *m.GetOrCreateGaugeCollectorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrCreateGaugeCollector != nil && afterGetOrCreateGaugeCollectorCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s", m.funcGetOrCreateGaugeCollectorOrigin)
	}

	if !m.GetOrCreateGaugeCollectorMock.invocationsDone() && afterGetOrCreateGaugeCollectorCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrCreateGaugeCollectorMock.expectedInvocations), m.GetOrCreateGaugeCollectorMock.expectedInvocationsOrigin, afterGetOrCreateGaugeCollectorCounter)
	}
}

type mGroupedStorageMockRegisterer struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockRegistererExpectation
	expectations       []*GroupedStorageMockRegistererExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockRegistererExpectation specifies expectation struct of the GroupedStorage.Registerer
type GroupedStorageMockRegistererExpectation struct {
	mock *GroupedStorageMock

	results      *GroupedStorageMockRegistererResults
	returnOrigin string
	Counter      uint64
}

// GroupedStorageMockRegistererResults contains results of the GroupedStorage.Registerer
type GroupedStorageMockRegistererResults struct {
	r1 prometheus.Registerer
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterer *mGroupedStorageMockRegisterer) Optional() *mGroupedStorageMockRegisterer {
	mmRegisterer.optional = true
	return mmRegisterer
}

// Expect sets up expected params for GroupedStorage.Registerer
func (mmRegisterer *mGroupedStorageMockRegisterer) Expect() *mGroupedStorageMockRegisterer {
	if mmRegisterer.mock.funcRegisterer != nil {
		mmRegisterer.mock.t.Fatalf("GroupedStorageMock.Registerer mock is already set by Set")
	}

	if mmRegisterer.defaultExpectation == nil {
		mmRegisterer.defaultExpectation = &GroupedStorageMockRegistererExpectation{}
	}

	return mmRegisterer
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.Registerer
func (mmRegisterer *mGroupedStorageMockRegisterer) Inspect(f func()) *mGroupedStorageMockRegisterer {
	if mmRegisterer.mock.inspectFuncRegisterer != nil {
		mmRegisterer.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.Registerer")
	}

	mmRegisterer.mock.inspectFuncRegisterer = f

	return mmRegisterer
}

// Return sets up results that will be returned by GroupedStorage.Registerer
func (mmRegisterer *mGroupedStorageMockRegisterer) Return(r1 prometheus.Registerer) *GroupedStorageMock {
	if mmRegisterer.mock.funcRegisterer != nil {
		mmRegisterer.mock.t.Fatalf("GroupedStorageMock.Registerer mock is already set by Set")
	}

	if mmRegisterer.defaultExpectation == nil {
		mmRegisterer.defaultExpectation = &GroupedStorageMockRegistererExpectation{mock: mmRegisterer.mock}
	}
	mmRegisterer.defaultExpectation.results = &GroupedStorageMockRegistererResults{r1}
	mmRegisterer.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterer.mock
}

// Set uses given function f to mock the GroupedStorage.Registerer method
func (mmRegisterer *mGroupedStorageMockRegisterer) Set(f func() (r1 prometheus.Registerer)) *GroupedStorageMock {
	if mmRegisterer.defaultExpectation != nil {
		mmRegisterer.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.Registerer method")
	}

	if len(mmRegisterer.expectations) > 0 {
		mmRegisterer.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.Registerer method")
	}

	mmRegisterer.mock.funcRegisterer = f
	mmRegisterer.mock.funcRegistererOrigin = minimock.CallerInfo(1)
	return mmRegisterer.mock
}

// Times sets number of times GroupedStorage.Registerer should be invoked
func (mmRegisterer *mGroupedStorageMockRegisterer) Times(n uint64) *mGroupedStorageMockRegisterer {
	if n == 0 {
		mmRegisterer.mock.t.Fatalf("Times of GroupedStorageMock.Registerer mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterer.expectedInvocations, n)
	mmRegisterer.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterer
}

func (mmRegisterer *mGroupedStorageMockRegisterer) invocationsDone() bool {
	if len(mmRegisterer.expectations) == 0 && mmRegisterer.defaultExpectation == nil && mmRegisterer.mock.funcRegisterer == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterer.mock.afterRegistererCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterer.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Registerer implements GroupedStorage
func (mmRegisterer *GroupedStorageMock) Registerer() (r1 prometheus.Registerer) {
	mm_atomic.AddUint64(&mmRegisterer.beforeRegistererCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterer.afterRegistererCounter, 1)

	mmRegisterer.t.Helper()

	if mmRegisterer.inspectFuncRegisterer != nil {
		mmRegisterer.inspectFuncRegisterer()
	}

	if mmRegisterer.RegistererMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterer.RegistererMock.defaultExpectation.Counter, 1)

		mm_results := mmRegisterer.RegistererMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterer.t.Fatal("No results are set for the GroupedStorageMock.Registerer")
		}
		return (*mm_results).r1
	}
	if mmRegisterer.funcRegisterer != nil {
		return mmRegisterer.funcRegisterer()
	}
	mmRegisterer.t.Fatalf("Unexpected call to GroupedStorageMock.Registerer.")
	return
}

// RegistererAfterCounter returns a count of finished GroupedStorageMock.Registerer invocations
func (mmRegisterer *GroupedStorageMock) RegistererAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterer.afterRegistererCounter)
}

// RegistererBeforeCounter returns a count of GroupedStorageMock.Registerer invocations
func (mmRegisterer *GroupedStorageMock) RegistererBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterer.beforeRegistererCounter)
}

// MinimockRegistererDone returns true if the count of the Registerer invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockRegistererDone() bool {
	if m.RegistererMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegistererMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegistererMock.invocationsDone()
}

// MinimockRegistererInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockRegistererInspect() {
	for _, e := range m.RegistererMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GroupedStorageMock.Registerer")
		}
	}

	afterRegistererCounter := mm_atomic.LoadUint64(&m.afterRegistererCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegistererMock.defaultExpectation != nil && afterRegistererCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.Registerer at\n%s", m.RegistererMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterer != nil && afterRegistererCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.Registerer at\n%s", m.funcRegistererOrigin)
	}

	if !m.RegistererMock.invocationsDone() && afterRegistererCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.Registerer at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegistererMock.expectedInvocations), m.RegistererMock.expectedInvocationsOrigin, afterRegistererCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GroupedStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCounterAddInspect()

			m.MinimockExpireGroupMetricByNameInspect()

			m.MinimockExpireGroupMetricsInspect()

			m.MinimockGaugeSetInspect()

			m.MinimockGetOrCreateCounterCollectorInspect()

			m.MinimockGetOrCreateGaugeCollectorInspect()

			m.MinimockRegistererInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GroupedStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GroupedStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCounterAddDone() &&
		m.MinimockExpireGroupMetricByNameDone() &&
		m.MinimockExpireGroupMetricsDone() &&
		m.MinimockGaugeSetDone() &&
		m.MinimockGetOrCreateCounterCollectorDone() &&
		m.MinimockGetOrCreateGaugeCollectorDone() &&
		m.MinimockRegistererDone()
}
