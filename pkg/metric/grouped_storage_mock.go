// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package metric

//go:generate minimock -i github.com/flant/shell-operator/pkg/metric.GroupedStorage -o grouped_storage_mock.go -n GroupedStorageMock -p metric

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/prometheus/client_golang/prometheus"
)

// GroupedStorageMock implements GroupedStorage
type GroupedStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCounterAdd          func(group string, name string, value float64, labels map[string]string)
	funcCounterAddOrigin    string
	inspectFuncCounterAdd   func(group string, name string, value float64, labels map[string]string)
	afterCounterAddCounter  uint64
	beforeCounterAddCounter uint64
	CounterAddMock          mGroupedStorageMockCounterAdd

	funcExpireGroupMetrics          func(group string)
	funcExpireGroupMetricsOrigin    string
	inspectFuncExpireGroupMetrics   func(group string)
	afterExpireGroupMetricsCounter  uint64
	beforeExpireGroupMetricsCounter uint64
	ExpireGroupMetricsMock          mGroupedStorageMockExpireGroupMetrics

	funcGaugeSet          func(group string, name string, value float64, labels map[string]string)
	funcGaugeSetOrigin    string
	inspectFuncGaugeSet   func(group string, name string, value float64, labels map[string]string)
	afterGaugeSetCounter  uint64
	beforeGaugeSetCounter uint64
	GaugeSetMock          mGroupedStorageMockGaugeSet

	funcGetOrCreateCounterCollector          func(name string, labelNames []string) (cp1 *ConstCounterCollector, err error)
	funcGetOrCreateCounterCollectorOrigin    string
	inspectFuncGetOrCreateCounterCollector   func(name string, labelNames []string)
	afterGetOrCreateCounterCollectorCounter  uint64
	beforeGetOrCreateCounterCollectorCounter uint64
	GetOrCreateCounterCollectorMock          mGroupedStorageMockGetOrCreateCounterCollector

	funcGetOrCreateGaugeCollector          func(name string, labelNames []string) (cp1 *ConstGaugeCollector, err error)
	funcGetOrCreateGaugeCollectorOrigin    string
	inspectFuncGetOrCreateGaugeCollector   func(name string, labelNames []string)
	afterGetOrCreateGaugeCollectorCounter  uint64
	beforeGetOrCreateGaugeCollectorCounter uint64
	GetOrCreateGaugeCollectorMock          mGroupedStorageMockGetOrCreateGaugeCollector

	funcRegisterer          func() (r1 prometheus.Registerer)
	funcRegistererOrigin    string
	inspectFuncRegisterer   func()
	afterRegistererCounter  uint64
	beforeRegistererCounter uint64
	RegistererMock          mGroupedStorageMockRegisterer
}

// NewGroupedStorageMock returns a mock for GroupedStorage
func NewGroupedStorageMock(t minimock.Tester) *GroupedStorageMock {
	m := &GroupedStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CounterAddMock = mGroupedStorageMockCounterAdd{mock: m}
	m.CounterAddMock.callArgs = []*GroupedStorageMockCounterAddParams{}

	m.ExpireGroupMetricsMock = mGroupedStorageMockExpireGroupMetrics{mock: m}
	m.ExpireGroupMetricsMock.callArgs = []*GroupedStorageMockExpireGroupMetricsParams{}

	m.GaugeSetMock = mGroupedStorageMockGaugeSet{mock: m}
	m.GaugeSetMock.callArgs = []*GroupedStorageMockGaugeSetParams{}

	m.GetOrCreateCounterCollectorMock = mGroupedStorageMockGetOrCreateCounterCollector{mock: m}
	m.GetOrCreateCounterCollectorMock.callArgs = []*GroupedStorageMockGetOrCreateCounterCollectorParams{}

	m.GetOrCreateGaugeCollectorMock = mGroupedStorageMockGetOrCreateGaugeCollector{mock: m}
	m.GetOrCreateGaugeCollectorMock.callArgs = []*GroupedStorageMockGetOrCreateGaugeCollectorParams{}

	m.RegistererMock = mGroupedStorageMockRegisterer{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mGroupedStorageMockCounterAdd struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockCounterAddExpectation
	expectations       []*GroupedStorageMockCounterAddExpectation

	callArgs []*GroupedStorageMockCounterAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockCounterAddExpectation specifies expectation struct of the GroupedStorage.CounterAdd
type GroupedStorageMockCounterAddExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockCounterAddParams
	paramPtrs          *GroupedStorageMockCounterAddParamPtrs
	expectationOrigins GroupedStorageMockCounterAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// GroupedStorageMockCounterAddParams contains parameters of the GroupedStorage.CounterAdd
type GroupedStorageMockCounterAddParams struct {
	group  string
	name   string
	value  float64
	labels map[string]string
}

// GroupedStorageMockCounterAddParamPtrs contains pointers to parameters of the GroupedStorage.CounterAdd
type GroupedStorageMockCounterAddParamPtrs struct {
	group  *string
	name   *string
	value  *float64
	labels *map[string]string
}

// GroupedStorageMockCounterAddOrigins contains origins of expectations of the GroupedStorage.CounterAdd
type GroupedStorageMockCounterAddExpectationOrigins struct {
	origin       string
	originGroup  string
	originName   string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Optional() *mGroupedStorageMockCounterAdd {
	mmCounterAdd.optional = true
	return mmCounterAdd
}

// Expect sets up expected params for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Expect(group string, name string, value float64, labels map[string]string) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.paramPtrs != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by ExpectParams functions")
	}

	mmCounterAdd.defaultExpectation.params = &GroupedStorageMockCounterAddParams{group, name, value, labels}
	mmCounterAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounterAdd.expectations {
		if minimock.Equal(e.params, mmCounterAdd.defaultExpectation.params) {
			mmCounterAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounterAdd.defaultExpectation.params)
		}
	}

	return mmCounterAdd
}

// ExpectGroupParam1 sets up expected param group for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) ExpectGroupParam1(group string) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &GroupedStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.group = &group
	mmCounterAdd.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectNameParam2 sets up expected param name for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) ExpectNameParam2(name string) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &GroupedStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.name = &name
	mmCounterAdd.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectValueParam3 sets up expected param value for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) ExpectValueParam3(value float64) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &GroupedStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.value = &value
	mmCounterAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectLabelsParam4 sets up expected param labels for GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) ExpectLabelsParam4(labels map[string]string) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &GroupedStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.labels = &labels
	mmCounterAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounterAdd
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Inspect(f func(group string, name string, value float64, labels map[string]string)) *mGroupedStorageMockCounterAdd {
	if mmCounterAdd.mock.inspectFuncCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.CounterAdd")
	}

	mmCounterAdd.mock.inspectFuncCounterAdd = f

	return mmCounterAdd
}

// Return sets up results that will be returned by GroupedStorage.CounterAdd
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Return() *GroupedStorageMock {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("GroupedStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &GroupedStorageMockCounterAddExpectation{mock: mmCounterAdd.mock}
	}

	mmCounterAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// Set uses given function f to mock the GroupedStorage.CounterAdd method
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Set(f func(group string, name string, value float64, labels map[string]string)) *GroupedStorageMock {
	if mmCounterAdd.defaultExpectation != nil {
		mmCounterAdd.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.CounterAdd method")
	}

	if len(mmCounterAdd.expectations) > 0 {
		mmCounterAdd.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.CounterAdd method")
	}

	mmCounterAdd.mock.funcCounterAdd = f
	mmCounterAdd.mock.funcCounterAddOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// Times sets number of times GroupedStorage.CounterAdd should be invoked
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Times(n uint64) *mGroupedStorageMockCounterAdd {
	if n == 0 {
		mmCounterAdd.mock.t.Fatalf("Times of GroupedStorageMock.CounterAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounterAdd.expectedInvocations, n)
	mmCounterAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounterAdd
}

func (mmCounterAdd *mGroupedStorageMockCounterAdd) invocationsDone() bool {
	if len(mmCounterAdd.expectations) == 0 && mmCounterAdd.defaultExpectation == nil && mmCounterAdd.mock.funcCounterAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounterAdd.mock.afterCounterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounterAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CounterAdd implements GroupedStorage
func (mmCounterAdd *GroupedStorageMock) CounterAdd(group string, name string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmCounterAdd.beforeCounterAddCounter, 1)
	defer mm_atomic.AddUint64(&mmCounterAdd.afterCounterAddCounter, 1)

	mmCounterAdd.t.Helper()

	if mmCounterAdd.inspectFuncCounterAdd != nil {
		mmCounterAdd.inspectFuncCounterAdd(group, name, value, labels)
	}

	mm_params := GroupedStorageMockCounterAddParams{group, name, value, labels}

	// Record call args
	mmCounterAdd.CounterAddMock.mutex.Lock()
	mmCounterAdd.CounterAddMock.callArgs = append(mmCounterAdd.CounterAddMock.callArgs, &mm_params)
	mmCounterAdd.CounterAddMock.mutex.Unlock()

	for _, e := range mmCounterAdd.CounterAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCounterAdd.CounterAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounterAdd.CounterAddMock.defaultExpectation.Counter, 1)
		mm_want := mmCounterAdd.CounterAddMock.defaultExpectation.params
		mm_want_ptrs := mmCounterAdd.CounterAddMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockCounterAddParams{group, name, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounterAdd.t.Errorf("GroupedStorageMock.CounterAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCounterAdd.funcCounterAdd != nil {
		mmCounterAdd.funcCounterAdd(group, name, value, labels)
		return
	}
	mmCounterAdd.t.Fatalf("Unexpected call to GroupedStorageMock.CounterAdd. %v %v %v %v", group, name, value, labels)

}

// CounterAddAfterCounter returns a count of finished GroupedStorageMock.CounterAdd invocations
func (mmCounterAdd *GroupedStorageMock) CounterAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.afterCounterAddCounter)
}

// CounterAddBeforeCounter returns a count of GroupedStorageMock.CounterAdd invocations
func (mmCounterAdd *GroupedStorageMock) CounterAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.beforeCounterAddCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.CounterAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounterAdd *mGroupedStorageMockCounterAdd) Calls() []*GroupedStorageMockCounterAddParams {
	mmCounterAdd.mutex.RLock()

	argCopy := make([]*GroupedStorageMockCounterAddParams, len(mmCounterAdd.callArgs))
	copy(argCopy, mmCounterAdd.callArgs)

	mmCounterAdd.mutex.RUnlock()

	return argCopy
}

// MinimockCounterAddDone returns true if the count of the CounterAdd invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockCounterAddDone() bool {
	if m.CounterAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterAddMock.invocationsDone()
}

// MinimockCounterAddInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockCounterAddInspect() {
	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.CounterAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterAddCounter := mm_atomic.LoadUint64(&m.afterCounterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterAddMock.defaultExpectation != nil && afterCounterAddCounter < 1 {
		if m.CounterAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.CounterAdd at\n%s", m.CounterAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.CounterAdd at\n%s with params: %#v", m.CounterAddMock.defaultExpectation.expectationOrigins.origin, *m.CounterAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounterAdd != nil && afterCounterAddCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.CounterAdd at\n%s", m.funcCounterAddOrigin)
	}

	if !m.CounterAddMock.invocationsDone() && afterCounterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.CounterAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterAddMock.expectedInvocations), m.CounterAddMock.expectedInvocationsOrigin, afterCounterAddCounter)
	}
}

type mGroupedStorageMockExpireGroupMetrics struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockExpireGroupMetricsExpectation
	expectations       []*GroupedStorageMockExpireGroupMetricsExpectation

	callArgs []*GroupedStorageMockExpireGroupMetricsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockExpireGroupMetricsExpectation specifies expectation struct of the GroupedStorage.ExpireGroupMetrics
type GroupedStorageMockExpireGroupMetricsExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockExpireGroupMetricsParams
	paramPtrs          *GroupedStorageMockExpireGroupMetricsParamPtrs
	expectationOrigins GroupedStorageMockExpireGroupMetricsExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// GroupedStorageMockExpireGroupMetricsParams contains parameters of the GroupedStorage.ExpireGroupMetrics
type GroupedStorageMockExpireGroupMetricsParams struct {
	group string
}

// GroupedStorageMockExpireGroupMetricsParamPtrs contains pointers to parameters of the GroupedStorage.ExpireGroupMetrics
type GroupedStorageMockExpireGroupMetricsParamPtrs struct {
	group *string
}

// GroupedStorageMockExpireGroupMetricsOrigins contains origins of expectations of the GroupedStorage.ExpireGroupMetrics
type GroupedStorageMockExpireGroupMetricsExpectationOrigins struct {
	origin      string
	originGroup string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Optional() *mGroupedStorageMockExpireGroupMetrics {
	mmExpireGroupMetrics.optional = true
	return mmExpireGroupMetrics
}

// Expect sets up expected params for GroupedStorage.ExpireGroupMetrics
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Expect(group string) *mGroupedStorageMockExpireGroupMetrics {
	if mmExpireGroupMetrics.mock.funcExpireGroupMetrics != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by Set")
	}

	if mmExpireGroupMetrics.defaultExpectation == nil {
		mmExpireGroupMetrics.defaultExpectation = &GroupedStorageMockExpireGroupMetricsExpectation{}
	}

	if mmExpireGroupMetrics.defaultExpectation.paramPtrs != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by ExpectParams functions")
	}

	mmExpireGroupMetrics.defaultExpectation.params = &GroupedStorageMockExpireGroupMetricsParams{group}
	mmExpireGroupMetrics.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmExpireGroupMetrics.expectations {
		if minimock.Equal(e.params, mmExpireGroupMetrics.defaultExpectation.params) {
			mmExpireGroupMetrics.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExpireGroupMetrics.defaultExpectation.params)
		}
	}

	return mmExpireGroupMetrics
}

// ExpectGroupParam1 sets up expected param group for GroupedStorage.ExpireGroupMetrics
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) ExpectGroupParam1(group string) *mGroupedStorageMockExpireGroupMetrics {
	if mmExpireGroupMetrics.mock.funcExpireGroupMetrics != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by Set")
	}

	if mmExpireGroupMetrics.defaultExpectation == nil {
		mmExpireGroupMetrics.defaultExpectation = &GroupedStorageMockExpireGroupMetricsExpectation{}
	}

	if mmExpireGroupMetrics.defaultExpectation.params != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by Expect")
	}

	if mmExpireGroupMetrics.defaultExpectation.paramPtrs == nil {
		mmExpireGroupMetrics.defaultExpectation.paramPtrs = &GroupedStorageMockExpireGroupMetricsParamPtrs{}
	}
	mmExpireGroupMetrics.defaultExpectation.paramPtrs.group = &group
	mmExpireGroupMetrics.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmExpireGroupMetrics
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.ExpireGroupMetrics
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Inspect(f func(group string)) *mGroupedStorageMockExpireGroupMetrics {
	if mmExpireGroupMetrics.mock.inspectFuncExpireGroupMetrics != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.ExpireGroupMetrics")
	}

	mmExpireGroupMetrics.mock.inspectFuncExpireGroupMetrics = f

	return mmExpireGroupMetrics
}

// Return sets up results that will be returned by GroupedStorage.ExpireGroupMetrics
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Return() *GroupedStorageMock {
	if mmExpireGroupMetrics.mock.funcExpireGroupMetrics != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("GroupedStorageMock.ExpireGroupMetrics mock is already set by Set")
	}

	if mmExpireGroupMetrics.defaultExpectation == nil {
		mmExpireGroupMetrics.defaultExpectation = &GroupedStorageMockExpireGroupMetricsExpectation{mock: mmExpireGroupMetrics.mock}
	}

	mmExpireGroupMetrics.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmExpireGroupMetrics.mock
}

// Set uses given function f to mock the GroupedStorage.ExpireGroupMetrics method
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Set(f func(group string)) *GroupedStorageMock {
	if mmExpireGroupMetrics.defaultExpectation != nil {
		mmExpireGroupMetrics.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.ExpireGroupMetrics method")
	}

	if len(mmExpireGroupMetrics.expectations) > 0 {
		mmExpireGroupMetrics.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.ExpireGroupMetrics method")
	}

	mmExpireGroupMetrics.mock.funcExpireGroupMetrics = f
	mmExpireGroupMetrics.mock.funcExpireGroupMetricsOrigin = minimock.CallerInfo(1)
	return mmExpireGroupMetrics.mock
}

// Times sets number of times GroupedStorage.ExpireGroupMetrics should be invoked
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Times(n uint64) *mGroupedStorageMockExpireGroupMetrics {
	if n == 0 {
		mmExpireGroupMetrics.mock.t.Fatalf("Times of GroupedStorageMock.ExpireGroupMetrics mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmExpireGroupMetrics.expectedInvocations, n)
	mmExpireGroupMetrics.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmExpireGroupMetrics
}

func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) invocationsDone() bool {
	if len(mmExpireGroupMetrics.expectations) == 0 && mmExpireGroupMetrics.defaultExpectation == nil && mmExpireGroupMetrics.mock.funcExpireGroupMetrics == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmExpireGroupMetrics.mock.afterExpireGroupMetricsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmExpireGroupMetrics.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ExpireGroupMetrics implements GroupedStorage
func (mmExpireGroupMetrics *GroupedStorageMock) ExpireGroupMetrics(group string) {
	mm_atomic.AddUint64(&mmExpireGroupMetrics.beforeExpireGroupMetricsCounter, 1)
	defer mm_atomic.AddUint64(&mmExpireGroupMetrics.afterExpireGroupMetricsCounter, 1)

	mmExpireGroupMetrics.t.Helper()

	if mmExpireGroupMetrics.inspectFuncExpireGroupMetrics != nil {
		mmExpireGroupMetrics.inspectFuncExpireGroupMetrics(group)
	}

	mm_params := GroupedStorageMockExpireGroupMetricsParams{group}

	// Record call args
	mmExpireGroupMetrics.ExpireGroupMetricsMock.mutex.Lock()
	mmExpireGroupMetrics.ExpireGroupMetricsMock.callArgs = append(mmExpireGroupMetrics.ExpireGroupMetricsMock.callArgs, &mm_params)
	mmExpireGroupMetrics.ExpireGroupMetricsMock.mutex.Unlock()

	for _, e := range mmExpireGroupMetrics.ExpireGroupMetricsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.Counter, 1)
		mm_want := mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.params
		mm_want_ptrs := mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockExpireGroupMetricsParams{group}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmExpireGroupMetrics.t.Errorf("GroupedStorageMock.ExpireGroupMetrics got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExpireGroupMetrics.t.Errorf("GroupedStorageMock.ExpireGroupMetrics got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmExpireGroupMetrics.ExpireGroupMetricsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmExpireGroupMetrics.funcExpireGroupMetrics != nil {
		mmExpireGroupMetrics.funcExpireGroupMetrics(group)
		return
	}
	mmExpireGroupMetrics.t.Fatalf("Unexpected call to GroupedStorageMock.ExpireGroupMetrics. %v", group)

}

// ExpireGroupMetricsAfterCounter returns a count of finished GroupedStorageMock.ExpireGroupMetrics invocations
func (mmExpireGroupMetrics *GroupedStorageMock) ExpireGroupMetricsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpireGroupMetrics.afterExpireGroupMetricsCounter)
}

// ExpireGroupMetricsBeforeCounter returns a count of GroupedStorageMock.ExpireGroupMetrics invocations
func (mmExpireGroupMetrics *GroupedStorageMock) ExpireGroupMetricsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExpireGroupMetrics.beforeExpireGroupMetricsCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.ExpireGroupMetrics.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExpireGroupMetrics *mGroupedStorageMockExpireGroupMetrics) Calls() []*GroupedStorageMockExpireGroupMetricsParams {
	mmExpireGroupMetrics.mutex.RLock()

	argCopy := make([]*GroupedStorageMockExpireGroupMetricsParams, len(mmExpireGroupMetrics.callArgs))
	copy(argCopy, mmExpireGroupMetrics.callArgs)

	mmExpireGroupMetrics.mutex.RUnlock()

	return argCopy
}

// MinimockExpireGroupMetricsDone returns true if the count of the ExpireGroupMetrics invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockExpireGroupMetricsDone() bool {
	if m.ExpireGroupMetricsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ExpireGroupMetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ExpireGroupMetricsMock.invocationsDone()
}

// MinimockExpireGroupMetricsInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockExpireGroupMetricsInspect() {
	for _, e := range m.ExpireGroupMetricsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetrics at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterExpireGroupMetricsCounter := mm_atomic.LoadUint64(&m.afterExpireGroupMetricsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ExpireGroupMetricsMock.defaultExpectation != nil && afterExpireGroupMetricsCounter < 1 {
		if m.ExpireGroupMetricsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetrics at\n%s", m.ExpireGroupMetricsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetrics at\n%s with params: %#v", m.ExpireGroupMetricsMock.defaultExpectation.expectationOrigins.origin, *m.ExpireGroupMetricsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExpireGroupMetrics != nil && afterExpireGroupMetricsCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.ExpireGroupMetrics at\n%s", m.funcExpireGroupMetricsOrigin)
	}

	if !m.ExpireGroupMetricsMock.invocationsDone() && afterExpireGroupMetricsCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.ExpireGroupMetrics at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ExpireGroupMetricsMock.expectedInvocations), m.ExpireGroupMetricsMock.expectedInvocationsOrigin, afterExpireGroupMetricsCounter)
	}
}

type mGroupedStorageMockGaugeSet struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockGaugeSetExpectation
	expectations       []*GroupedStorageMockGaugeSetExpectation

	callArgs []*GroupedStorageMockGaugeSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockGaugeSetExpectation specifies expectation struct of the GroupedStorage.GaugeSet
type GroupedStorageMockGaugeSetExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockGaugeSetParams
	paramPtrs          *GroupedStorageMockGaugeSetParamPtrs
	expectationOrigins GroupedStorageMockGaugeSetExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// GroupedStorageMockGaugeSetParams contains parameters of the GroupedStorage.GaugeSet
type GroupedStorageMockGaugeSetParams struct {
	group  string
	name   string
	value  float64
	labels map[string]string
}

// GroupedStorageMockGaugeSetParamPtrs contains pointers to parameters of the GroupedStorage.GaugeSet
type GroupedStorageMockGaugeSetParamPtrs struct {
	group  *string
	name   *string
	value  *float64
	labels *map[string]string
}

// GroupedStorageMockGaugeSetOrigins contains origins of expectations of the GroupedStorage.GaugeSet
type GroupedStorageMockGaugeSetExpectationOrigins struct {
	origin       string
	originGroup  string
	originName   string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Optional() *mGroupedStorageMockGaugeSet {
	mmGaugeSet.optional = true
	return mmGaugeSet
}

// Expect sets up expected params for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Expect(group string, name string, value float64, labels map[string]string) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.paramPtrs != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by ExpectParams functions")
	}

	mmGaugeSet.defaultExpectation.params = &GroupedStorageMockGaugeSetParams{group, name, value, labels}
	mmGaugeSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeSet.expectations {
		if minimock.Equal(e.params, mmGaugeSet.defaultExpectation.params) {
			mmGaugeSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeSet.defaultExpectation.params)
		}
	}

	return mmGaugeSet
}

// ExpectGroupParam1 sets up expected param group for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) ExpectGroupParam1(group string) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &GroupedStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.group = &group
	mmGaugeSet.defaultExpectation.expectationOrigins.originGroup = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectNameParam2 sets up expected param name for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) ExpectNameParam2(name string) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &GroupedStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.name = &name
	mmGaugeSet.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectValueParam3 sets up expected param value for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) ExpectValueParam3(value float64) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &GroupedStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.value = &value
	mmGaugeSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectLabelsParam4 sets up expected param labels for GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) ExpectLabelsParam4(labels map[string]string) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &GroupedStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeSet.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeSet
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Inspect(f func(group string, name string, value float64, labels map[string]string)) *mGroupedStorageMockGaugeSet {
	if mmGaugeSet.mock.inspectFuncGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.GaugeSet")
	}

	mmGaugeSet.mock.inspectFuncGaugeSet = f

	return mmGaugeSet
}

// Return sets up results that will be returned by GroupedStorage.GaugeSet
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Return() *GroupedStorageMock {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("GroupedStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &GroupedStorageMockGaugeSetExpectation{mock: mmGaugeSet.mock}
	}

	mmGaugeSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// Set uses given function f to mock the GroupedStorage.GaugeSet method
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Set(f func(group string, name string, value float64, labels map[string]string)) *GroupedStorageMock {
	if mmGaugeSet.defaultExpectation != nil {
		mmGaugeSet.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.GaugeSet method")
	}

	if len(mmGaugeSet.expectations) > 0 {
		mmGaugeSet.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.GaugeSet method")
	}

	mmGaugeSet.mock.funcGaugeSet = f
	mmGaugeSet.mock.funcGaugeSetOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// Times sets number of times GroupedStorage.GaugeSet should be invoked
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Times(n uint64) *mGroupedStorageMockGaugeSet {
	if n == 0 {
		mmGaugeSet.mock.t.Fatalf("Times of GroupedStorageMock.GaugeSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeSet.expectedInvocations, n)
	mmGaugeSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeSet
}

func (mmGaugeSet *mGroupedStorageMockGaugeSet) invocationsDone() bool {
	if len(mmGaugeSet.expectations) == 0 && mmGaugeSet.defaultExpectation == nil && mmGaugeSet.mock.funcGaugeSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeSet.mock.afterGaugeSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeSet implements GroupedStorage
func (mmGaugeSet *GroupedStorageMock) GaugeSet(group string, name string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeSet.beforeGaugeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeSet.afterGaugeSetCounter, 1)

	mmGaugeSet.t.Helper()

	if mmGaugeSet.inspectFuncGaugeSet != nil {
		mmGaugeSet.inspectFuncGaugeSet(group, name, value, labels)
	}

	mm_params := GroupedStorageMockGaugeSetParams{group, name, value, labels}

	// Record call args
	mmGaugeSet.GaugeSetMock.mutex.Lock()
	mmGaugeSet.GaugeSetMock.callArgs = append(mmGaugeSet.GaugeSetMock.callArgs, &mm_params)
	mmGaugeSet.GaugeSetMock.mutex.Unlock()

	for _, e := range mmGaugeSet.GaugeSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeSet.GaugeSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeSet.GaugeSetMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeSet.GaugeSetMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeSet.GaugeSetMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockGaugeSetParams{group, name, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.group != nil && !minimock.Equal(*mm_want_ptrs.group, mm_got.group) {
				mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameter group, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originGroup, *mm_want_ptrs.group, mm_got.group, minimock.Diff(*mm_want_ptrs.group, mm_got.group))
			}

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeSet.t.Errorf("GroupedStorageMock.GaugeSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeSet.funcGaugeSet != nil {
		mmGaugeSet.funcGaugeSet(group, name, value, labels)
		return
	}
	mmGaugeSet.t.Fatalf("Unexpected call to GroupedStorageMock.GaugeSet. %v %v %v %v", group, name, value, labels)

}

// GaugeSetAfterCounter returns a count of finished GroupedStorageMock.GaugeSet invocations
func (mmGaugeSet *GroupedStorageMock) GaugeSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.afterGaugeSetCounter)
}

// GaugeSetBeforeCounter returns a count of GroupedStorageMock.GaugeSet invocations
func (mmGaugeSet *GroupedStorageMock) GaugeSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.beforeGaugeSetCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.GaugeSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeSet *mGroupedStorageMockGaugeSet) Calls() []*GroupedStorageMockGaugeSetParams {
	mmGaugeSet.mutex.RLock()

	argCopy := make([]*GroupedStorageMockGaugeSetParams, len(mmGaugeSet.callArgs))
	copy(argCopy, mmGaugeSet.callArgs)

	mmGaugeSet.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeSetDone returns true if the count of the GaugeSet invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockGaugeSetDone() bool {
	if m.GaugeSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeSetMock.invocationsDone()
}

// MinimockGaugeSetInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockGaugeSetInspect() {
	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.GaugeSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeSetCounter := mm_atomic.LoadUint64(&m.afterGaugeSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeSetMock.defaultExpectation != nil && afterGaugeSetCounter < 1 {
		if m.GaugeSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.GaugeSet at\n%s", m.GaugeSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.GaugeSet at\n%s with params: %#v", m.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *m.GaugeSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeSet != nil && afterGaugeSetCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.GaugeSet at\n%s", m.funcGaugeSetOrigin)
	}

	if !m.GaugeSetMock.invocationsDone() && afterGaugeSetCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.GaugeSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeSetMock.expectedInvocations), m.GaugeSetMock.expectedInvocationsOrigin, afterGaugeSetCounter)
	}
}

type mGroupedStorageMockGetOrCreateCounterCollector struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockGetOrCreateCounterCollectorExpectation
	expectations       []*GroupedStorageMockGetOrCreateCounterCollectorExpectation

	callArgs []*GroupedStorageMockGetOrCreateCounterCollectorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockGetOrCreateCounterCollectorExpectation specifies expectation struct of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockGetOrCreateCounterCollectorParams
	paramPtrs          *GroupedStorageMockGetOrCreateCounterCollectorParamPtrs
	expectationOrigins GroupedStorageMockGetOrCreateCounterCollectorExpectationOrigins
	results            *GroupedStorageMockGetOrCreateCounterCollectorResults
	returnOrigin       string
	Counter            uint64
}

// GroupedStorageMockGetOrCreateCounterCollectorParams contains parameters of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorParams struct {
	name       string
	labelNames []string
}

// GroupedStorageMockGetOrCreateCounterCollectorParamPtrs contains pointers to parameters of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorParamPtrs struct {
	name       *string
	labelNames *[]string
}

// GroupedStorageMockGetOrCreateCounterCollectorResults contains results of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorResults struct {
	cp1 *ConstCounterCollector
	err error
}

// GroupedStorageMockGetOrCreateCounterCollectorOrigins contains origins of expectations of the GroupedStorage.GetOrCreateCounterCollector
type GroupedStorageMockGetOrCreateCounterCollectorExpectationOrigins struct {
	origin           string
	originName       string
	originLabelNames string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Optional() *mGroupedStorageMockGetOrCreateCounterCollector {
	mmGetOrCreateCounterCollector.optional = true
	return mmGetOrCreateCounterCollector
}

// Expect sets up expected params for GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Expect(name string, labelNames []string) *mGroupedStorageMockGetOrCreateCounterCollector {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation == nil {
		mmGetOrCreateCounterCollector.defaultExpectation = &GroupedStorageMockGetOrCreateCounterCollectorExpectation{}
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by ExpectParams functions")
	}

	mmGetOrCreateCounterCollector.defaultExpectation.params = &GroupedStorageMockGetOrCreateCounterCollectorParams{name, labelNames}
	mmGetOrCreateCounterCollector.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrCreateCounterCollector.expectations {
		if minimock.Equal(e.params, mmGetOrCreateCounterCollector.defaultExpectation.params) {
			mmGetOrCreateCounterCollector.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrCreateCounterCollector.defaultExpectation.params)
		}
	}

	return mmGetOrCreateCounterCollector
}

// ExpectNameParam1 sets up expected param name for GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) ExpectNameParam1(name string) *mGroupedStorageMockGetOrCreateCounterCollector {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation == nil {
		mmGetOrCreateCounterCollector.defaultExpectation = &GroupedStorageMockGetOrCreateCounterCollectorExpectation{}
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.params != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Expect")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs == nil {
		mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs = &GroupedStorageMockGetOrCreateCounterCollectorParamPtrs{}
	}
	mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs.name = &name
	mmGetOrCreateCounterCollector.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGetOrCreateCounterCollector
}

// ExpectLabelNamesParam2 sets up expected param labelNames for GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) ExpectLabelNamesParam2(labelNames []string) *mGroupedStorageMockGetOrCreateCounterCollector {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation == nil {
		mmGetOrCreateCounterCollector.defaultExpectation = &GroupedStorageMockGetOrCreateCounterCollectorExpectation{}
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.params != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Expect")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs == nil {
		mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs = &GroupedStorageMockGetOrCreateCounterCollectorParamPtrs{}
	}
	mmGetOrCreateCounterCollector.defaultExpectation.paramPtrs.labelNames = &labelNames
	mmGetOrCreateCounterCollector.defaultExpectation.expectationOrigins.originLabelNames = minimock.CallerInfo(1)

	return mmGetOrCreateCounterCollector
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Inspect(f func(name string, labelNames []string)) *mGroupedStorageMockGetOrCreateCounterCollector {
	if mmGetOrCreateCounterCollector.mock.inspectFuncGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.GetOrCreateCounterCollector")
	}

	mmGetOrCreateCounterCollector.mock.inspectFuncGetOrCreateCounterCollector = f

	return mmGetOrCreateCounterCollector
}

// Return sets up results that will be returned by GroupedStorage.GetOrCreateCounterCollector
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Return(cp1 *ConstCounterCollector, err error) *GroupedStorageMock {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	if mmGetOrCreateCounterCollector.defaultExpectation == nil {
		mmGetOrCreateCounterCollector.defaultExpectation = &GroupedStorageMockGetOrCreateCounterCollectorExpectation{mock: mmGetOrCreateCounterCollector.mock}
	}
	mmGetOrCreateCounterCollector.defaultExpectation.results = &GroupedStorageMockGetOrCreateCounterCollectorResults{cp1, err}
	mmGetOrCreateCounterCollector.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateCounterCollector.mock
}

// Set uses given function f to mock the GroupedStorage.GetOrCreateCounterCollector method
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Set(f func(name string, labelNames []string) (cp1 *ConstCounterCollector, err error)) *GroupedStorageMock {
	if mmGetOrCreateCounterCollector.defaultExpectation != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.GetOrCreateCounterCollector method")
	}

	if len(mmGetOrCreateCounterCollector.expectations) > 0 {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.GetOrCreateCounterCollector method")
	}

	mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector = f
	mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollectorOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateCounterCollector.mock
}

// When sets expectation for the GroupedStorage.GetOrCreateCounterCollector which will trigger the result defined by the following
// Then helper
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) When(name string, labelNames []string) *GroupedStorageMockGetOrCreateCounterCollectorExpectation {
	if mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateCounterCollector mock is already set by Set")
	}

	expectation := &GroupedStorageMockGetOrCreateCounterCollectorExpectation{
		mock:               mmGetOrCreateCounterCollector.mock,
		params:             &GroupedStorageMockGetOrCreateCounterCollectorParams{name, labelNames},
		expectationOrigins: GroupedStorageMockGetOrCreateCounterCollectorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrCreateCounterCollector.expectations = append(mmGetOrCreateCounterCollector.expectations, expectation)
	return expectation
}

// Then sets up GroupedStorage.GetOrCreateCounterCollector return parameters for the expectation previously defined by the When method
func (e *GroupedStorageMockGetOrCreateCounterCollectorExpectation) Then(cp1 *ConstCounterCollector, err error) *GroupedStorageMock {
	e.results = &GroupedStorageMockGetOrCreateCounterCollectorResults{cp1, err}
	return e.mock
}

// Times sets number of times GroupedStorage.GetOrCreateCounterCollector should be invoked
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Times(n uint64) *mGroupedStorageMockGetOrCreateCounterCollector {
	if n == 0 {
		mmGetOrCreateCounterCollector.mock.t.Fatalf("Times of GroupedStorageMock.GetOrCreateCounterCollector mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrCreateCounterCollector.expectedInvocations, n)
	mmGetOrCreateCounterCollector.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateCounterCollector
}

func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) invocationsDone() bool {
	if len(mmGetOrCreateCounterCollector.expectations) == 0 && mmGetOrCreateCounterCollector.defaultExpectation == nil && mmGetOrCreateCounterCollector.mock.funcGetOrCreateCounterCollector == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrCreateCounterCollector.mock.afterGetOrCreateCounterCollectorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrCreateCounterCollector.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrCreateCounterCollector implements GroupedStorage
func (mmGetOrCreateCounterCollector *GroupedStorageMock) GetOrCreateCounterCollector(name string, labelNames []string) (cp1 *ConstCounterCollector, err error) {
	mm_atomic.AddUint64(&mmGetOrCreateCounterCollector.beforeGetOrCreateCounterCollectorCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrCreateCounterCollector.afterGetOrCreateCounterCollectorCounter, 1)

	mmGetOrCreateCounterCollector.t.Helper()

	if mmGetOrCreateCounterCollector.inspectFuncGetOrCreateCounterCollector != nil {
		mmGetOrCreateCounterCollector.inspectFuncGetOrCreateCounterCollector(name, labelNames)
	}

	mm_params := GroupedStorageMockGetOrCreateCounterCollectorParams{name, labelNames}

	// Record call args
	mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.mutex.Lock()
	mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.callArgs = append(mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.callArgs, &mm_params)
	mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.mutex.Unlock()

	for _, e := range mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockGetOrCreateCounterCollectorParams{name, labelNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetOrCreateCounterCollector.t.Errorf("GroupedStorageMock.GetOrCreateCounterCollector got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.labelNames != nil && !minimock.Equal(*mm_want_ptrs.labelNames, mm_got.labelNames) {
				mmGetOrCreateCounterCollector.t.Errorf("GroupedStorageMock.GetOrCreateCounterCollector got unexpected parameter labelNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.expectationOrigins.originLabelNames, *mm_want_ptrs.labelNames, mm_got.labelNames, minimock.Diff(*mm_want_ptrs.labelNames, mm_got.labelNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrCreateCounterCollector.t.Errorf("GroupedStorageMock.GetOrCreateCounterCollector got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrCreateCounterCollector.GetOrCreateCounterCollectorMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrCreateCounterCollector.t.Fatal("No results are set for the GroupedStorageMock.GetOrCreateCounterCollector")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetOrCreateCounterCollector.funcGetOrCreateCounterCollector != nil {
		return mmGetOrCreateCounterCollector.funcGetOrCreateCounterCollector(name, labelNames)
	}
	mmGetOrCreateCounterCollector.t.Fatalf("Unexpected call to GroupedStorageMock.GetOrCreateCounterCollector. %v %v", name, labelNames)
	return
}

// GetOrCreateCounterCollectorAfterCounter returns a count of finished GroupedStorageMock.GetOrCreateCounterCollector invocations
func (mmGetOrCreateCounterCollector *GroupedStorageMock) GetOrCreateCounterCollectorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreateCounterCollector.afterGetOrCreateCounterCollectorCounter)
}

// GetOrCreateCounterCollectorBeforeCounter returns a count of GroupedStorageMock.GetOrCreateCounterCollector invocations
func (mmGetOrCreateCounterCollector *GroupedStorageMock) GetOrCreateCounterCollectorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreateCounterCollector.beforeGetOrCreateCounterCollectorCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.GetOrCreateCounterCollector.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrCreateCounterCollector *mGroupedStorageMockGetOrCreateCounterCollector) Calls() []*GroupedStorageMockGetOrCreateCounterCollectorParams {
	mmGetOrCreateCounterCollector.mutex.RLock()

	argCopy := make([]*GroupedStorageMockGetOrCreateCounterCollectorParams, len(mmGetOrCreateCounterCollector.callArgs))
	copy(argCopy, mmGetOrCreateCounterCollector.callArgs)

	mmGetOrCreateCounterCollector.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrCreateCounterCollectorDone returns true if the count of the GetOrCreateCounterCollector invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockGetOrCreateCounterCollectorDone() bool {
	if m.GetOrCreateCounterCollectorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrCreateCounterCollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrCreateCounterCollectorMock.invocationsDone()
}

// MinimockGetOrCreateCounterCollectorInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockGetOrCreateCounterCollectorInspect() {
	for _, e := range m.GetOrCreateCounterCollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateCounterCollector at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrCreateCounterCollectorCounter := mm_atomic.LoadUint64(&m.afterGetOrCreateCounterCollectorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrCreateCounterCollectorMock.defaultExpectation != nil && afterGetOrCreateCounterCollectorCounter < 1 {
		if m.GetOrCreateCounterCollectorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateCounterCollector at\n%s", m.GetOrCreateCounterCollectorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateCounterCollector at\n%s with params: %#v", m.GetOrCreateCounterCollectorMock.defaultExpectation.expectationOrigins.origin, *m.GetOrCreateCounterCollectorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrCreateCounterCollector != nil && afterGetOrCreateCounterCollectorCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateCounterCollector at\n%s", m.funcGetOrCreateCounterCollectorOrigin)
	}

	if !m.GetOrCreateCounterCollectorMock.invocationsDone() && afterGetOrCreateCounterCollectorCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.GetOrCreateCounterCollector at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrCreateCounterCollectorMock.expectedInvocations), m.GetOrCreateCounterCollectorMock.expectedInvocationsOrigin, afterGetOrCreateCounterCollectorCounter)
	}
}

type mGroupedStorageMockGetOrCreateGaugeCollector struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockGetOrCreateGaugeCollectorExpectation
	expectations       []*GroupedStorageMockGetOrCreateGaugeCollectorExpectation

	callArgs []*GroupedStorageMockGetOrCreateGaugeCollectorParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockGetOrCreateGaugeCollectorExpectation specifies expectation struct of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorExpectation struct {
	mock               *GroupedStorageMock
	params             *GroupedStorageMockGetOrCreateGaugeCollectorParams
	paramPtrs          *GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs
	expectationOrigins GroupedStorageMockGetOrCreateGaugeCollectorExpectationOrigins
	results            *GroupedStorageMockGetOrCreateGaugeCollectorResults
	returnOrigin       string
	Counter            uint64
}

// GroupedStorageMockGetOrCreateGaugeCollectorParams contains parameters of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorParams struct {
	name       string
	labelNames []string
}

// GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs contains pointers to parameters of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs struct {
	name       *string
	labelNames *[]string
}

// GroupedStorageMockGetOrCreateGaugeCollectorResults contains results of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorResults struct {
	cp1 *ConstGaugeCollector
	err error
}

// GroupedStorageMockGetOrCreateGaugeCollectorOrigins contains origins of expectations of the GroupedStorage.GetOrCreateGaugeCollector
type GroupedStorageMockGetOrCreateGaugeCollectorExpectationOrigins struct {
	origin           string
	originName       string
	originLabelNames string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Optional() *mGroupedStorageMockGetOrCreateGaugeCollector {
	mmGetOrCreateGaugeCollector.optional = true
	return mmGetOrCreateGaugeCollector
}

// Expect sets up expected params for GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Expect(name string, labelNames []string) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation = &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{}
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by ExpectParams functions")
	}

	mmGetOrCreateGaugeCollector.defaultExpectation.params = &GroupedStorageMockGetOrCreateGaugeCollectorParams{name, labelNames}
	mmGetOrCreateGaugeCollector.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetOrCreateGaugeCollector.expectations {
		if minimock.Equal(e.params, mmGetOrCreateGaugeCollector.defaultExpectation.params) {
			mmGetOrCreateGaugeCollector.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrCreateGaugeCollector.defaultExpectation.params)
		}
	}

	return mmGetOrCreateGaugeCollector
}

// ExpectNameParam1 sets up expected param name for GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) ExpectNameParam1(name string) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation = &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{}
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.params != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Expect")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs = &GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs{}
	}
	mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs.name = &name
	mmGetOrCreateGaugeCollector.defaultExpectation.expectationOrigins.originName = minimock.CallerInfo(1)

	return mmGetOrCreateGaugeCollector
}

// ExpectLabelNamesParam2 sets up expected param labelNames for GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) ExpectLabelNamesParam2(labelNames []string) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation = &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{}
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.params != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Expect")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs = &GroupedStorageMockGetOrCreateGaugeCollectorParamPtrs{}
	}
	mmGetOrCreateGaugeCollector.defaultExpectation.paramPtrs.labelNames = &labelNames
	mmGetOrCreateGaugeCollector.defaultExpectation.expectationOrigins.originLabelNames = minimock.CallerInfo(1)

	return mmGetOrCreateGaugeCollector
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Inspect(f func(name string, labelNames []string)) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if mmGetOrCreateGaugeCollector.mock.inspectFuncGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.GetOrCreateGaugeCollector")
	}

	mmGetOrCreateGaugeCollector.mock.inspectFuncGetOrCreateGaugeCollector = f

	return mmGetOrCreateGaugeCollector
}

// Return sets up results that will be returned by GroupedStorage.GetOrCreateGaugeCollector
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Return(cp1 *ConstGaugeCollector, err error) *GroupedStorageMock {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	if mmGetOrCreateGaugeCollector.defaultExpectation == nil {
		mmGetOrCreateGaugeCollector.defaultExpectation = &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{mock: mmGetOrCreateGaugeCollector.mock}
	}
	mmGetOrCreateGaugeCollector.defaultExpectation.results = &GroupedStorageMockGetOrCreateGaugeCollectorResults{cp1, err}
	mmGetOrCreateGaugeCollector.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateGaugeCollector.mock
}

// Set uses given function f to mock the GroupedStorage.GetOrCreateGaugeCollector method
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Set(f func(name string, labelNames []string) (cp1 *ConstGaugeCollector, err error)) *GroupedStorageMock {
	if mmGetOrCreateGaugeCollector.defaultExpectation != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.GetOrCreateGaugeCollector method")
	}

	if len(mmGetOrCreateGaugeCollector.expectations) > 0 {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.GetOrCreateGaugeCollector method")
	}

	mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector = f
	mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollectorOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateGaugeCollector.mock
}

// When sets expectation for the GroupedStorage.GetOrCreateGaugeCollector which will trigger the result defined by the following
// Then helper
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) When(name string, labelNames []string) *GroupedStorageMockGetOrCreateGaugeCollectorExpectation {
	if mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("GroupedStorageMock.GetOrCreateGaugeCollector mock is already set by Set")
	}

	expectation := &GroupedStorageMockGetOrCreateGaugeCollectorExpectation{
		mock:               mmGetOrCreateGaugeCollector.mock,
		params:             &GroupedStorageMockGetOrCreateGaugeCollectorParams{name, labelNames},
		expectationOrigins: GroupedStorageMockGetOrCreateGaugeCollectorExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetOrCreateGaugeCollector.expectations = append(mmGetOrCreateGaugeCollector.expectations, expectation)
	return expectation
}

// Then sets up GroupedStorage.GetOrCreateGaugeCollector return parameters for the expectation previously defined by the When method
func (e *GroupedStorageMockGetOrCreateGaugeCollectorExpectation) Then(cp1 *ConstGaugeCollector, err error) *GroupedStorageMock {
	e.results = &GroupedStorageMockGetOrCreateGaugeCollectorResults{cp1, err}
	return e.mock
}

// Times sets number of times GroupedStorage.GetOrCreateGaugeCollector should be invoked
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Times(n uint64) *mGroupedStorageMockGetOrCreateGaugeCollector {
	if n == 0 {
		mmGetOrCreateGaugeCollector.mock.t.Fatalf("Times of GroupedStorageMock.GetOrCreateGaugeCollector mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetOrCreateGaugeCollector.expectedInvocations, n)
	mmGetOrCreateGaugeCollector.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetOrCreateGaugeCollector
}

func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) invocationsDone() bool {
	if len(mmGetOrCreateGaugeCollector.expectations) == 0 && mmGetOrCreateGaugeCollector.defaultExpectation == nil && mmGetOrCreateGaugeCollector.mock.funcGetOrCreateGaugeCollector == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetOrCreateGaugeCollector.mock.afterGetOrCreateGaugeCollectorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetOrCreateGaugeCollector.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetOrCreateGaugeCollector implements GroupedStorage
func (mmGetOrCreateGaugeCollector *GroupedStorageMock) GetOrCreateGaugeCollector(name string, labelNames []string) (cp1 *ConstGaugeCollector, err error) {
	mm_atomic.AddUint64(&mmGetOrCreateGaugeCollector.beforeGetOrCreateGaugeCollectorCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrCreateGaugeCollector.afterGetOrCreateGaugeCollectorCounter, 1)

	mmGetOrCreateGaugeCollector.t.Helper()

	if mmGetOrCreateGaugeCollector.inspectFuncGetOrCreateGaugeCollector != nil {
		mmGetOrCreateGaugeCollector.inspectFuncGetOrCreateGaugeCollector(name, labelNames)
	}

	mm_params := GroupedStorageMockGetOrCreateGaugeCollectorParams{name, labelNames}

	// Record call args
	mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.mutex.Lock()
	mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.callArgs = append(mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.callArgs, &mm_params)
	mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.mutex.Unlock()

	for _, e := range mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.params
		mm_want_ptrs := mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.paramPtrs

		mm_got := GroupedStorageMockGetOrCreateGaugeCollectorParams{name, labelNames}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.name != nil && !minimock.Equal(*mm_want_ptrs.name, mm_got.name) {
				mmGetOrCreateGaugeCollector.t.Errorf("GroupedStorageMock.GetOrCreateGaugeCollector got unexpected parameter name, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.expectationOrigins.originName, *mm_want_ptrs.name, mm_got.name, minimock.Diff(*mm_want_ptrs.name, mm_got.name))
			}

			if mm_want_ptrs.labelNames != nil && !minimock.Equal(*mm_want_ptrs.labelNames, mm_got.labelNames) {
				mmGetOrCreateGaugeCollector.t.Errorf("GroupedStorageMock.GetOrCreateGaugeCollector got unexpected parameter labelNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.expectationOrigins.originLabelNames, *mm_want_ptrs.labelNames, mm_got.labelNames, minimock.Diff(*mm_want_ptrs.labelNames, mm_got.labelNames))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrCreateGaugeCollector.t.Errorf("GroupedStorageMock.GetOrCreateGaugeCollector got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrCreateGaugeCollector.GetOrCreateGaugeCollectorMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrCreateGaugeCollector.t.Fatal("No results are set for the GroupedStorageMock.GetOrCreateGaugeCollector")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmGetOrCreateGaugeCollector.funcGetOrCreateGaugeCollector != nil {
		return mmGetOrCreateGaugeCollector.funcGetOrCreateGaugeCollector(name, labelNames)
	}
	mmGetOrCreateGaugeCollector.t.Fatalf("Unexpected call to GroupedStorageMock.GetOrCreateGaugeCollector. %v %v", name, labelNames)
	return
}

// GetOrCreateGaugeCollectorAfterCounter returns a count of finished GroupedStorageMock.GetOrCreateGaugeCollector invocations
func (mmGetOrCreateGaugeCollector *GroupedStorageMock) GetOrCreateGaugeCollectorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreateGaugeCollector.afterGetOrCreateGaugeCollectorCounter)
}

// GetOrCreateGaugeCollectorBeforeCounter returns a count of GroupedStorageMock.GetOrCreateGaugeCollector invocations
func (mmGetOrCreateGaugeCollector *GroupedStorageMock) GetOrCreateGaugeCollectorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrCreateGaugeCollector.beforeGetOrCreateGaugeCollectorCounter)
}

// Calls returns a list of arguments used in each call to GroupedStorageMock.GetOrCreateGaugeCollector.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrCreateGaugeCollector *mGroupedStorageMockGetOrCreateGaugeCollector) Calls() []*GroupedStorageMockGetOrCreateGaugeCollectorParams {
	mmGetOrCreateGaugeCollector.mutex.RLock()

	argCopy := make([]*GroupedStorageMockGetOrCreateGaugeCollectorParams, len(mmGetOrCreateGaugeCollector.callArgs))
	copy(argCopy, mmGetOrCreateGaugeCollector.callArgs)

	mmGetOrCreateGaugeCollector.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrCreateGaugeCollectorDone returns true if the count of the GetOrCreateGaugeCollector invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockGetOrCreateGaugeCollectorDone() bool {
	if m.GetOrCreateGaugeCollectorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetOrCreateGaugeCollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetOrCreateGaugeCollectorMock.invocationsDone()
}

// MinimockGetOrCreateGaugeCollectorInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockGetOrCreateGaugeCollectorInspect() {
	for _, e := range m.GetOrCreateGaugeCollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetOrCreateGaugeCollectorCounter := mm_atomic.LoadUint64(&m.afterGetOrCreateGaugeCollectorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrCreateGaugeCollectorMock.defaultExpectation != nil && afterGetOrCreateGaugeCollectorCounter < 1 {
		if m.GetOrCreateGaugeCollectorMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s", m.GetOrCreateGaugeCollectorMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s with params: %#v", m.GetOrCreateGaugeCollectorMock.defaultExpectation.expectationOrigins.origin, *m.GetOrCreateGaugeCollectorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrCreateGaugeCollector != nil && afterGetOrCreateGaugeCollectorCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s", m.funcGetOrCreateGaugeCollectorOrigin)
	}

	if !m.GetOrCreateGaugeCollectorMock.invocationsDone() && afterGetOrCreateGaugeCollectorCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.GetOrCreateGaugeCollector at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetOrCreateGaugeCollectorMock.expectedInvocations), m.GetOrCreateGaugeCollectorMock.expectedInvocationsOrigin, afterGetOrCreateGaugeCollectorCounter)
	}
}

type mGroupedStorageMockRegisterer struct {
	optional           bool
	mock               *GroupedStorageMock
	defaultExpectation *GroupedStorageMockRegistererExpectation
	expectations       []*GroupedStorageMockRegistererExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// GroupedStorageMockRegistererExpectation specifies expectation struct of the GroupedStorage.Registerer
type GroupedStorageMockRegistererExpectation struct {
	mock *GroupedStorageMock

	results      *GroupedStorageMockRegistererResults
	returnOrigin string
	Counter      uint64
}

// GroupedStorageMockRegistererResults contains results of the GroupedStorage.Registerer
type GroupedStorageMockRegistererResults struct {
	r1 prometheus.Registerer
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterer *mGroupedStorageMockRegisterer) Optional() *mGroupedStorageMockRegisterer {
	mmRegisterer.optional = true
	return mmRegisterer
}

// Expect sets up expected params for GroupedStorage.Registerer
func (mmRegisterer *mGroupedStorageMockRegisterer) Expect() *mGroupedStorageMockRegisterer {
	if mmRegisterer.mock.funcRegisterer != nil {
		mmRegisterer.mock.t.Fatalf("GroupedStorageMock.Registerer mock is already set by Set")
	}

	if mmRegisterer.defaultExpectation == nil {
		mmRegisterer.defaultExpectation = &GroupedStorageMockRegistererExpectation{}
	}

	return mmRegisterer
}

// Inspect accepts an inspector function that has same arguments as the GroupedStorage.Registerer
func (mmRegisterer *mGroupedStorageMockRegisterer) Inspect(f func()) *mGroupedStorageMockRegisterer {
	if mmRegisterer.mock.inspectFuncRegisterer != nil {
		mmRegisterer.mock.t.Fatalf("Inspect function is already set for GroupedStorageMock.Registerer")
	}

	mmRegisterer.mock.inspectFuncRegisterer = f

	return mmRegisterer
}

// Return sets up results that will be returned by GroupedStorage.Registerer
func (mmRegisterer *mGroupedStorageMockRegisterer) Return(r1 prometheus.Registerer) *GroupedStorageMock {
	if mmRegisterer.mock.funcRegisterer != nil {
		mmRegisterer.mock.t.Fatalf("GroupedStorageMock.Registerer mock is already set by Set")
	}

	if mmRegisterer.defaultExpectation == nil {
		mmRegisterer.defaultExpectation = &GroupedStorageMockRegistererExpectation{mock: mmRegisterer.mock}
	}
	mmRegisterer.defaultExpectation.results = &GroupedStorageMockRegistererResults{r1}
	mmRegisterer.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterer.mock
}

// Set uses given function f to mock the GroupedStorage.Registerer method
func (mmRegisterer *mGroupedStorageMockRegisterer) Set(f func() (r1 prometheus.Registerer)) *GroupedStorageMock {
	if mmRegisterer.defaultExpectation != nil {
		mmRegisterer.mock.t.Fatalf("Default expectation is already set for the GroupedStorage.Registerer method")
	}

	if len(mmRegisterer.expectations) > 0 {
		mmRegisterer.mock.t.Fatalf("Some expectations are already set for the GroupedStorage.Registerer method")
	}

	mmRegisterer.mock.funcRegisterer = f
	mmRegisterer.mock.funcRegistererOrigin = minimock.CallerInfo(1)
	return mmRegisterer.mock
}

// Times sets number of times GroupedStorage.Registerer should be invoked
func (mmRegisterer *mGroupedStorageMockRegisterer) Times(n uint64) *mGroupedStorageMockRegisterer {
	if n == 0 {
		mmRegisterer.mock.t.Fatalf("Times of GroupedStorageMock.Registerer mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterer.expectedInvocations, n)
	mmRegisterer.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterer
}

func (mmRegisterer *mGroupedStorageMockRegisterer) invocationsDone() bool {
	if len(mmRegisterer.expectations) == 0 && mmRegisterer.defaultExpectation == nil && mmRegisterer.mock.funcRegisterer == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterer.mock.afterRegistererCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterer.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Registerer implements GroupedStorage
func (mmRegisterer *GroupedStorageMock) Registerer() (r1 prometheus.Registerer) {
	mm_atomic.AddUint64(&mmRegisterer.beforeRegistererCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterer.afterRegistererCounter, 1)

	mmRegisterer.t.Helper()

	if mmRegisterer.inspectFuncRegisterer != nil {
		mmRegisterer.inspectFuncRegisterer()
	}

	if mmRegisterer.RegistererMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterer.RegistererMock.defaultExpectation.Counter, 1)

		mm_results := mmRegisterer.RegistererMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterer.t.Fatal("No results are set for the GroupedStorageMock.Registerer")
		}
		return (*mm_results).r1
	}
	if mmRegisterer.funcRegisterer != nil {
		return mmRegisterer.funcRegisterer()
	}
	mmRegisterer.t.Fatalf("Unexpected call to GroupedStorageMock.Registerer.")
	return
}

// RegistererAfterCounter returns a count of finished GroupedStorageMock.Registerer invocations
func (mmRegisterer *GroupedStorageMock) RegistererAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterer.afterRegistererCounter)
}

// RegistererBeforeCounter returns a count of GroupedStorageMock.Registerer invocations
func (mmRegisterer *GroupedStorageMock) RegistererBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterer.beforeRegistererCounter)
}

// MinimockRegistererDone returns true if the count of the Registerer invocations corresponds
// the number of defined expectations
func (m *GroupedStorageMock) MinimockRegistererDone() bool {
	if m.RegistererMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegistererMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegistererMock.invocationsDone()
}

// MinimockRegistererInspect logs each unmet expectation
func (m *GroupedStorageMock) MinimockRegistererInspect() {
	for _, e := range m.RegistererMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to GroupedStorageMock.Registerer")
		}
	}

	afterRegistererCounter := mm_atomic.LoadUint64(&m.afterRegistererCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegistererMock.defaultExpectation != nil && afterRegistererCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.Registerer at\n%s", m.RegistererMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterer != nil && afterRegistererCounter < 1 {
		m.t.Errorf("Expected call to GroupedStorageMock.Registerer at\n%s", m.funcRegistererOrigin)
	}

	if !m.RegistererMock.invocationsDone() && afterRegistererCounter > 0 {
		m.t.Errorf("Expected %d calls to GroupedStorageMock.Registerer at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegistererMock.expectedInvocations), m.RegistererMock.expectedInvocationsOrigin, afterRegistererCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *GroupedStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCounterAddInspect()

			m.MinimockExpireGroupMetricsInspect()

			m.MinimockGaugeSetInspect()

			m.MinimockGetOrCreateCounterCollectorInspect()

			m.MinimockGetOrCreateGaugeCollectorInspect()

			m.MinimockRegistererInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *GroupedStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *GroupedStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCounterAddDone() &&
		m.MinimockExpireGroupMetricsDone() &&
		m.MinimockGaugeSetDone() &&
		m.MinimockGetOrCreateCounterCollectorDone() &&
		m.MinimockGetOrCreateGaugeCollectorDone() &&
		m.MinimockRegistererDone()
}
