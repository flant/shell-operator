// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package metric

//go:generate minimock -i github.com/flant/shell-operator/pkg/metric.Storage -o storage_mock.go -n StorageMock -p metric

import (
	"net/http"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/flant/shell-operator/pkg/metric_storage/operation"
	"github.com/gojuno/minimock/v3"
	"github.com/prometheus/client_golang/prometheus"
)

// StorageMock implements Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcApplyOperation          func(op operation.MetricOperation, commonLabels map[string]string)
	funcApplyOperationOrigin    string
	inspectFuncApplyOperation   func(op operation.MetricOperation, commonLabels map[string]string)
	afterApplyOperationCounter  uint64
	beforeApplyOperationCounter uint64
	ApplyOperationMock          mStorageMockApplyOperation

	funcCounter          func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)
	funcCounterOrigin    string
	inspectFuncCounter   func(metric string, labels map[string]string)
	afterCounterCounter  uint64
	beforeCounterCounter uint64
	CounterMock          mStorageMockCounter

	funcCounterAdd          func(metric string, value float64, labels map[string]string)
	funcCounterAddOrigin    string
	inspectFuncCounterAdd   func(metric string, value float64, labels map[string]string)
	afterCounterAddCounter  uint64
	beforeCounterAddCounter uint64
	CounterAddMock          mStorageMockCounterAdd

	funcGauge          func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)
	funcGaugeOrigin    string
	inspectFuncGauge   func(metric string, labels map[string]string)
	afterGaugeCounter  uint64
	beforeGaugeCounter uint64
	GaugeMock          mStorageMockGauge

	funcGaugeAdd          func(metric string, value float64, labels map[string]string)
	funcGaugeAddOrigin    string
	inspectFuncGaugeAdd   func(metric string, value float64, labels map[string]string)
	afterGaugeAddCounter  uint64
	beforeGaugeAddCounter uint64
	GaugeAddMock          mStorageMockGaugeAdd

	funcGaugeSet          func(metric string, value float64, labels map[string]string)
	funcGaugeSetOrigin    string
	inspectFuncGaugeSet   func(metric string, value float64, labels map[string]string)
	afterGaugeSetCounter  uint64
	beforeGaugeSetCounter uint64
	GaugeSetMock          mStorageMockGaugeSet

	funcGrouped          func() (g1 GroupedStorage)
	funcGroupedOrigin    string
	inspectFuncGrouped   func()
	afterGroupedCounter  uint64
	beforeGroupedCounter uint64
	GroupedMock          mStorageMockGrouped

	funcHandler          func() (h1 http.Handler)
	funcHandlerOrigin    string
	inspectFuncHandler   func()
	afterHandlerCounter  uint64
	beforeHandlerCounter uint64
	HandlerMock          mStorageMockHandler

	funcHistogram          func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)
	funcHistogramOrigin    string
	inspectFuncHistogram   func(metric string, labels map[string]string, buckets []float64)
	afterHistogramCounter  uint64
	beforeHistogramCounter uint64
	HistogramMock          mStorageMockHistogram

	funcHistogramObserve          func(metric string, value float64, labels map[string]string, buckets []float64)
	funcHistogramObserveOrigin    string
	inspectFuncHistogramObserve   func(metric string, value float64, labels map[string]string, buckets []float64)
	afterHistogramObserveCounter  uint64
	beforeHistogramObserveCounter uint64
	HistogramObserveMock          mStorageMockHistogramObserve

	funcRegisterCounter          func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)
	funcRegisterCounterOrigin    string
	inspectFuncRegisterCounter   func(metric string, labels map[string]string)
	afterRegisterCounterCounter  uint64
	beforeRegisterCounterCounter uint64
	RegisterCounterMock          mStorageMockRegisterCounter

	funcRegisterGauge          func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)
	funcRegisterGaugeOrigin    string
	inspectFuncRegisterGauge   func(metric string, labels map[string]string)
	afterRegisterGaugeCounter  uint64
	beforeRegisterGaugeCounter uint64
	RegisterGaugeMock          mStorageMockRegisterGauge

	funcRegisterHistogram          func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)
	funcRegisterHistogramOrigin    string
	inspectFuncRegisterHistogram   func(metric string, labels map[string]string, buckets []float64)
	afterRegisterHistogramCounter  uint64
	beforeRegisterHistogramCounter uint64
	RegisterHistogramMock          mStorageMockRegisterHistogram

	funcSendBatch          func(ops []operation.MetricOperation, labels map[string]string) (err error)
	funcSendBatchOrigin    string
	inspectFuncSendBatch   func(ops []operation.MetricOperation, labels map[string]string)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mStorageMockSendBatch
}

// NewStorageMock returns a mock for Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ApplyOperationMock = mStorageMockApplyOperation{mock: m}
	m.ApplyOperationMock.callArgs = []*StorageMockApplyOperationParams{}

	m.CounterMock = mStorageMockCounter{mock: m}
	m.CounterMock.callArgs = []*StorageMockCounterParams{}

	m.CounterAddMock = mStorageMockCounterAdd{mock: m}
	m.CounterAddMock.callArgs = []*StorageMockCounterAddParams{}

	m.GaugeMock = mStorageMockGauge{mock: m}
	m.GaugeMock.callArgs = []*StorageMockGaugeParams{}

	m.GaugeAddMock = mStorageMockGaugeAdd{mock: m}
	m.GaugeAddMock.callArgs = []*StorageMockGaugeAddParams{}

	m.GaugeSetMock = mStorageMockGaugeSet{mock: m}
	m.GaugeSetMock.callArgs = []*StorageMockGaugeSetParams{}

	m.GroupedMock = mStorageMockGrouped{mock: m}

	m.HandlerMock = mStorageMockHandler{mock: m}

	m.HistogramMock = mStorageMockHistogram{mock: m}
	m.HistogramMock.callArgs = []*StorageMockHistogramParams{}

	m.HistogramObserveMock = mStorageMockHistogramObserve{mock: m}
	m.HistogramObserveMock.callArgs = []*StorageMockHistogramObserveParams{}

	m.RegisterCounterMock = mStorageMockRegisterCounter{mock: m}
	m.RegisterCounterMock.callArgs = []*StorageMockRegisterCounterParams{}

	m.RegisterGaugeMock = mStorageMockRegisterGauge{mock: m}
	m.RegisterGaugeMock.callArgs = []*StorageMockRegisterGaugeParams{}

	m.RegisterHistogramMock = mStorageMockRegisterHistogram{mock: m}
	m.RegisterHistogramMock.callArgs = []*StorageMockRegisterHistogramParams{}

	m.SendBatchMock = mStorageMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*StorageMockSendBatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockApplyOperation struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockApplyOperationExpectation
	expectations       []*StorageMockApplyOperationExpectation

	callArgs []*StorageMockApplyOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockApplyOperationExpectation specifies expectation struct of the Storage.ApplyOperation
type StorageMockApplyOperationExpectation struct {
	mock               *StorageMock
	params             *StorageMockApplyOperationParams
	paramPtrs          *StorageMockApplyOperationParamPtrs
	expectationOrigins StorageMockApplyOperationExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockApplyOperationParams contains parameters of the Storage.ApplyOperation
type StorageMockApplyOperationParams struct {
	op           operation.MetricOperation
	commonLabels map[string]string
}

// StorageMockApplyOperationParamPtrs contains pointers to parameters of the Storage.ApplyOperation
type StorageMockApplyOperationParamPtrs struct {
	op           *operation.MetricOperation
	commonLabels *map[string]string
}

// StorageMockApplyOperationOrigins contains origins of expectations of the Storage.ApplyOperation
type StorageMockApplyOperationExpectationOrigins struct {
	origin             string
	originOp           string
	originCommonLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmApplyOperation *mStorageMockApplyOperation) Optional() *mStorageMockApplyOperation {
	mmApplyOperation.optional = true
	return mmApplyOperation
}

// Expect sets up expected params for Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) Expect(op operation.MetricOperation, commonLabels map[string]string) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.paramPtrs != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by ExpectParams functions")
	}

	mmApplyOperation.defaultExpectation.params = &StorageMockApplyOperationParams{op, commonLabels}
	mmApplyOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmApplyOperation.expectations {
		if minimock.Equal(e.params, mmApplyOperation.defaultExpectation.params) {
			mmApplyOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyOperation.defaultExpectation.params)
		}
	}

	return mmApplyOperation
}

// ExpectOpParam1 sets up expected param op for Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) ExpectOpParam1(op operation.MetricOperation) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.params != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Expect")
	}

	if mmApplyOperation.defaultExpectation.paramPtrs == nil {
		mmApplyOperation.defaultExpectation.paramPtrs = &StorageMockApplyOperationParamPtrs{}
	}
	mmApplyOperation.defaultExpectation.paramPtrs.op = &op
	mmApplyOperation.defaultExpectation.expectationOrigins.originOp = minimock.CallerInfo(1)

	return mmApplyOperation
}

// ExpectCommonLabelsParam2 sets up expected param commonLabels for Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) ExpectCommonLabelsParam2(commonLabels map[string]string) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.params != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Expect")
	}

	if mmApplyOperation.defaultExpectation.paramPtrs == nil {
		mmApplyOperation.defaultExpectation.paramPtrs = &StorageMockApplyOperationParamPtrs{}
	}
	mmApplyOperation.defaultExpectation.paramPtrs.commonLabels = &commonLabels
	mmApplyOperation.defaultExpectation.expectationOrigins.originCommonLabels = minimock.CallerInfo(1)

	return mmApplyOperation
}

// Inspect accepts an inspector function that has same arguments as the Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) Inspect(f func(op operation.MetricOperation, commonLabels map[string]string)) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.inspectFuncApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("Inspect function is already set for StorageMock.ApplyOperation")
	}

	mmApplyOperation.mock.inspectFuncApplyOperation = f

	return mmApplyOperation
}

// Return sets up results that will be returned by Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) Return() *StorageMock {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{mock: mmApplyOperation.mock}
	}

	mmApplyOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmApplyOperation.mock
}

// Set uses given function f to mock the Storage.ApplyOperation method
func (mmApplyOperation *mStorageMockApplyOperation) Set(f func(op operation.MetricOperation, commonLabels map[string]string)) *StorageMock {
	if mmApplyOperation.defaultExpectation != nil {
		mmApplyOperation.mock.t.Fatalf("Default expectation is already set for the Storage.ApplyOperation method")
	}

	if len(mmApplyOperation.expectations) > 0 {
		mmApplyOperation.mock.t.Fatalf("Some expectations are already set for the Storage.ApplyOperation method")
	}

	mmApplyOperation.mock.funcApplyOperation = f
	mmApplyOperation.mock.funcApplyOperationOrigin = minimock.CallerInfo(1)
	return mmApplyOperation.mock
}

// When sets expectation for the Storage.ApplyOperation which will trigger the result defined by the following
// Then helper
func (mmApplyOperation *mStorageMockApplyOperation) When(op operation.MetricOperation, commonLabels map[string]string) *StorageMockApplyOperationExpectation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	expectation := &StorageMockApplyOperationExpectation{
		mock:               mmApplyOperation.mock,
		params:             &StorageMockApplyOperationParams{op, commonLabels},
		expectationOrigins: StorageMockApplyOperationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmApplyOperation.expectations = append(mmApplyOperation.expectations, expectation)
	return expectation
}

// Then sets up Storage.ApplyOperation return parameters for the expectation previously defined by the When method

func (e *StorageMockApplyOperationExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.ApplyOperation should be invoked
func (mmApplyOperation *mStorageMockApplyOperation) Times(n uint64) *mStorageMockApplyOperation {
	if n == 0 {
		mmApplyOperation.mock.t.Fatalf("Times of StorageMock.ApplyOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmApplyOperation.expectedInvocations, n)
	mmApplyOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmApplyOperation
}

func (mmApplyOperation *mStorageMockApplyOperation) invocationsDone() bool {
	if len(mmApplyOperation.expectations) == 0 && mmApplyOperation.defaultExpectation == nil && mmApplyOperation.mock.funcApplyOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmApplyOperation.mock.afterApplyOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmApplyOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ApplyOperation implements Storage
func (mmApplyOperation *StorageMock) ApplyOperation(op operation.MetricOperation, commonLabels map[string]string) {
	mm_atomic.AddUint64(&mmApplyOperation.beforeApplyOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyOperation.afterApplyOperationCounter, 1)

	mmApplyOperation.t.Helper()

	if mmApplyOperation.inspectFuncApplyOperation != nil {
		mmApplyOperation.inspectFuncApplyOperation(op, commonLabels)
	}

	mm_params := StorageMockApplyOperationParams{op, commonLabels}

	// Record call args
	mmApplyOperation.ApplyOperationMock.mutex.Lock()
	mmApplyOperation.ApplyOperationMock.callArgs = append(mmApplyOperation.ApplyOperationMock.callArgs, &mm_params)
	mmApplyOperation.ApplyOperationMock.mutex.Unlock()

	for _, e := range mmApplyOperation.ApplyOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmApplyOperation.ApplyOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyOperation.ApplyOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyOperation.ApplyOperationMock.defaultExpectation.params
		mm_want_ptrs := mmApplyOperation.ApplyOperationMock.defaultExpectation.paramPtrs

		mm_got := StorageMockApplyOperationParams{op, commonLabels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.op != nil && !minimock.Equal(*mm_want_ptrs.op, mm_got.op) {
				mmApplyOperation.t.Errorf("StorageMock.ApplyOperation got unexpected parameter op, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.originOp, *mm_want_ptrs.op, mm_got.op, minimock.Diff(*mm_want_ptrs.op, mm_got.op))
			}

			if mm_want_ptrs.commonLabels != nil && !minimock.Equal(*mm_want_ptrs.commonLabels, mm_got.commonLabels) {
				mmApplyOperation.t.Errorf("StorageMock.ApplyOperation got unexpected parameter commonLabels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.originCommonLabels, *mm_want_ptrs.commonLabels, mm_got.commonLabels, minimock.Diff(*mm_want_ptrs.commonLabels, mm_got.commonLabels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyOperation.t.Errorf("StorageMock.ApplyOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmApplyOperation.funcApplyOperation != nil {
		mmApplyOperation.funcApplyOperation(op, commonLabels)
		return
	}
	mmApplyOperation.t.Fatalf("Unexpected call to StorageMock.ApplyOperation. %v %v", op, commonLabels)

}

// ApplyOperationAfterCounter returns a count of finished StorageMock.ApplyOperation invocations
func (mmApplyOperation *StorageMock) ApplyOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOperation.afterApplyOperationCounter)
}

// ApplyOperationBeforeCounter returns a count of StorageMock.ApplyOperation invocations
func (mmApplyOperation *StorageMock) ApplyOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOperation.beforeApplyOperationCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ApplyOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyOperation *mStorageMockApplyOperation) Calls() []*StorageMockApplyOperationParams {
	mmApplyOperation.mutex.RLock()

	argCopy := make([]*StorageMockApplyOperationParams, len(mmApplyOperation.callArgs))
	copy(argCopy, mmApplyOperation.callArgs)

	mmApplyOperation.mutex.RUnlock()

	return argCopy
}

// MinimockApplyOperationDone returns true if the count of the ApplyOperation invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockApplyOperationDone() bool {
	if m.ApplyOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ApplyOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ApplyOperationMock.invocationsDone()
}

// MinimockApplyOperationInspect logs each unmet expectation
func (m *StorageMock) MinimockApplyOperationInspect() {
	for _, e := range m.ApplyOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterApplyOperationCounter := mm_atomic.LoadUint64(&m.afterApplyOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyOperationMock.defaultExpectation != nil && afterApplyOperationCounter < 1 {
		if m.ApplyOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s", m.ApplyOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s with params: %#v", m.ApplyOperationMock.defaultExpectation.expectationOrigins.origin, *m.ApplyOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyOperation != nil && afterApplyOperationCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s", m.funcApplyOperationOrigin)
	}

	if !m.ApplyOperationMock.invocationsDone() && afterApplyOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ApplyOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ApplyOperationMock.expectedInvocations), m.ApplyOperationMock.expectedInvocationsOrigin, afterApplyOperationCounter)
	}
}

type mStorageMockCounter struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCounterExpectation
	expectations       []*StorageMockCounterExpectation

	callArgs []*StorageMockCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCounterExpectation specifies expectation struct of the Storage.Counter
type StorageMockCounterExpectation struct {
	mock               *StorageMock
	params             *StorageMockCounterParams
	paramPtrs          *StorageMockCounterParamPtrs
	expectationOrigins StorageMockCounterExpectationOrigins
	results            *StorageMockCounterResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCounterParams contains parameters of the Storage.Counter
type StorageMockCounterParams struct {
	metric string
	labels map[string]string
}

// StorageMockCounterParamPtrs contains pointers to parameters of the Storage.Counter
type StorageMockCounterParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockCounterResults contains results of the Storage.Counter
type StorageMockCounterResults struct {
	cp1 *prometheus.CounterVec
}

// StorageMockCounterOrigins contains origins of expectations of the Storage.Counter
type StorageMockCounterExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounter *mStorageMockCounter) Optional() *mStorageMockCounter {
	mmCounter.optional = true
	return mmCounter
}

// Expect sets up expected params for Storage.Counter
func (mmCounter *mStorageMockCounter) Expect(metric string, labels map[string]string) *mStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.paramPtrs != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by ExpectParams functions")
	}

	mmCounter.defaultExpectation.params = &StorageMockCounterParams{metric, labels}
	mmCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounter.expectations {
		if minimock.Equal(e.params, mmCounter.defaultExpectation.params) {
			mmCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounter.defaultExpectation.params)
		}
	}

	return mmCounter
}

// ExpectMetricParam1 sets up expected param metric for Storage.Counter
func (mmCounter *mStorageMockCounter) ExpectMetricParam1(metric string) *mStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.params != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Expect")
	}

	if mmCounter.defaultExpectation.paramPtrs == nil {
		mmCounter.defaultExpectation.paramPtrs = &StorageMockCounterParamPtrs{}
	}
	mmCounter.defaultExpectation.paramPtrs.metric = &metric
	mmCounter.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmCounter
}

// ExpectLabelsParam2 sets up expected param labels for Storage.Counter
func (mmCounter *mStorageMockCounter) ExpectLabelsParam2(labels map[string]string) *mStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.params != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Expect")
	}

	if mmCounter.defaultExpectation.paramPtrs == nil {
		mmCounter.defaultExpectation.paramPtrs = &StorageMockCounterParamPtrs{}
	}
	mmCounter.defaultExpectation.paramPtrs.labels = &labels
	mmCounter.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounter
}

// Inspect accepts an inspector function that has same arguments as the Storage.Counter
func (mmCounter *mStorageMockCounter) Inspect(f func(metric string, labels map[string]string)) *mStorageMockCounter {
	if mmCounter.mock.inspectFuncCounter != nil {
		mmCounter.mock.t.Fatalf("Inspect function is already set for StorageMock.Counter")
	}

	mmCounter.mock.inspectFuncCounter = f

	return mmCounter
}

// Return sets up results that will be returned by Storage.Counter
func (mmCounter *mStorageMockCounter) Return(cp1 *prometheus.CounterVec) *StorageMock {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{mock: mmCounter.mock}
	}
	mmCounter.defaultExpectation.results = &StorageMockCounterResults{cp1}
	mmCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounter.mock
}

// Set uses given function f to mock the Storage.Counter method
func (mmCounter *mStorageMockCounter) Set(f func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)) *StorageMock {
	if mmCounter.defaultExpectation != nil {
		mmCounter.mock.t.Fatalf("Default expectation is already set for the Storage.Counter method")
	}

	if len(mmCounter.expectations) > 0 {
		mmCounter.mock.t.Fatalf("Some expectations are already set for the Storage.Counter method")
	}

	mmCounter.mock.funcCounter = f
	mmCounter.mock.funcCounterOrigin = minimock.CallerInfo(1)
	return mmCounter.mock
}

// When sets expectation for the Storage.Counter which will trigger the result defined by the following
// Then helper
func (mmCounter *mStorageMockCounter) When(metric string, labels map[string]string) *StorageMockCounterExpectation {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	expectation := &StorageMockCounterExpectation{
		mock:               mmCounter.mock,
		params:             &StorageMockCounterParams{metric, labels},
		expectationOrigins: StorageMockCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCounter.expectations = append(mmCounter.expectations, expectation)
	return expectation
}

// Then sets up Storage.Counter return parameters for the expectation previously defined by the When method
func (e *StorageMockCounterExpectation) Then(cp1 *prometheus.CounterVec) *StorageMock {
	e.results = &StorageMockCounterResults{cp1}
	return e.mock
}

// Times sets number of times Storage.Counter should be invoked
func (mmCounter *mStorageMockCounter) Times(n uint64) *mStorageMockCounter {
	if n == 0 {
		mmCounter.mock.t.Fatalf("Times of StorageMock.Counter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounter.expectedInvocations, n)
	mmCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounter
}

func (mmCounter *mStorageMockCounter) invocationsDone() bool {
	if len(mmCounter.expectations) == 0 && mmCounter.defaultExpectation == nil && mmCounter.mock.funcCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounter.mock.afterCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Counter implements Storage
func (mmCounter *StorageMock) Counter(metric string, labels map[string]string) (cp1 *prometheus.CounterVec) {
	mm_atomic.AddUint64(&mmCounter.beforeCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmCounter.afterCounterCounter, 1)

	mmCounter.t.Helper()

	if mmCounter.inspectFuncCounter != nil {
		mmCounter.inspectFuncCounter(metric, labels)
	}

	mm_params := StorageMockCounterParams{metric, labels}

	// Record call args
	mmCounter.CounterMock.mutex.Lock()
	mmCounter.CounterMock.callArgs = append(mmCounter.CounterMock.callArgs, &mm_params)
	mmCounter.CounterMock.mutex.Unlock()

	for _, e := range mmCounter.CounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1
		}
	}

	if mmCounter.CounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounter.CounterMock.defaultExpectation.Counter, 1)
		mm_want := mmCounter.CounterMock.defaultExpectation.params
		mm_want_ptrs := mmCounter.CounterMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCounterParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmCounter.t.Errorf("StorageMock.Counter got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounter.CounterMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounter.t.Errorf("StorageMock.Counter got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounter.CounterMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounter.t.Errorf("StorageMock.Counter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounter.CounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCounter.CounterMock.defaultExpectation.results
		if mm_results == nil {
			mmCounter.t.Fatal("No results are set for the StorageMock.Counter")
		}
		return (*mm_results).cp1
	}
	if mmCounter.funcCounter != nil {
		return mmCounter.funcCounter(metric, labels)
	}
	mmCounter.t.Fatalf("Unexpected call to StorageMock.Counter. %v %v", metric, labels)
	return
}

// CounterAfterCounter returns a count of finished StorageMock.Counter invocations
func (mmCounter *StorageMock) CounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounter.afterCounterCounter)
}

// CounterBeforeCounter returns a count of StorageMock.Counter invocations
func (mmCounter *StorageMock) CounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounter.beforeCounterCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Counter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounter *mStorageMockCounter) Calls() []*StorageMockCounterParams {
	mmCounter.mutex.RLock()

	argCopy := make([]*StorageMockCounterParams, len(mmCounter.callArgs))
	copy(argCopy, mmCounter.callArgs)

	mmCounter.mutex.RUnlock()

	return argCopy
}

// MinimockCounterDone returns true if the count of the Counter invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCounterDone() bool {
	if m.CounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterMock.invocationsDone()
}

// MinimockCounterInspect logs each unmet expectation
func (m *StorageMock) MinimockCounterInspect() {
	for _, e := range m.CounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Counter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterCounter := mm_atomic.LoadUint64(&m.afterCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterMock.defaultExpectation != nil && afterCounterCounter < 1 {
		if m.CounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.Counter at\n%s", m.CounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.Counter at\n%s with params: %#v", m.CounterMock.defaultExpectation.expectationOrigins.origin, *m.CounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounter != nil && afterCounterCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Counter at\n%s", m.funcCounterOrigin)
	}

	if !m.CounterMock.invocationsDone() && afterCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Counter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterMock.expectedInvocations), m.CounterMock.expectedInvocationsOrigin, afterCounterCounter)
	}
}

type mStorageMockCounterAdd struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCounterAddExpectation
	expectations       []*StorageMockCounterAddExpectation

	callArgs []*StorageMockCounterAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCounterAddExpectation specifies expectation struct of the Storage.CounterAdd
type StorageMockCounterAddExpectation struct {
	mock               *StorageMock
	params             *StorageMockCounterAddParams
	paramPtrs          *StorageMockCounterAddParamPtrs
	expectationOrigins StorageMockCounterAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockCounterAddParams contains parameters of the Storage.CounterAdd
type StorageMockCounterAddParams struct {
	metric string
	value  float64
	labels map[string]string
}

// StorageMockCounterAddParamPtrs contains pointers to parameters of the Storage.CounterAdd
type StorageMockCounterAddParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// StorageMockCounterAddOrigins contains origins of expectations of the Storage.CounterAdd
type StorageMockCounterAddExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounterAdd *mStorageMockCounterAdd) Optional() *mStorageMockCounterAdd {
	mmCounterAdd.optional = true
	return mmCounterAdd
}

// Expect sets up expected params for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) Expect(metric string, value float64, labels map[string]string) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.paramPtrs != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by ExpectParams functions")
	}

	mmCounterAdd.defaultExpectation.params = &StorageMockCounterAddParams{metric, value, labels}
	mmCounterAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounterAdd.expectations {
		if minimock.Equal(e.params, mmCounterAdd.defaultExpectation.params) {
			mmCounterAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounterAdd.defaultExpectation.params)
		}
	}

	return mmCounterAdd
}

// ExpectMetricParam1 sets up expected param metric for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) ExpectMetricParam1(metric string) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &StorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.metric = &metric
	mmCounterAdd.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectValueParam2 sets up expected param value for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) ExpectValueParam2(value float64) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &StorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.value = &value
	mmCounterAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectLabelsParam3 sets up expected param labels for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) ExpectLabelsParam3(labels map[string]string) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &StorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.labels = &labels
	mmCounterAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounterAdd
}

// Inspect accepts an inspector function that has same arguments as the Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) Inspect(f func(metric string, value float64, labels map[string]string)) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.inspectFuncCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("Inspect function is already set for StorageMock.CounterAdd")
	}

	mmCounterAdd.mock.inspectFuncCounterAdd = f

	return mmCounterAdd
}

// Return sets up results that will be returned by Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) Return() *StorageMock {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{mock: mmCounterAdd.mock}
	}

	mmCounterAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// Set uses given function f to mock the Storage.CounterAdd method
func (mmCounterAdd *mStorageMockCounterAdd) Set(f func(metric string, value float64, labels map[string]string)) *StorageMock {
	if mmCounterAdd.defaultExpectation != nil {
		mmCounterAdd.mock.t.Fatalf("Default expectation is already set for the Storage.CounterAdd method")
	}

	if len(mmCounterAdd.expectations) > 0 {
		mmCounterAdd.mock.t.Fatalf("Some expectations are already set for the Storage.CounterAdd method")
	}

	mmCounterAdd.mock.funcCounterAdd = f
	mmCounterAdd.mock.funcCounterAddOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// When sets expectation for the Storage.CounterAdd which will trigger the result defined by the following
// Then helper
func (mmCounterAdd *mStorageMockCounterAdd) When(metric string, value float64, labels map[string]string) *StorageMockCounterAddExpectation {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	expectation := &StorageMockCounterAddExpectation{
		mock:               mmCounterAdd.mock,
		params:             &StorageMockCounterAddParams{metric, value, labels},
		expectationOrigins: StorageMockCounterAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCounterAdd.expectations = append(mmCounterAdd.expectations, expectation)
	return expectation
}

// Then sets up Storage.CounterAdd return parameters for the expectation previously defined by the When method

func (e *StorageMockCounterAddExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.CounterAdd should be invoked
func (mmCounterAdd *mStorageMockCounterAdd) Times(n uint64) *mStorageMockCounterAdd {
	if n == 0 {
		mmCounterAdd.mock.t.Fatalf("Times of StorageMock.CounterAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounterAdd.expectedInvocations, n)
	mmCounterAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounterAdd
}

func (mmCounterAdd *mStorageMockCounterAdd) invocationsDone() bool {
	if len(mmCounterAdd.expectations) == 0 && mmCounterAdd.defaultExpectation == nil && mmCounterAdd.mock.funcCounterAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounterAdd.mock.afterCounterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounterAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CounterAdd implements Storage
func (mmCounterAdd *StorageMock) CounterAdd(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmCounterAdd.beforeCounterAddCounter, 1)
	defer mm_atomic.AddUint64(&mmCounterAdd.afterCounterAddCounter, 1)

	mmCounterAdd.t.Helper()

	if mmCounterAdd.inspectFuncCounterAdd != nil {
		mmCounterAdd.inspectFuncCounterAdd(metric, value, labels)
	}

	mm_params := StorageMockCounterAddParams{metric, value, labels}

	// Record call args
	mmCounterAdd.CounterAddMock.mutex.Lock()
	mmCounterAdd.CounterAddMock.callArgs = append(mmCounterAdd.CounterAddMock.callArgs, &mm_params)
	mmCounterAdd.CounterAddMock.mutex.Unlock()

	for _, e := range mmCounterAdd.CounterAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCounterAdd.CounterAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounterAdd.CounterAddMock.defaultExpectation.Counter, 1)
		mm_want := mmCounterAdd.CounterAddMock.defaultExpectation.params
		mm_want_ptrs := mmCounterAdd.CounterAddMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCounterAddParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCounterAdd.funcCounterAdd != nil {
		mmCounterAdd.funcCounterAdd(metric, value, labels)
		return
	}
	mmCounterAdd.t.Fatalf("Unexpected call to StorageMock.CounterAdd. %v %v %v", metric, value, labels)

}

// CounterAddAfterCounter returns a count of finished StorageMock.CounterAdd invocations
func (mmCounterAdd *StorageMock) CounterAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.afterCounterAddCounter)
}

// CounterAddBeforeCounter returns a count of StorageMock.CounterAdd invocations
func (mmCounterAdd *StorageMock) CounterAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.beforeCounterAddCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CounterAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounterAdd *mStorageMockCounterAdd) Calls() []*StorageMockCounterAddParams {
	mmCounterAdd.mutex.RLock()

	argCopy := make([]*StorageMockCounterAddParams, len(mmCounterAdd.callArgs))
	copy(argCopy, mmCounterAdd.callArgs)

	mmCounterAdd.mutex.RUnlock()

	return argCopy
}

// MinimockCounterAddDone returns true if the count of the CounterAdd invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCounterAddDone() bool {
	if m.CounterAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterAddMock.invocationsDone()
}

// MinimockCounterAddInspect logs each unmet expectation
func (m *StorageMock) MinimockCounterAddInspect() {
	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterAddCounter := mm_atomic.LoadUint64(&m.afterCounterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterAddMock.defaultExpectation != nil && afterCounterAddCounter < 1 {
		if m.CounterAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s", m.CounterAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s with params: %#v", m.CounterAddMock.defaultExpectation.expectationOrigins.origin, *m.CounterAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounterAdd != nil && afterCounterAddCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s", m.funcCounterAddOrigin)
	}

	if !m.CounterAddMock.invocationsDone() && afterCounterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CounterAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterAddMock.expectedInvocations), m.CounterAddMock.expectedInvocationsOrigin, afterCounterAddCounter)
	}
}

type mStorageMockGauge struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGaugeExpectation
	expectations       []*StorageMockGaugeExpectation

	callArgs []*StorageMockGaugeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGaugeExpectation specifies expectation struct of the Storage.Gauge
type StorageMockGaugeExpectation struct {
	mock               *StorageMock
	params             *StorageMockGaugeParams
	paramPtrs          *StorageMockGaugeParamPtrs
	expectationOrigins StorageMockGaugeExpectationOrigins
	results            *StorageMockGaugeResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGaugeParams contains parameters of the Storage.Gauge
type StorageMockGaugeParams struct {
	metric string
	labels map[string]string
}

// StorageMockGaugeParamPtrs contains pointers to parameters of the Storage.Gauge
type StorageMockGaugeParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockGaugeResults contains results of the Storage.Gauge
type StorageMockGaugeResults struct {
	gp1 *prometheus.GaugeVec
}

// StorageMockGaugeOrigins contains origins of expectations of the Storage.Gauge
type StorageMockGaugeExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGauge *mStorageMockGauge) Optional() *mStorageMockGauge {
	mmGauge.optional = true
	return mmGauge
}

// Expect sets up expected params for Storage.Gauge
func (mmGauge *mStorageMockGauge) Expect(metric string, labels map[string]string) *mStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.paramPtrs != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by ExpectParams functions")
	}

	mmGauge.defaultExpectation.params = &StorageMockGaugeParams{metric, labels}
	mmGauge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGauge.expectations {
		if minimock.Equal(e.params, mmGauge.defaultExpectation.params) {
			mmGauge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGauge.defaultExpectation.params)
		}
	}

	return mmGauge
}

// ExpectMetricParam1 sets up expected param metric for Storage.Gauge
func (mmGauge *mStorageMockGauge) ExpectMetricParam1(metric string) *mStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.params != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Expect")
	}

	if mmGauge.defaultExpectation.paramPtrs == nil {
		mmGauge.defaultExpectation.paramPtrs = &StorageMockGaugeParamPtrs{}
	}
	mmGauge.defaultExpectation.paramPtrs.metric = &metric
	mmGauge.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGauge
}

// ExpectLabelsParam2 sets up expected param labels for Storage.Gauge
func (mmGauge *mStorageMockGauge) ExpectLabelsParam2(labels map[string]string) *mStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.params != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Expect")
	}

	if mmGauge.defaultExpectation.paramPtrs == nil {
		mmGauge.defaultExpectation.paramPtrs = &StorageMockGaugeParamPtrs{}
	}
	mmGauge.defaultExpectation.paramPtrs.labels = &labels
	mmGauge.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGauge
}

// Inspect accepts an inspector function that has same arguments as the Storage.Gauge
func (mmGauge *mStorageMockGauge) Inspect(f func(metric string, labels map[string]string)) *mStorageMockGauge {
	if mmGauge.mock.inspectFuncGauge != nil {
		mmGauge.mock.t.Fatalf("Inspect function is already set for StorageMock.Gauge")
	}

	mmGauge.mock.inspectFuncGauge = f

	return mmGauge
}

// Return sets up results that will be returned by Storage.Gauge
func (mmGauge *mStorageMockGauge) Return(gp1 *prometheus.GaugeVec) *StorageMock {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{mock: mmGauge.mock}
	}
	mmGauge.defaultExpectation.results = &StorageMockGaugeResults{gp1}
	mmGauge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGauge.mock
}

// Set uses given function f to mock the Storage.Gauge method
func (mmGauge *mStorageMockGauge) Set(f func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)) *StorageMock {
	if mmGauge.defaultExpectation != nil {
		mmGauge.mock.t.Fatalf("Default expectation is already set for the Storage.Gauge method")
	}

	if len(mmGauge.expectations) > 0 {
		mmGauge.mock.t.Fatalf("Some expectations are already set for the Storage.Gauge method")
	}

	mmGauge.mock.funcGauge = f
	mmGauge.mock.funcGaugeOrigin = minimock.CallerInfo(1)
	return mmGauge.mock
}

// When sets expectation for the Storage.Gauge which will trigger the result defined by the following
// Then helper
func (mmGauge *mStorageMockGauge) When(metric string, labels map[string]string) *StorageMockGaugeExpectation {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	expectation := &StorageMockGaugeExpectation{
		mock:               mmGauge.mock,
		params:             &StorageMockGaugeParams{metric, labels},
		expectationOrigins: StorageMockGaugeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGauge.expectations = append(mmGauge.expectations, expectation)
	return expectation
}

// Then sets up Storage.Gauge return parameters for the expectation previously defined by the When method
func (e *StorageMockGaugeExpectation) Then(gp1 *prometheus.GaugeVec) *StorageMock {
	e.results = &StorageMockGaugeResults{gp1}
	return e.mock
}

// Times sets number of times Storage.Gauge should be invoked
func (mmGauge *mStorageMockGauge) Times(n uint64) *mStorageMockGauge {
	if n == 0 {
		mmGauge.mock.t.Fatalf("Times of StorageMock.Gauge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGauge.expectedInvocations, n)
	mmGauge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGauge
}

func (mmGauge *mStorageMockGauge) invocationsDone() bool {
	if len(mmGauge.expectations) == 0 && mmGauge.defaultExpectation == nil && mmGauge.mock.funcGauge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGauge.mock.afterGaugeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGauge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Gauge implements Storage
func (mmGauge *StorageMock) Gauge(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec) {
	mm_atomic.AddUint64(&mmGauge.beforeGaugeCounter, 1)
	defer mm_atomic.AddUint64(&mmGauge.afterGaugeCounter, 1)

	mmGauge.t.Helper()

	if mmGauge.inspectFuncGauge != nil {
		mmGauge.inspectFuncGauge(metric, labels)
	}

	mm_params := StorageMockGaugeParams{metric, labels}

	// Record call args
	mmGauge.GaugeMock.mutex.Lock()
	mmGauge.GaugeMock.callArgs = append(mmGauge.GaugeMock.callArgs, &mm_params)
	mmGauge.GaugeMock.mutex.Unlock()

	for _, e := range mmGauge.GaugeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1
		}
	}

	if mmGauge.GaugeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGauge.GaugeMock.defaultExpectation.Counter, 1)
		mm_want := mmGauge.GaugeMock.defaultExpectation.params
		mm_want_ptrs := mmGauge.GaugeMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGaugeParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGauge.t.Errorf("StorageMock.Gauge got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGauge.GaugeMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGauge.t.Errorf("StorageMock.Gauge got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGauge.GaugeMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGauge.t.Errorf("StorageMock.Gauge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGauge.GaugeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGauge.GaugeMock.defaultExpectation.results
		if mm_results == nil {
			mmGauge.t.Fatal("No results are set for the StorageMock.Gauge")
		}
		return (*mm_results).gp1
	}
	if mmGauge.funcGauge != nil {
		return mmGauge.funcGauge(metric, labels)
	}
	mmGauge.t.Fatalf("Unexpected call to StorageMock.Gauge. %v %v", metric, labels)
	return
}

// GaugeAfterCounter returns a count of finished StorageMock.Gauge invocations
func (mmGauge *StorageMock) GaugeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGauge.afterGaugeCounter)
}

// GaugeBeforeCounter returns a count of StorageMock.Gauge invocations
func (mmGauge *StorageMock) GaugeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGauge.beforeGaugeCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Gauge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGauge *mStorageMockGauge) Calls() []*StorageMockGaugeParams {
	mmGauge.mutex.RLock()

	argCopy := make([]*StorageMockGaugeParams, len(mmGauge.callArgs))
	copy(argCopy, mmGauge.callArgs)

	mmGauge.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeDone returns true if the count of the Gauge invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGaugeDone() bool {
	if m.GaugeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeMock.invocationsDone()
}

// MinimockGaugeInspect logs each unmet expectation
func (m *StorageMock) MinimockGaugeInspect() {
	for _, e := range m.GaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Gauge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeCounter := mm_atomic.LoadUint64(&m.afterGaugeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeMock.defaultExpectation != nil && afterGaugeCounter < 1 {
		if m.GaugeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.Gauge at\n%s", m.GaugeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.Gauge at\n%s with params: %#v", m.GaugeMock.defaultExpectation.expectationOrigins.origin, *m.GaugeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGauge != nil && afterGaugeCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Gauge at\n%s", m.funcGaugeOrigin)
	}

	if !m.GaugeMock.invocationsDone() && afterGaugeCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Gauge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeMock.expectedInvocations), m.GaugeMock.expectedInvocationsOrigin, afterGaugeCounter)
	}
}

type mStorageMockGaugeAdd struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGaugeAddExpectation
	expectations       []*StorageMockGaugeAddExpectation

	callArgs []*StorageMockGaugeAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGaugeAddExpectation specifies expectation struct of the Storage.GaugeAdd
type StorageMockGaugeAddExpectation struct {
	mock               *StorageMock
	params             *StorageMockGaugeAddParams
	paramPtrs          *StorageMockGaugeAddParamPtrs
	expectationOrigins StorageMockGaugeAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockGaugeAddParams contains parameters of the Storage.GaugeAdd
type StorageMockGaugeAddParams struct {
	metric string
	value  float64
	labels map[string]string
}

// StorageMockGaugeAddParamPtrs contains pointers to parameters of the Storage.GaugeAdd
type StorageMockGaugeAddParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// StorageMockGaugeAddOrigins contains origins of expectations of the Storage.GaugeAdd
type StorageMockGaugeAddExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeAdd *mStorageMockGaugeAdd) Optional() *mStorageMockGaugeAdd {
	mmGaugeAdd.optional = true
	return mmGaugeAdd
}

// Expect sets up expected params for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) Expect(metric string, value float64, labels map[string]string) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by ExpectParams functions")
	}

	mmGaugeAdd.defaultExpectation.params = &StorageMockGaugeAddParams{metric, value, labels}
	mmGaugeAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeAdd.expectations {
		if minimock.Equal(e.params, mmGaugeAdd.defaultExpectation.params) {
			mmGaugeAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeAdd.defaultExpectation.params)
		}
	}

	return mmGaugeAdd
}

// ExpectMetricParam1 sets up expected param metric for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) ExpectMetricParam1(metric string) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &StorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.metric = &metric
	mmGaugeAdd.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// ExpectValueParam2 sets up expected param value for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) ExpectValueParam2(value float64) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &StorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.value = &value
	mmGaugeAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// ExpectLabelsParam3 sets up expected param labels for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) ExpectLabelsParam3(labels map[string]string) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &StorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// Inspect accepts an inspector function that has same arguments as the Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) Inspect(f func(metric string, value float64, labels map[string]string)) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.inspectFuncGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("Inspect function is already set for StorageMock.GaugeAdd")
	}

	mmGaugeAdd.mock.inspectFuncGaugeAdd = f

	return mmGaugeAdd
}

// Return sets up results that will be returned by Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) Return() *StorageMock {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{mock: mmGaugeAdd.mock}
	}

	mmGaugeAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd.mock
}

// Set uses given function f to mock the Storage.GaugeAdd method
func (mmGaugeAdd *mStorageMockGaugeAdd) Set(f func(metric string, value float64, labels map[string]string)) *StorageMock {
	if mmGaugeAdd.defaultExpectation != nil {
		mmGaugeAdd.mock.t.Fatalf("Default expectation is already set for the Storage.GaugeAdd method")
	}

	if len(mmGaugeAdd.expectations) > 0 {
		mmGaugeAdd.mock.t.Fatalf("Some expectations are already set for the Storage.GaugeAdd method")
	}

	mmGaugeAdd.mock.funcGaugeAdd = f
	mmGaugeAdd.mock.funcGaugeAddOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd.mock
}

// When sets expectation for the Storage.GaugeAdd which will trigger the result defined by the following
// Then helper
func (mmGaugeAdd *mStorageMockGaugeAdd) When(metric string, value float64, labels map[string]string) *StorageMockGaugeAddExpectation {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	expectation := &StorageMockGaugeAddExpectation{
		mock:               mmGaugeAdd.mock,
		params:             &StorageMockGaugeAddParams{metric, value, labels},
		expectationOrigins: StorageMockGaugeAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGaugeAdd.expectations = append(mmGaugeAdd.expectations, expectation)
	return expectation
}

// Then sets up Storage.GaugeAdd return parameters for the expectation previously defined by the When method

func (e *StorageMockGaugeAddExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.GaugeAdd should be invoked
func (mmGaugeAdd *mStorageMockGaugeAdd) Times(n uint64) *mStorageMockGaugeAdd {
	if n == 0 {
		mmGaugeAdd.mock.t.Fatalf("Times of StorageMock.GaugeAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeAdd.expectedInvocations, n)
	mmGaugeAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd
}

func (mmGaugeAdd *mStorageMockGaugeAdd) invocationsDone() bool {
	if len(mmGaugeAdd.expectations) == 0 && mmGaugeAdd.defaultExpectation == nil && mmGaugeAdd.mock.funcGaugeAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeAdd.mock.afterGaugeAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeAdd implements Storage
func (mmGaugeAdd *StorageMock) GaugeAdd(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeAdd.beforeGaugeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeAdd.afterGaugeAddCounter, 1)

	mmGaugeAdd.t.Helper()

	if mmGaugeAdd.inspectFuncGaugeAdd != nil {
		mmGaugeAdd.inspectFuncGaugeAdd(metric, value, labels)
	}

	mm_params := StorageMockGaugeAddParams{metric, value, labels}

	// Record call args
	mmGaugeAdd.GaugeAddMock.mutex.Lock()
	mmGaugeAdd.GaugeAddMock.callArgs = append(mmGaugeAdd.GaugeAddMock.callArgs, &mm_params)
	mmGaugeAdd.GaugeAddMock.mutex.Unlock()

	for _, e := range mmGaugeAdd.GaugeAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeAdd.GaugeAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeAdd.GaugeAddMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeAdd.GaugeAddMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeAdd.GaugeAddMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGaugeAddParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeAdd.funcGaugeAdd != nil {
		mmGaugeAdd.funcGaugeAdd(metric, value, labels)
		return
	}
	mmGaugeAdd.t.Fatalf("Unexpected call to StorageMock.GaugeAdd. %v %v %v", metric, value, labels)

}

// GaugeAddAfterCounter returns a count of finished StorageMock.GaugeAdd invocations
func (mmGaugeAdd *StorageMock) GaugeAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeAdd.afterGaugeAddCounter)
}

// GaugeAddBeforeCounter returns a count of StorageMock.GaugeAdd invocations
func (mmGaugeAdd *StorageMock) GaugeAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeAdd.beforeGaugeAddCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GaugeAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeAdd *mStorageMockGaugeAdd) Calls() []*StorageMockGaugeAddParams {
	mmGaugeAdd.mutex.RLock()

	argCopy := make([]*StorageMockGaugeAddParams, len(mmGaugeAdd.callArgs))
	copy(argCopy, mmGaugeAdd.callArgs)

	mmGaugeAdd.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeAddDone returns true if the count of the GaugeAdd invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGaugeAddDone() bool {
	if m.GaugeAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeAddMock.invocationsDone()
}

// MinimockGaugeAddInspect logs each unmet expectation
func (m *StorageMock) MinimockGaugeAddInspect() {
	for _, e := range m.GaugeAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeAddCounter := mm_atomic.LoadUint64(&m.afterGaugeAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeAddMock.defaultExpectation != nil && afterGaugeAddCounter < 1 {
		if m.GaugeAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s", m.GaugeAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s with params: %#v", m.GaugeAddMock.defaultExpectation.expectationOrigins.origin, *m.GaugeAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeAdd != nil && afterGaugeAddCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s", m.funcGaugeAddOrigin)
	}

	if !m.GaugeAddMock.invocationsDone() && afterGaugeAddCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GaugeAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeAddMock.expectedInvocations), m.GaugeAddMock.expectedInvocationsOrigin, afterGaugeAddCounter)
	}
}

type mStorageMockGaugeSet struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGaugeSetExpectation
	expectations       []*StorageMockGaugeSetExpectation

	callArgs []*StorageMockGaugeSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGaugeSetExpectation specifies expectation struct of the Storage.GaugeSet
type StorageMockGaugeSetExpectation struct {
	mock               *StorageMock
	params             *StorageMockGaugeSetParams
	paramPtrs          *StorageMockGaugeSetParamPtrs
	expectationOrigins StorageMockGaugeSetExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockGaugeSetParams contains parameters of the Storage.GaugeSet
type StorageMockGaugeSetParams struct {
	metric string
	value  float64
	labels map[string]string
}

// StorageMockGaugeSetParamPtrs contains pointers to parameters of the Storage.GaugeSet
type StorageMockGaugeSetParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// StorageMockGaugeSetOrigins contains origins of expectations of the Storage.GaugeSet
type StorageMockGaugeSetExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeSet *mStorageMockGaugeSet) Optional() *mStorageMockGaugeSet {
	mmGaugeSet.optional = true
	return mmGaugeSet
}

// Expect sets up expected params for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) Expect(metric string, value float64, labels map[string]string) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.paramPtrs != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by ExpectParams functions")
	}

	mmGaugeSet.defaultExpectation.params = &StorageMockGaugeSetParams{metric, value, labels}
	mmGaugeSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeSet.expectations {
		if minimock.Equal(e.params, mmGaugeSet.defaultExpectation.params) {
			mmGaugeSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeSet.defaultExpectation.params)
		}
	}

	return mmGaugeSet
}

// ExpectMetricParam1 sets up expected param metric for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) ExpectMetricParam1(metric string) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &StorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.metric = &metric
	mmGaugeSet.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectValueParam2 sets up expected param value for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) ExpectValueParam2(value float64) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &StorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.value = &value
	mmGaugeSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectLabelsParam3 sets up expected param labels for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) ExpectLabelsParam3(labels map[string]string) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &StorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeSet.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeSet
}

// Inspect accepts an inspector function that has same arguments as the Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) Inspect(f func(metric string, value float64, labels map[string]string)) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.inspectFuncGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("Inspect function is already set for StorageMock.GaugeSet")
	}

	mmGaugeSet.mock.inspectFuncGaugeSet = f

	return mmGaugeSet
}

// Return sets up results that will be returned by Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) Return() *StorageMock {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{mock: mmGaugeSet.mock}
	}

	mmGaugeSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// Set uses given function f to mock the Storage.GaugeSet method
func (mmGaugeSet *mStorageMockGaugeSet) Set(f func(metric string, value float64, labels map[string]string)) *StorageMock {
	if mmGaugeSet.defaultExpectation != nil {
		mmGaugeSet.mock.t.Fatalf("Default expectation is already set for the Storage.GaugeSet method")
	}

	if len(mmGaugeSet.expectations) > 0 {
		mmGaugeSet.mock.t.Fatalf("Some expectations are already set for the Storage.GaugeSet method")
	}

	mmGaugeSet.mock.funcGaugeSet = f
	mmGaugeSet.mock.funcGaugeSetOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// When sets expectation for the Storage.GaugeSet which will trigger the result defined by the following
// Then helper
func (mmGaugeSet *mStorageMockGaugeSet) When(metric string, value float64, labels map[string]string) *StorageMockGaugeSetExpectation {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	expectation := &StorageMockGaugeSetExpectation{
		mock:               mmGaugeSet.mock,
		params:             &StorageMockGaugeSetParams{metric, value, labels},
		expectationOrigins: StorageMockGaugeSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGaugeSet.expectations = append(mmGaugeSet.expectations, expectation)
	return expectation
}

// Then sets up Storage.GaugeSet return parameters for the expectation previously defined by the When method

func (e *StorageMockGaugeSetExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.GaugeSet should be invoked
func (mmGaugeSet *mStorageMockGaugeSet) Times(n uint64) *mStorageMockGaugeSet {
	if n == 0 {
		mmGaugeSet.mock.t.Fatalf("Times of StorageMock.GaugeSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeSet.expectedInvocations, n)
	mmGaugeSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeSet
}

func (mmGaugeSet *mStorageMockGaugeSet) invocationsDone() bool {
	if len(mmGaugeSet.expectations) == 0 && mmGaugeSet.defaultExpectation == nil && mmGaugeSet.mock.funcGaugeSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeSet.mock.afterGaugeSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeSet implements Storage
func (mmGaugeSet *StorageMock) GaugeSet(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeSet.beforeGaugeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeSet.afterGaugeSetCounter, 1)

	mmGaugeSet.t.Helper()

	if mmGaugeSet.inspectFuncGaugeSet != nil {
		mmGaugeSet.inspectFuncGaugeSet(metric, value, labels)
	}

	mm_params := StorageMockGaugeSetParams{metric, value, labels}

	// Record call args
	mmGaugeSet.GaugeSetMock.mutex.Lock()
	mmGaugeSet.GaugeSetMock.callArgs = append(mmGaugeSet.GaugeSetMock.callArgs, &mm_params)
	mmGaugeSet.GaugeSetMock.mutex.Unlock()

	for _, e := range mmGaugeSet.GaugeSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeSet.GaugeSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeSet.GaugeSetMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeSet.GaugeSetMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeSet.GaugeSetMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGaugeSetParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeSet.funcGaugeSet != nil {
		mmGaugeSet.funcGaugeSet(metric, value, labels)
		return
	}
	mmGaugeSet.t.Fatalf("Unexpected call to StorageMock.GaugeSet. %v %v %v", metric, value, labels)

}

// GaugeSetAfterCounter returns a count of finished StorageMock.GaugeSet invocations
func (mmGaugeSet *StorageMock) GaugeSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.afterGaugeSetCounter)
}

// GaugeSetBeforeCounter returns a count of StorageMock.GaugeSet invocations
func (mmGaugeSet *StorageMock) GaugeSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.beforeGaugeSetCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GaugeSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeSet *mStorageMockGaugeSet) Calls() []*StorageMockGaugeSetParams {
	mmGaugeSet.mutex.RLock()

	argCopy := make([]*StorageMockGaugeSetParams, len(mmGaugeSet.callArgs))
	copy(argCopy, mmGaugeSet.callArgs)

	mmGaugeSet.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeSetDone returns true if the count of the GaugeSet invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGaugeSetDone() bool {
	if m.GaugeSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeSetMock.invocationsDone()
}

// MinimockGaugeSetInspect logs each unmet expectation
func (m *StorageMock) MinimockGaugeSetInspect() {
	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeSetCounter := mm_atomic.LoadUint64(&m.afterGaugeSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeSetMock.defaultExpectation != nil && afterGaugeSetCounter < 1 {
		if m.GaugeSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s", m.GaugeSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s with params: %#v", m.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *m.GaugeSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeSet != nil && afterGaugeSetCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s", m.funcGaugeSetOrigin)
	}

	if !m.GaugeSetMock.invocationsDone() && afterGaugeSetCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GaugeSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeSetMock.expectedInvocations), m.GaugeSetMock.expectedInvocationsOrigin, afterGaugeSetCounter)
	}
}

type mStorageMockGrouped struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGroupedExpectation
	expectations       []*StorageMockGroupedExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGroupedExpectation specifies expectation struct of the Storage.Grouped
type StorageMockGroupedExpectation struct {
	mock *StorageMock

	results      *StorageMockGroupedResults
	returnOrigin string
	Counter      uint64
}

// StorageMockGroupedResults contains results of the Storage.Grouped
type StorageMockGroupedResults struct {
	g1 GroupedStorage
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGrouped *mStorageMockGrouped) Optional() *mStorageMockGrouped {
	mmGrouped.optional = true
	return mmGrouped
}

// Expect sets up expected params for Storage.Grouped
func (mmGrouped *mStorageMockGrouped) Expect() *mStorageMockGrouped {
	if mmGrouped.mock.funcGrouped != nil {
		mmGrouped.mock.t.Fatalf("StorageMock.Grouped mock is already set by Set")
	}

	if mmGrouped.defaultExpectation == nil {
		mmGrouped.defaultExpectation = &StorageMockGroupedExpectation{}
	}

	return mmGrouped
}

// Inspect accepts an inspector function that has same arguments as the Storage.Grouped
func (mmGrouped *mStorageMockGrouped) Inspect(f func()) *mStorageMockGrouped {
	if mmGrouped.mock.inspectFuncGrouped != nil {
		mmGrouped.mock.t.Fatalf("Inspect function is already set for StorageMock.Grouped")
	}

	mmGrouped.mock.inspectFuncGrouped = f

	return mmGrouped
}

// Return sets up results that will be returned by Storage.Grouped
func (mmGrouped *mStorageMockGrouped) Return(g1 GroupedStorage) *StorageMock {
	if mmGrouped.mock.funcGrouped != nil {
		mmGrouped.mock.t.Fatalf("StorageMock.Grouped mock is already set by Set")
	}

	if mmGrouped.defaultExpectation == nil {
		mmGrouped.defaultExpectation = &StorageMockGroupedExpectation{mock: mmGrouped.mock}
	}
	mmGrouped.defaultExpectation.results = &StorageMockGroupedResults{g1}
	mmGrouped.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGrouped.mock
}

// Set uses given function f to mock the Storage.Grouped method
func (mmGrouped *mStorageMockGrouped) Set(f func() (g1 GroupedStorage)) *StorageMock {
	if mmGrouped.defaultExpectation != nil {
		mmGrouped.mock.t.Fatalf("Default expectation is already set for the Storage.Grouped method")
	}

	if len(mmGrouped.expectations) > 0 {
		mmGrouped.mock.t.Fatalf("Some expectations are already set for the Storage.Grouped method")
	}

	mmGrouped.mock.funcGrouped = f
	mmGrouped.mock.funcGroupedOrigin = minimock.CallerInfo(1)
	return mmGrouped.mock
}

// Times sets number of times Storage.Grouped should be invoked
func (mmGrouped *mStorageMockGrouped) Times(n uint64) *mStorageMockGrouped {
	if n == 0 {
		mmGrouped.mock.t.Fatalf("Times of StorageMock.Grouped mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGrouped.expectedInvocations, n)
	mmGrouped.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGrouped
}

func (mmGrouped *mStorageMockGrouped) invocationsDone() bool {
	if len(mmGrouped.expectations) == 0 && mmGrouped.defaultExpectation == nil && mmGrouped.mock.funcGrouped == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGrouped.mock.afterGroupedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGrouped.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Grouped implements Storage
func (mmGrouped *StorageMock) Grouped() (g1 GroupedStorage) {
	mm_atomic.AddUint64(&mmGrouped.beforeGroupedCounter, 1)
	defer mm_atomic.AddUint64(&mmGrouped.afterGroupedCounter, 1)

	mmGrouped.t.Helper()

	if mmGrouped.inspectFuncGrouped != nil {
		mmGrouped.inspectFuncGrouped()
	}

	if mmGrouped.GroupedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGrouped.GroupedMock.defaultExpectation.Counter, 1)

		mm_results := mmGrouped.GroupedMock.defaultExpectation.results
		if mm_results == nil {
			mmGrouped.t.Fatal("No results are set for the StorageMock.Grouped")
		}
		return (*mm_results).g1
	}
	if mmGrouped.funcGrouped != nil {
		return mmGrouped.funcGrouped()
	}
	mmGrouped.t.Fatalf("Unexpected call to StorageMock.Grouped.")
	return
}

// GroupedAfterCounter returns a count of finished StorageMock.Grouped invocations
func (mmGrouped *StorageMock) GroupedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrouped.afterGroupedCounter)
}

// GroupedBeforeCounter returns a count of StorageMock.Grouped invocations
func (mmGrouped *StorageMock) GroupedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrouped.beforeGroupedCounter)
}

// MinimockGroupedDone returns true if the count of the Grouped invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGroupedDone() bool {
	if m.GroupedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GroupedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GroupedMock.invocationsDone()
}

// MinimockGroupedInspect logs each unmet expectation
func (m *StorageMock) MinimockGroupedInspect() {
	for _, e := range m.GroupedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.Grouped")
		}
	}

	afterGroupedCounter := mm_atomic.LoadUint64(&m.afterGroupedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GroupedMock.defaultExpectation != nil && afterGroupedCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Grouped at\n%s", m.GroupedMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGrouped != nil && afterGroupedCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Grouped at\n%s", m.funcGroupedOrigin)
	}

	if !m.GroupedMock.invocationsDone() && afterGroupedCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Grouped at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GroupedMock.expectedInvocations), m.GroupedMock.expectedInvocationsOrigin, afterGroupedCounter)
	}
}

type mStorageMockHandler struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockHandlerExpectation
	expectations       []*StorageMockHandlerExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockHandlerExpectation specifies expectation struct of the Storage.Handler
type StorageMockHandlerExpectation struct {
	mock *StorageMock

	results      *StorageMockHandlerResults
	returnOrigin string
	Counter      uint64
}

// StorageMockHandlerResults contains results of the Storage.Handler
type StorageMockHandlerResults struct {
	h1 http.Handler
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHandler *mStorageMockHandler) Optional() *mStorageMockHandler {
	mmHandler.optional = true
	return mmHandler
}

// Expect sets up expected params for Storage.Handler
func (mmHandler *mStorageMockHandler) Expect() *mStorageMockHandler {
	if mmHandler.mock.funcHandler != nil {
		mmHandler.mock.t.Fatalf("StorageMock.Handler mock is already set by Set")
	}

	if mmHandler.defaultExpectation == nil {
		mmHandler.defaultExpectation = &StorageMockHandlerExpectation{}
	}

	return mmHandler
}

// Inspect accepts an inspector function that has same arguments as the Storage.Handler
func (mmHandler *mStorageMockHandler) Inspect(f func()) *mStorageMockHandler {
	if mmHandler.mock.inspectFuncHandler != nil {
		mmHandler.mock.t.Fatalf("Inspect function is already set for StorageMock.Handler")
	}

	mmHandler.mock.inspectFuncHandler = f

	return mmHandler
}

// Return sets up results that will be returned by Storage.Handler
func (mmHandler *mStorageMockHandler) Return(h1 http.Handler) *StorageMock {
	if mmHandler.mock.funcHandler != nil {
		mmHandler.mock.t.Fatalf("StorageMock.Handler mock is already set by Set")
	}

	if mmHandler.defaultExpectation == nil {
		mmHandler.defaultExpectation = &StorageMockHandlerExpectation{mock: mmHandler.mock}
	}
	mmHandler.defaultExpectation.results = &StorageMockHandlerResults{h1}
	mmHandler.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHandler.mock
}

// Set uses given function f to mock the Storage.Handler method
func (mmHandler *mStorageMockHandler) Set(f func() (h1 http.Handler)) *StorageMock {
	if mmHandler.defaultExpectation != nil {
		mmHandler.mock.t.Fatalf("Default expectation is already set for the Storage.Handler method")
	}

	if len(mmHandler.expectations) > 0 {
		mmHandler.mock.t.Fatalf("Some expectations are already set for the Storage.Handler method")
	}

	mmHandler.mock.funcHandler = f
	mmHandler.mock.funcHandlerOrigin = minimock.CallerInfo(1)
	return mmHandler.mock
}

// Times sets number of times Storage.Handler should be invoked
func (mmHandler *mStorageMockHandler) Times(n uint64) *mStorageMockHandler {
	if n == 0 {
		mmHandler.mock.t.Fatalf("Times of StorageMock.Handler mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHandler.expectedInvocations, n)
	mmHandler.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHandler
}

func (mmHandler *mStorageMockHandler) invocationsDone() bool {
	if len(mmHandler.expectations) == 0 && mmHandler.defaultExpectation == nil && mmHandler.mock.funcHandler == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHandler.mock.afterHandlerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHandler.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Handler implements Storage
func (mmHandler *StorageMock) Handler() (h1 http.Handler) {
	mm_atomic.AddUint64(&mmHandler.beforeHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmHandler.afterHandlerCounter, 1)

	mmHandler.t.Helper()

	if mmHandler.inspectFuncHandler != nil {
		mmHandler.inspectFuncHandler()
	}

	if mmHandler.HandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHandler.HandlerMock.defaultExpectation.Counter, 1)

		mm_results := mmHandler.HandlerMock.defaultExpectation.results
		if mm_results == nil {
			mmHandler.t.Fatal("No results are set for the StorageMock.Handler")
		}
		return (*mm_results).h1
	}
	if mmHandler.funcHandler != nil {
		return mmHandler.funcHandler()
	}
	mmHandler.t.Fatalf("Unexpected call to StorageMock.Handler.")
	return
}

// HandlerAfterCounter returns a count of finished StorageMock.Handler invocations
func (mmHandler *StorageMock) HandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandler.afterHandlerCounter)
}

// HandlerBeforeCounter returns a count of StorageMock.Handler invocations
func (mmHandler *StorageMock) HandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandler.beforeHandlerCounter)
}

// MinimockHandlerDone returns true if the count of the Handler invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockHandlerDone() bool {
	if m.HandlerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HandlerMock.invocationsDone()
}

// MinimockHandlerInspect logs each unmet expectation
func (m *StorageMock) MinimockHandlerInspect() {
	for _, e := range m.HandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.Handler")
		}
	}

	afterHandlerCounter := mm_atomic.LoadUint64(&m.afterHandlerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HandlerMock.defaultExpectation != nil && afterHandlerCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Handler at\n%s", m.HandlerMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHandler != nil && afterHandlerCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Handler at\n%s", m.funcHandlerOrigin)
	}

	if !m.HandlerMock.invocationsDone() && afterHandlerCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Handler at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HandlerMock.expectedInvocations), m.HandlerMock.expectedInvocationsOrigin, afterHandlerCounter)
	}
}

type mStorageMockHistogram struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockHistogramExpectation
	expectations       []*StorageMockHistogramExpectation

	callArgs []*StorageMockHistogramParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockHistogramExpectation specifies expectation struct of the Storage.Histogram
type StorageMockHistogramExpectation struct {
	mock               *StorageMock
	params             *StorageMockHistogramParams
	paramPtrs          *StorageMockHistogramParamPtrs
	expectationOrigins StorageMockHistogramExpectationOrigins
	results            *StorageMockHistogramResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockHistogramParams contains parameters of the Storage.Histogram
type StorageMockHistogramParams struct {
	metric  string
	labels  map[string]string
	buckets []float64
}

// StorageMockHistogramParamPtrs contains pointers to parameters of the Storage.Histogram
type StorageMockHistogramParamPtrs struct {
	metric  *string
	labels  *map[string]string
	buckets *[]float64
}

// StorageMockHistogramResults contains results of the Storage.Histogram
type StorageMockHistogramResults struct {
	hp1 *prometheus.HistogramVec
}

// StorageMockHistogramOrigins contains origins of expectations of the Storage.Histogram
type StorageMockHistogramExpectationOrigins struct {
	origin        string
	originMetric  string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistogram *mStorageMockHistogram) Optional() *mStorageMockHistogram {
	mmHistogram.optional = true
	return mmHistogram
}

// Expect sets up expected params for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) Expect(metric string, labels map[string]string, buckets []float64) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.paramPtrs != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by ExpectParams functions")
	}

	mmHistogram.defaultExpectation.params = &StorageMockHistogramParams{metric, labels, buckets}
	mmHistogram.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistogram.expectations {
		if minimock.Equal(e.params, mmHistogram.defaultExpectation.params) {
			mmHistogram.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistogram.defaultExpectation.params)
		}
	}

	return mmHistogram
}

// ExpectMetricParam1 sets up expected param metric for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) ExpectMetricParam1(metric string) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &StorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.metric = &metric
	mmHistogram.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmHistogram
}

// ExpectLabelsParam2 sets up expected param labels for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) ExpectLabelsParam2(labels map[string]string) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &StorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.labels = &labels
	mmHistogram.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmHistogram
}

// ExpectBucketsParam3 sets up expected param buckets for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) ExpectBucketsParam3(buckets []float64) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &StorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.buckets = &buckets
	mmHistogram.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmHistogram
}

// Inspect accepts an inspector function that has same arguments as the Storage.Histogram
func (mmHistogram *mStorageMockHistogram) Inspect(f func(metric string, labels map[string]string, buckets []float64)) *mStorageMockHistogram {
	if mmHistogram.mock.inspectFuncHistogram != nil {
		mmHistogram.mock.t.Fatalf("Inspect function is already set for StorageMock.Histogram")
	}

	mmHistogram.mock.inspectFuncHistogram = f

	return mmHistogram
}

// Return sets up results that will be returned by Storage.Histogram
func (mmHistogram *mStorageMockHistogram) Return(hp1 *prometheus.HistogramVec) *StorageMock {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{mock: mmHistogram.mock}
	}
	mmHistogram.defaultExpectation.results = &StorageMockHistogramResults{hp1}
	mmHistogram.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistogram.mock
}

// Set uses given function f to mock the Storage.Histogram method
func (mmHistogram *mStorageMockHistogram) Set(f func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)) *StorageMock {
	if mmHistogram.defaultExpectation != nil {
		mmHistogram.mock.t.Fatalf("Default expectation is already set for the Storage.Histogram method")
	}

	if len(mmHistogram.expectations) > 0 {
		mmHistogram.mock.t.Fatalf("Some expectations are already set for the Storage.Histogram method")
	}

	mmHistogram.mock.funcHistogram = f
	mmHistogram.mock.funcHistogramOrigin = minimock.CallerInfo(1)
	return mmHistogram.mock
}

// When sets expectation for the Storage.Histogram which will trigger the result defined by the following
// Then helper
func (mmHistogram *mStorageMockHistogram) When(metric string, labels map[string]string, buckets []float64) *StorageMockHistogramExpectation {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	expectation := &StorageMockHistogramExpectation{
		mock:               mmHistogram.mock,
		params:             &StorageMockHistogramParams{metric, labels, buckets},
		expectationOrigins: StorageMockHistogramExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistogram.expectations = append(mmHistogram.expectations, expectation)
	return expectation
}

// Then sets up Storage.Histogram return parameters for the expectation previously defined by the When method
func (e *StorageMockHistogramExpectation) Then(hp1 *prometheus.HistogramVec) *StorageMock {
	e.results = &StorageMockHistogramResults{hp1}
	return e.mock
}

// Times sets number of times Storage.Histogram should be invoked
func (mmHistogram *mStorageMockHistogram) Times(n uint64) *mStorageMockHistogram {
	if n == 0 {
		mmHistogram.mock.t.Fatalf("Times of StorageMock.Histogram mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistogram.expectedInvocations, n)
	mmHistogram.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistogram
}

func (mmHistogram *mStorageMockHistogram) invocationsDone() bool {
	if len(mmHistogram.expectations) == 0 && mmHistogram.defaultExpectation == nil && mmHistogram.mock.funcHistogram == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistogram.mock.afterHistogramCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistogram.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Histogram implements Storage
func (mmHistogram *StorageMock) Histogram(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec) {
	mm_atomic.AddUint64(&mmHistogram.beforeHistogramCounter, 1)
	defer mm_atomic.AddUint64(&mmHistogram.afterHistogramCounter, 1)

	mmHistogram.t.Helper()

	if mmHistogram.inspectFuncHistogram != nil {
		mmHistogram.inspectFuncHistogram(metric, labels, buckets)
	}

	mm_params := StorageMockHistogramParams{metric, labels, buckets}

	// Record call args
	mmHistogram.HistogramMock.mutex.Lock()
	mmHistogram.HistogramMock.callArgs = append(mmHistogram.HistogramMock.callArgs, &mm_params)
	mmHistogram.HistogramMock.mutex.Unlock()

	for _, e := range mmHistogram.HistogramMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1
		}
	}

	if mmHistogram.HistogramMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistogram.HistogramMock.defaultExpectation.Counter, 1)
		mm_want := mmHistogram.HistogramMock.defaultExpectation.params
		mm_want_ptrs := mmHistogram.HistogramMock.defaultExpectation.paramPtrs

		mm_got := StorageMockHistogramParams{metric, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHistogram.HistogramMock.defaultExpectation.results
		if mm_results == nil {
			mmHistogram.t.Fatal("No results are set for the StorageMock.Histogram")
		}
		return (*mm_results).hp1
	}
	if mmHistogram.funcHistogram != nil {
		return mmHistogram.funcHistogram(metric, labels, buckets)
	}
	mmHistogram.t.Fatalf("Unexpected call to StorageMock.Histogram. %v %v %v", metric, labels, buckets)
	return
}

// HistogramAfterCounter returns a count of finished StorageMock.Histogram invocations
func (mmHistogram *StorageMock) HistogramAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogram.afterHistogramCounter)
}

// HistogramBeforeCounter returns a count of StorageMock.Histogram invocations
func (mmHistogram *StorageMock) HistogramBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogram.beforeHistogramCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Histogram.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistogram *mStorageMockHistogram) Calls() []*StorageMockHistogramParams {
	mmHistogram.mutex.RLock()

	argCopy := make([]*StorageMockHistogramParams, len(mmHistogram.callArgs))
	copy(argCopy, mmHistogram.callArgs)

	mmHistogram.mutex.RUnlock()

	return argCopy
}

// MinimockHistogramDone returns true if the count of the Histogram invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockHistogramDone() bool {
	if m.HistogramMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistogramMock.invocationsDone()
}

// MinimockHistogramInspect logs each unmet expectation
func (m *StorageMock) MinimockHistogramInspect() {
	for _, e := range m.HistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Histogram at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistogramCounter := mm_atomic.LoadUint64(&m.afterHistogramCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistogramMock.defaultExpectation != nil && afterHistogramCounter < 1 {
		if m.HistogramMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.Histogram at\n%s", m.HistogramMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.Histogram at\n%s with params: %#v", m.HistogramMock.defaultExpectation.expectationOrigins.origin, *m.HistogramMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistogram != nil && afterHistogramCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Histogram at\n%s", m.funcHistogramOrigin)
	}

	if !m.HistogramMock.invocationsDone() && afterHistogramCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Histogram at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistogramMock.expectedInvocations), m.HistogramMock.expectedInvocationsOrigin, afterHistogramCounter)
	}
}

type mStorageMockHistogramObserve struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockHistogramObserveExpectation
	expectations       []*StorageMockHistogramObserveExpectation

	callArgs []*StorageMockHistogramObserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockHistogramObserveExpectation specifies expectation struct of the Storage.HistogramObserve
type StorageMockHistogramObserveExpectation struct {
	mock               *StorageMock
	params             *StorageMockHistogramObserveParams
	paramPtrs          *StorageMockHistogramObserveParamPtrs
	expectationOrigins StorageMockHistogramObserveExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockHistogramObserveParams contains parameters of the Storage.HistogramObserve
type StorageMockHistogramObserveParams struct {
	metric  string
	value   float64
	labels  map[string]string
	buckets []float64
}

// StorageMockHistogramObserveParamPtrs contains pointers to parameters of the Storage.HistogramObserve
type StorageMockHistogramObserveParamPtrs struct {
	metric  *string
	value   *float64
	labels  *map[string]string
	buckets *[]float64
}

// StorageMockHistogramObserveOrigins contains origins of expectations of the Storage.HistogramObserve
type StorageMockHistogramObserveExpectationOrigins struct {
	origin        string
	originMetric  string
	originValue   string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistogramObserve *mStorageMockHistogramObserve) Optional() *mStorageMockHistogramObserve {
	mmHistogramObserve.optional = true
	return mmHistogramObserve
}

// Expect sets up expected params for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) Expect(metric string, value float64, labels map[string]string, buckets []float64) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by ExpectParams functions")
	}

	mmHistogramObserve.defaultExpectation.params = &StorageMockHistogramObserveParams{metric, value, labels, buckets}
	mmHistogramObserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistogramObserve.expectations {
		if minimock.Equal(e.params, mmHistogramObserve.defaultExpectation.params) {
			mmHistogramObserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistogramObserve.defaultExpectation.params)
		}
	}

	return mmHistogramObserve
}

// ExpectMetricParam1 sets up expected param metric for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectMetricParam1(metric string) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.metric = &metric
	mmHistogramObserve.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectValueParam2 sets up expected param value for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectValueParam2(value float64) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.value = &value
	mmHistogramObserve.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectLabelsParam3 sets up expected param labels for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectLabelsParam3(labels map[string]string) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.labels = &labels
	mmHistogramObserve.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectBucketsParam4 sets up expected param buckets for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectBucketsParam4(buckets []float64) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.buckets = &buckets
	mmHistogramObserve.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// Inspect accepts an inspector function that has same arguments as the Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) Inspect(f func(metric string, value float64, labels map[string]string, buckets []float64)) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.inspectFuncHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("Inspect function is already set for StorageMock.HistogramObserve")
	}

	mmHistogramObserve.mock.inspectFuncHistogramObserve = f

	return mmHistogramObserve
}

// Return sets up results that will be returned by Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) Return() *StorageMock {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{mock: mmHistogramObserve.mock}
	}

	mmHistogramObserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve.mock
}

// Set uses given function f to mock the Storage.HistogramObserve method
func (mmHistogramObserve *mStorageMockHistogramObserve) Set(f func(metric string, value float64, labels map[string]string, buckets []float64)) *StorageMock {
	if mmHistogramObserve.defaultExpectation != nil {
		mmHistogramObserve.mock.t.Fatalf("Default expectation is already set for the Storage.HistogramObserve method")
	}

	if len(mmHistogramObserve.expectations) > 0 {
		mmHistogramObserve.mock.t.Fatalf("Some expectations are already set for the Storage.HistogramObserve method")
	}

	mmHistogramObserve.mock.funcHistogramObserve = f
	mmHistogramObserve.mock.funcHistogramObserveOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve.mock
}

// When sets expectation for the Storage.HistogramObserve which will trigger the result defined by the following
// Then helper
func (mmHistogramObserve *mStorageMockHistogramObserve) When(metric string, value float64, labels map[string]string, buckets []float64) *StorageMockHistogramObserveExpectation {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	expectation := &StorageMockHistogramObserveExpectation{
		mock:               mmHistogramObserve.mock,
		params:             &StorageMockHistogramObserveParams{metric, value, labels, buckets},
		expectationOrigins: StorageMockHistogramObserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistogramObserve.expectations = append(mmHistogramObserve.expectations, expectation)
	return expectation
}

// Then sets up Storage.HistogramObserve return parameters for the expectation previously defined by the When method

func (e *StorageMockHistogramObserveExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.HistogramObserve should be invoked
func (mmHistogramObserve *mStorageMockHistogramObserve) Times(n uint64) *mStorageMockHistogramObserve {
	if n == 0 {
		mmHistogramObserve.mock.t.Fatalf("Times of StorageMock.HistogramObserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistogramObserve.expectedInvocations, n)
	mmHistogramObserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve
}

func (mmHistogramObserve *mStorageMockHistogramObserve) invocationsDone() bool {
	if len(mmHistogramObserve.expectations) == 0 && mmHistogramObserve.defaultExpectation == nil && mmHistogramObserve.mock.funcHistogramObserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistogramObserve.mock.afterHistogramObserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistogramObserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HistogramObserve implements Storage
func (mmHistogramObserve *StorageMock) HistogramObserve(metric string, value float64, labels map[string]string, buckets []float64) {
	mm_atomic.AddUint64(&mmHistogramObserve.beforeHistogramObserveCounter, 1)
	defer mm_atomic.AddUint64(&mmHistogramObserve.afterHistogramObserveCounter, 1)

	mmHistogramObserve.t.Helper()

	if mmHistogramObserve.inspectFuncHistogramObserve != nil {
		mmHistogramObserve.inspectFuncHistogramObserve(metric, value, labels, buckets)
	}

	mm_params := StorageMockHistogramObserveParams{metric, value, labels, buckets}

	// Record call args
	mmHistogramObserve.HistogramObserveMock.mutex.Lock()
	mmHistogramObserve.HistogramObserveMock.callArgs = append(mmHistogramObserve.HistogramObserveMock.callArgs, &mm_params)
	mmHistogramObserve.HistogramObserveMock.mutex.Unlock()

	for _, e := range mmHistogramObserve.HistogramObserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmHistogramObserve.HistogramObserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistogramObserve.HistogramObserveMock.defaultExpectation.Counter, 1)
		mm_want := mmHistogramObserve.HistogramObserveMock.defaultExpectation.params
		mm_want_ptrs := mmHistogramObserve.HistogramObserveMock.defaultExpectation.paramPtrs

		mm_got := StorageMockHistogramObserveParams{metric, value, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmHistogramObserve.funcHistogramObserve != nil {
		mmHistogramObserve.funcHistogramObserve(metric, value, labels, buckets)
		return
	}
	mmHistogramObserve.t.Fatalf("Unexpected call to StorageMock.HistogramObserve. %v %v %v %v", metric, value, labels, buckets)

}

// HistogramObserveAfterCounter returns a count of finished StorageMock.HistogramObserve invocations
func (mmHistogramObserve *StorageMock) HistogramObserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogramObserve.afterHistogramObserveCounter)
}

// HistogramObserveBeforeCounter returns a count of StorageMock.HistogramObserve invocations
func (mmHistogramObserve *StorageMock) HistogramObserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogramObserve.beforeHistogramObserveCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.HistogramObserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistogramObserve *mStorageMockHistogramObserve) Calls() []*StorageMockHistogramObserveParams {
	mmHistogramObserve.mutex.RLock()

	argCopy := make([]*StorageMockHistogramObserveParams, len(mmHistogramObserve.callArgs))
	copy(argCopy, mmHistogramObserve.callArgs)

	mmHistogramObserve.mutex.RUnlock()

	return argCopy
}

// MinimockHistogramObserveDone returns true if the count of the HistogramObserve invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockHistogramObserveDone() bool {
	if m.HistogramObserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistogramObserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistogramObserveMock.invocationsDone()
}

// MinimockHistogramObserveInspect logs each unmet expectation
func (m *StorageMock) MinimockHistogramObserveInspect() {
	for _, e := range m.HistogramObserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistogramObserveCounter := mm_atomic.LoadUint64(&m.afterHistogramObserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistogramObserveMock.defaultExpectation != nil && afterHistogramObserveCounter < 1 {
		if m.HistogramObserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s", m.HistogramObserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s with params: %#v", m.HistogramObserveMock.defaultExpectation.expectationOrigins.origin, *m.HistogramObserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistogramObserve != nil && afterHistogramObserveCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s", m.funcHistogramObserveOrigin)
	}

	if !m.HistogramObserveMock.invocationsDone() && afterHistogramObserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.HistogramObserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistogramObserveMock.expectedInvocations), m.HistogramObserveMock.expectedInvocationsOrigin, afterHistogramObserveCounter)
	}
}

type mStorageMockRegisterCounter struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRegisterCounterExpectation
	expectations       []*StorageMockRegisterCounterExpectation

	callArgs []*StorageMockRegisterCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRegisterCounterExpectation specifies expectation struct of the Storage.RegisterCounter
type StorageMockRegisterCounterExpectation struct {
	mock               *StorageMock
	params             *StorageMockRegisterCounterParams
	paramPtrs          *StorageMockRegisterCounterParamPtrs
	expectationOrigins StorageMockRegisterCounterExpectationOrigins
	results            *StorageMockRegisterCounterResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRegisterCounterParams contains parameters of the Storage.RegisterCounter
type StorageMockRegisterCounterParams struct {
	metric string
	labels map[string]string
}

// StorageMockRegisterCounterParamPtrs contains pointers to parameters of the Storage.RegisterCounter
type StorageMockRegisterCounterParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockRegisterCounterResults contains results of the Storage.RegisterCounter
type StorageMockRegisterCounterResults struct {
	cp1 *prometheus.CounterVec
}

// StorageMockRegisterCounterOrigins contains origins of expectations of the Storage.RegisterCounter
type StorageMockRegisterCounterExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterCounter *mStorageMockRegisterCounter) Optional() *mStorageMockRegisterCounter {
	mmRegisterCounter.optional = true
	return mmRegisterCounter
}

// Expect sets up expected params for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) Expect(metric string, labels map[string]string) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by ExpectParams functions")
	}

	mmRegisterCounter.defaultExpectation.params = &StorageMockRegisterCounterParams{metric, labels}
	mmRegisterCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterCounter.expectations {
		if minimock.Equal(e.params, mmRegisterCounter.defaultExpectation.params) {
			mmRegisterCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterCounter.defaultExpectation.params)
		}
	}

	return mmRegisterCounter
}

// ExpectMetricParam1 sets up expected param metric for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) ExpectMetricParam1(metric string) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.params != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Expect")
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs == nil {
		mmRegisterCounter.defaultExpectation.paramPtrs = &StorageMockRegisterCounterParamPtrs{}
	}
	mmRegisterCounter.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterCounter.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterCounter
}

// ExpectLabelsParam2 sets up expected param labels for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) ExpectLabelsParam2(labels map[string]string) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.params != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Expect")
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs == nil {
		mmRegisterCounter.defaultExpectation.paramPtrs = &StorageMockRegisterCounterParamPtrs{}
	}
	mmRegisterCounter.defaultExpectation.paramPtrs.labels = &labels
	mmRegisterCounter.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmRegisterCounter
}

// Inspect accepts an inspector function that has same arguments as the Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) Inspect(f func(metric string, labels map[string]string)) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.inspectFuncRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("Inspect function is already set for StorageMock.RegisterCounter")
	}

	mmRegisterCounter.mock.inspectFuncRegisterCounter = f

	return mmRegisterCounter
}

// Return sets up results that will be returned by Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) Return(cp1 *prometheus.CounterVec) *StorageMock {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{mock: mmRegisterCounter.mock}
	}
	mmRegisterCounter.defaultExpectation.results = &StorageMockRegisterCounterResults{cp1}
	mmRegisterCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter.mock
}

// Set uses given function f to mock the Storage.RegisterCounter method
func (mmRegisterCounter *mStorageMockRegisterCounter) Set(f func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)) *StorageMock {
	if mmRegisterCounter.defaultExpectation != nil {
		mmRegisterCounter.mock.t.Fatalf("Default expectation is already set for the Storage.RegisterCounter method")
	}

	if len(mmRegisterCounter.expectations) > 0 {
		mmRegisterCounter.mock.t.Fatalf("Some expectations are already set for the Storage.RegisterCounter method")
	}

	mmRegisterCounter.mock.funcRegisterCounter = f
	mmRegisterCounter.mock.funcRegisterCounterOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter.mock
}

// When sets expectation for the Storage.RegisterCounter which will trigger the result defined by the following
// Then helper
func (mmRegisterCounter *mStorageMockRegisterCounter) When(metric string, labels map[string]string) *StorageMockRegisterCounterExpectation {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	expectation := &StorageMockRegisterCounterExpectation{
		mock:               mmRegisterCounter.mock,
		params:             &StorageMockRegisterCounterParams{metric, labels},
		expectationOrigins: StorageMockRegisterCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterCounter.expectations = append(mmRegisterCounter.expectations, expectation)
	return expectation
}

// Then sets up Storage.RegisterCounter return parameters for the expectation previously defined by the When method
func (e *StorageMockRegisterCounterExpectation) Then(cp1 *prometheus.CounterVec) *StorageMock {
	e.results = &StorageMockRegisterCounterResults{cp1}
	return e.mock
}

// Times sets number of times Storage.RegisterCounter should be invoked
func (mmRegisterCounter *mStorageMockRegisterCounter) Times(n uint64) *mStorageMockRegisterCounter {
	if n == 0 {
		mmRegisterCounter.mock.t.Fatalf("Times of StorageMock.RegisterCounter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterCounter.expectedInvocations, n)
	mmRegisterCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter
}

func (mmRegisterCounter *mStorageMockRegisterCounter) invocationsDone() bool {
	if len(mmRegisterCounter.expectations) == 0 && mmRegisterCounter.defaultExpectation == nil && mmRegisterCounter.mock.funcRegisterCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterCounter.mock.afterRegisterCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterCounter implements Storage
func (mmRegisterCounter *StorageMock) RegisterCounter(metric string, labels map[string]string) (cp1 *prometheus.CounterVec) {
	mm_atomic.AddUint64(&mmRegisterCounter.beforeRegisterCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterCounter.afterRegisterCounterCounter, 1)

	mmRegisterCounter.t.Helper()

	if mmRegisterCounter.inspectFuncRegisterCounter != nil {
		mmRegisterCounter.inspectFuncRegisterCounter(metric, labels)
	}

	mm_params := StorageMockRegisterCounterParams{metric, labels}

	// Record call args
	mmRegisterCounter.RegisterCounterMock.mutex.Lock()
	mmRegisterCounter.RegisterCounterMock.callArgs = append(mmRegisterCounter.RegisterCounterMock.callArgs, &mm_params)
	mmRegisterCounter.RegisterCounterMock.mutex.Unlock()

	for _, e := range mmRegisterCounter.RegisterCounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1
		}
	}

	if mmRegisterCounter.RegisterCounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterCounter.RegisterCounterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterCounter.RegisterCounterMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterCounter.RegisterCounterMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRegisterCounterParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterCounter.RegisterCounterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterCounter.t.Fatal("No results are set for the StorageMock.RegisterCounter")
		}
		return (*mm_results).cp1
	}
	if mmRegisterCounter.funcRegisterCounter != nil {
		return mmRegisterCounter.funcRegisterCounter(metric, labels)
	}
	mmRegisterCounter.t.Fatalf("Unexpected call to StorageMock.RegisterCounter. %v %v", metric, labels)
	return
}

// RegisterCounterAfterCounter returns a count of finished StorageMock.RegisterCounter invocations
func (mmRegisterCounter *StorageMock) RegisterCounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCounter.afterRegisterCounterCounter)
}

// RegisterCounterBeforeCounter returns a count of StorageMock.RegisterCounter invocations
func (mmRegisterCounter *StorageMock) RegisterCounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCounter.beforeRegisterCounterCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RegisterCounter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterCounter *mStorageMockRegisterCounter) Calls() []*StorageMockRegisterCounterParams {
	mmRegisterCounter.mutex.RLock()

	argCopy := make([]*StorageMockRegisterCounterParams, len(mmRegisterCounter.callArgs))
	copy(argCopy, mmRegisterCounter.callArgs)

	mmRegisterCounter.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterCounterDone returns true if the count of the RegisterCounter invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRegisterCounterDone() bool {
	if m.RegisterCounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterCounterMock.invocationsDone()
}

// MinimockRegisterCounterInspect logs each unmet expectation
func (m *StorageMock) MinimockRegisterCounterInspect() {
	for _, e := range m.RegisterCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterCounterCounter := mm_atomic.LoadUint64(&m.afterRegisterCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterCounterMock.defaultExpectation != nil && afterRegisterCounterCounter < 1 {
		if m.RegisterCounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s", m.RegisterCounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s with params: %#v", m.RegisterCounterMock.defaultExpectation.expectationOrigins.origin, *m.RegisterCounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterCounter != nil && afterRegisterCounterCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s", m.funcRegisterCounterOrigin)
	}

	if !m.RegisterCounterMock.invocationsDone() && afterRegisterCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RegisterCounter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterCounterMock.expectedInvocations), m.RegisterCounterMock.expectedInvocationsOrigin, afterRegisterCounterCounter)
	}
}

type mStorageMockRegisterGauge struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRegisterGaugeExpectation
	expectations       []*StorageMockRegisterGaugeExpectation

	callArgs []*StorageMockRegisterGaugeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRegisterGaugeExpectation specifies expectation struct of the Storage.RegisterGauge
type StorageMockRegisterGaugeExpectation struct {
	mock               *StorageMock
	params             *StorageMockRegisterGaugeParams
	paramPtrs          *StorageMockRegisterGaugeParamPtrs
	expectationOrigins StorageMockRegisterGaugeExpectationOrigins
	results            *StorageMockRegisterGaugeResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRegisterGaugeParams contains parameters of the Storage.RegisterGauge
type StorageMockRegisterGaugeParams struct {
	metric string
	labels map[string]string
}

// StorageMockRegisterGaugeParamPtrs contains pointers to parameters of the Storage.RegisterGauge
type StorageMockRegisterGaugeParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockRegisterGaugeResults contains results of the Storage.RegisterGauge
type StorageMockRegisterGaugeResults struct {
	gp1 *prometheus.GaugeVec
}

// StorageMockRegisterGaugeOrigins contains origins of expectations of the Storage.RegisterGauge
type StorageMockRegisterGaugeExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterGauge *mStorageMockRegisterGauge) Optional() *mStorageMockRegisterGauge {
	mmRegisterGauge.optional = true
	return mmRegisterGauge
}

// Expect sets up expected params for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) Expect(metric string, labels map[string]string) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by ExpectParams functions")
	}

	mmRegisterGauge.defaultExpectation.params = &StorageMockRegisterGaugeParams{metric, labels}
	mmRegisterGauge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterGauge.expectations {
		if minimock.Equal(e.params, mmRegisterGauge.defaultExpectation.params) {
			mmRegisterGauge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterGauge.defaultExpectation.params)
		}
	}

	return mmRegisterGauge
}

// ExpectMetricParam1 sets up expected param metric for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) ExpectMetricParam1(metric string) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.params != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Expect")
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs == nil {
		mmRegisterGauge.defaultExpectation.paramPtrs = &StorageMockRegisterGaugeParamPtrs{}
	}
	mmRegisterGauge.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterGauge.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterGauge
}

// ExpectLabelsParam2 sets up expected param labels for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) ExpectLabelsParam2(labels map[string]string) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.params != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Expect")
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs == nil {
		mmRegisterGauge.defaultExpectation.paramPtrs = &StorageMockRegisterGaugeParamPtrs{}
	}
	mmRegisterGauge.defaultExpectation.paramPtrs.labels = &labels
	mmRegisterGauge.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmRegisterGauge
}

// Inspect accepts an inspector function that has same arguments as the Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) Inspect(f func(metric string, labels map[string]string)) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.inspectFuncRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("Inspect function is already set for StorageMock.RegisterGauge")
	}

	mmRegisterGauge.mock.inspectFuncRegisterGauge = f

	return mmRegisterGauge
}

// Return sets up results that will be returned by Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) Return(gp1 *prometheus.GaugeVec) *StorageMock {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{mock: mmRegisterGauge.mock}
	}
	mmRegisterGauge.defaultExpectation.results = &StorageMockRegisterGaugeResults{gp1}
	mmRegisterGauge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge.mock
}

// Set uses given function f to mock the Storage.RegisterGauge method
func (mmRegisterGauge *mStorageMockRegisterGauge) Set(f func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)) *StorageMock {
	if mmRegisterGauge.defaultExpectation != nil {
		mmRegisterGauge.mock.t.Fatalf("Default expectation is already set for the Storage.RegisterGauge method")
	}

	if len(mmRegisterGauge.expectations) > 0 {
		mmRegisterGauge.mock.t.Fatalf("Some expectations are already set for the Storage.RegisterGauge method")
	}

	mmRegisterGauge.mock.funcRegisterGauge = f
	mmRegisterGauge.mock.funcRegisterGaugeOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge.mock
}

// When sets expectation for the Storage.RegisterGauge which will trigger the result defined by the following
// Then helper
func (mmRegisterGauge *mStorageMockRegisterGauge) When(metric string, labels map[string]string) *StorageMockRegisterGaugeExpectation {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	expectation := &StorageMockRegisterGaugeExpectation{
		mock:               mmRegisterGauge.mock,
		params:             &StorageMockRegisterGaugeParams{metric, labels},
		expectationOrigins: StorageMockRegisterGaugeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterGauge.expectations = append(mmRegisterGauge.expectations, expectation)
	return expectation
}

// Then sets up Storage.RegisterGauge return parameters for the expectation previously defined by the When method
func (e *StorageMockRegisterGaugeExpectation) Then(gp1 *prometheus.GaugeVec) *StorageMock {
	e.results = &StorageMockRegisterGaugeResults{gp1}
	return e.mock
}

// Times sets number of times Storage.RegisterGauge should be invoked
func (mmRegisterGauge *mStorageMockRegisterGauge) Times(n uint64) *mStorageMockRegisterGauge {
	if n == 0 {
		mmRegisterGauge.mock.t.Fatalf("Times of StorageMock.RegisterGauge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterGauge.expectedInvocations, n)
	mmRegisterGauge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge
}

func (mmRegisterGauge *mStorageMockRegisterGauge) invocationsDone() bool {
	if len(mmRegisterGauge.expectations) == 0 && mmRegisterGauge.defaultExpectation == nil && mmRegisterGauge.mock.funcRegisterGauge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterGauge.mock.afterRegisterGaugeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterGauge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterGauge implements Storage
func (mmRegisterGauge *StorageMock) RegisterGauge(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec) {
	mm_atomic.AddUint64(&mmRegisterGauge.beforeRegisterGaugeCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterGauge.afterRegisterGaugeCounter, 1)

	mmRegisterGauge.t.Helper()

	if mmRegisterGauge.inspectFuncRegisterGauge != nil {
		mmRegisterGauge.inspectFuncRegisterGauge(metric, labels)
	}

	mm_params := StorageMockRegisterGaugeParams{metric, labels}

	// Record call args
	mmRegisterGauge.RegisterGaugeMock.mutex.Lock()
	mmRegisterGauge.RegisterGaugeMock.callArgs = append(mmRegisterGauge.RegisterGaugeMock.callArgs, &mm_params)
	mmRegisterGauge.RegisterGaugeMock.mutex.Unlock()

	for _, e := range mmRegisterGauge.RegisterGaugeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1
		}
	}

	if mmRegisterGauge.RegisterGaugeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterGauge.RegisterGaugeMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRegisterGaugeParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterGauge.t.Fatal("No results are set for the StorageMock.RegisterGauge")
		}
		return (*mm_results).gp1
	}
	if mmRegisterGauge.funcRegisterGauge != nil {
		return mmRegisterGauge.funcRegisterGauge(metric, labels)
	}
	mmRegisterGauge.t.Fatalf("Unexpected call to StorageMock.RegisterGauge. %v %v", metric, labels)
	return
}

// RegisterGaugeAfterCounter returns a count of finished StorageMock.RegisterGauge invocations
func (mmRegisterGauge *StorageMock) RegisterGaugeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterGauge.afterRegisterGaugeCounter)
}

// RegisterGaugeBeforeCounter returns a count of StorageMock.RegisterGauge invocations
func (mmRegisterGauge *StorageMock) RegisterGaugeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterGauge.beforeRegisterGaugeCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RegisterGauge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterGauge *mStorageMockRegisterGauge) Calls() []*StorageMockRegisterGaugeParams {
	mmRegisterGauge.mutex.RLock()

	argCopy := make([]*StorageMockRegisterGaugeParams, len(mmRegisterGauge.callArgs))
	copy(argCopy, mmRegisterGauge.callArgs)

	mmRegisterGauge.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterGaugeDone returns true if the count of the RegisterGauge invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRegisterGaugeDone() bool {
	if m.RegisterGaugeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterGaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterGaugeMock.invocationsDone()
}

// MinimockRegisterGaugeInspect logs each unmet expectation
func (m *StorageMock) MinimockRegisterGaugeInspect() {
	for _, e := range m.RegisterGaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterGaugeCounter := mm_atomic.LoadUint64(&m.afterRegisterGaugeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterGaugeMock.defaultExpectation != nil && afterRegisterGaugeCounter < 1 {
		if m.RegisterGaugeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s", m.RegisterGaugeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s with params: %#v", m.RegisterGaugeMock.defaultExpectation.expectationOrigins.origin, *m.RegisterGaugeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterGauge != nil && afterRegisterGaugeCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s", m.funcRegisterGaugeOrigin)
	}

	if !m.RegisterGaugeMock.invocationsDone() && afterRegisterGaugeCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RegisterGauge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterGaugeMock.expectedInvocations), m.RegisterGaugeMock.expectedInvocationsOrigin, afterRegisterGaugeCounter)
	}
}

type mStorageMockRegisterHistogram struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRegisterHistogramExpectation
	expectations       []*StorageMockRegisterHistogramExpectation

	callArgs []*StorageMockRegisterHistogramParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRegisterHistogramExpectation specifies expectation struct of the Storage.RegisterHistogram
type StorageMockRegisterHistogramExpectation struct {
	mock               *StorageMock
	params             *StorageMockRegisterHistogramParams
	paramPtrs          *StorageMockRegisterHistogramParamPtrs
	expectationOrigins StorageMockRegisterHistogramExpectationOrigins
	results            *StorageMockRegisterHistogramResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRegisterHistogramParams contains parameters of the Storage.RegisterHistogram
type StorageMockRegisterHistogramParams struct {
	metric  string
	labels  map[string]string
	buckets []float64
}

// StorageMockRegisterHistogramParamPtrs contains pointers to parameters of the Storage.RegisterHistogram
type StorageMockRegisterHistogramParamPtrs struct {
	metric  *string
	labels  *map[string]string
	buckets *[]float64
}

// StorageMockRegisterHistogramResults contains results of the Storage.RegisterHistogram
type StorageMockRegisterHistogramResults struct {
	hp1 *prometheus.HistogramVec
}

// StorageMockRegisterHistogramOrigins contains origins of expectations of the Storage.RegisterHistogram
type StorageMockRegisterHistogramExpectationOrigins struct {
	origin        string
	originMetric  string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Optional() *mStorageMockRegisterHistogram {
	mmRegisterHistogram.optional = true
	return mmRegisterHistogram
}

// Expect sets up expected params for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Expect(metric string, labels map[string]string, buckets []float64) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by ExpectParams functions")
	}

	mmRegisterHistogram.defaultExpectation.params = &StorageMockRegisterHistogramParams{metric, labels, buckets}
	mmRegisterHistogram.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterHistogram.expectations {
		if minimock.Equal(e.params, mmRegisterHistogram.defaultExpectation.params) {
			mmRegisterHistogram.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterHistogram.defaultExpectation.params)
		}
	}

	return mmRegisterHistogram
}

// ExpectMetricParam1 sets up expected param metric for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectMetricParam1(metric string) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// ExpectLabelsParam2 sets up expected param labels for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectLabelsParam2(labels map[string]string) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.labels = &labels
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// ExpectBucketsParam3 sets up expected param buckets for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectBucketsParam3(buckets []float64) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.buckets = &buckets
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// Inspect accepts an inspector function that has same arguments as the Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Inspect(f func(metric string, labels map[string]string, buckets []float64)) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.inspectFuncRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("Inspect function is already set for StorageMock.RegisterHistogram")
	}

	mmRegisterHistogram.mock.inspectFuncRegisterHistogram = f

	return mmRegisterHistogram
}

// Return sets up results that will be returned by Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Return(hp1 *prometheus.HistogramVec) *StorageMock {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{mock: mmRegisterHistogram.mock}
	}
	mmRegisterHistogram.defaultExpectation.results = &StorageMockRegisterHistogramResults{hp1}
	mmRegisterHistogram.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram.mock
}

// Set uses given function f to mock the Storage.RegisterHistogram method
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Set(f func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)) *StorageMock {
	if mmRegisterHistogram.defaultExpectation != nil {
		mmRegisterHistogram.mock.t.Fatalf("Default expectation is already set for the Storage.RegisterHistogram method")
	}

	if len(mmRegisterHistogram.expectations) > 0 {
		mmRegisterHistogram.mock.t.Fatalf("Some expectations are already set for the Storage.RegisterHistogram method")
	}

	mmRegisterHistogram.mock.funcRegisterHistogram = f
	mmRegisterHistogram.mock.funcRegisterHistogramOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram.mock
}

// When sets expectation for the Storage.RegisterHistogram which will trigger the result defined by the following
// Then helper
func (mmRegisterHistogram *mStorageMockRegisterHistogram) When(metric string, labels map[string]string, buckets []float64) *StorageMockRegisterHistogramExpectation {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	expectation := &StorageMockRegisterHistogramExpectation{
		mock:               mmRegisterHistogram.mock,
		params:             &StorageMockRegisterHistogramParams{metric, labels, buckets},
		expectationOrigins: StorageMockRegisterHistogramExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterHistogram.expectations = append(mmRegisterHistogram.expectations, expectation)
	return expectation
}

// Then sets up Storage.RegisterHistogram return parameters for the expectation previously defined by the When method
func (e *StorageMockRegisterHistogramExpectation) Then(hp1 *prometheus.HistogramVec) *StorageMock {
	e.results = &StorageMockRegisterHistogramResults{hp1}
	return e.mock
}

// Times sets number of times Storage.RegisterHistogram should be invoked
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Times(n uint64) *mStorageMockRegisterHistogram {
	if n == 0 {
		mmRegisterHistogram.mock.t.Fatalf("Times of StorageMock.RegisterHistogram mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterHistogram.expectedInvocations, n)
	mmRegisterHistogram.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram
}

func (mmRegisterHistogram *mStorageMockRegisterHistogram) invocationsDone() bool {
	if len(mmRegisterHistogram.expectations) == 0 && mmRegisterHistogram.defaultExpectation == nil && mmRegisterHistogram.mock.funcRegisterHistogram == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterHistogram.mock.afterRegisterHistogramCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterHistogram.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterHistogram implements Storage
func (mmRegisterHistogram *StorageMock) RegisterHistogram(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec) {
	mm_atomic.AddUint64(&mmRegisterHistogram.beforeRegisterHistogramCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterHistogram.afterRegisterHistogramCounter, 1)

	mmRegisterHistogram.t.Helper()

	if mmRegisterHistogram.inspectFuncRegisterHistogram != nil {
		mmRegisterHistogram.inspectFuncRegisterHistogram(metric, labels, buckets)
	}

	mm_params := StorageMockRegisterHistogramParams{metric, labels, buckets}

	// Record call args
	mmRegisterHistogram.RegisterHistogramMock.mutex.Lock()
	mmRegisterHistogram.RegisterHistogramMock.callArgs = append(mmRegisterHistogram.RegisterHistogramMock.callArgs, &mm_params)
	mmRegisterHistogram.RegisterHistogramMock.mutex.Unlock()

	for _, e := range mmRegisterHistogram.RegisterHistogramMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1
		}
	}

	if mmRegisterHistogram.RegisterHistogramMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRegisterHistogramParams{metric, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterHistogram.t.Fatal("No results are set for the StorageMock.RegisterHistogram")
		}
		return (*mm_results).hp1
	}
	if mmRegisterHistogram.funcRegisterHistogram != nil {
		return mmRegisterHistogram.funcRegisterHistogram(metric, labels, buckets)
	}
	mmRegisterHistogram.t.Fatalf("Unexpected call to StorageMock.RegisterHistogram. %v %v %v", metric, labels, buckets)
	return
}

// RegisterHistogramAfterCounter returns a count of finished StorageMock.RegisterHistogram invocations
func (mmRegisterHistogram *StorageMock) RegisterHistogramAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterHistogram.afterRegisterHistogramCounter)
}

// RegisterHistogramBeforeCounter returns a count of StorageMock.RegisterHistogram invocations
func (mmRegisterHistogram *StorageMock) RegisterHistogramBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterHistogram.beforeRegisterHistogramCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RegisterHistogram.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Calls() []*StorageMockRegisterHistogramParams {
	mmRegisterHistogram.mutex.RLock()

	argCopy := make([]*StorageMockRegisterHistogramParams, len(mmRegisterHistogram.callArgs))
	copy(argCopy, mmRegisterHistogram.callArgs)

	mmRegisterHistogram.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterHistogramDone returns true if the count of the RegisterHistogram invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRegisterHistogramDone() bool {
	if m.RegisterHistogramMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterHistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterHistogramMock.invocationsDone()
}

// MinimockRegisterHistogramInspect logs each unmet expectation
func (m *StorageMock) MinimockRegisterHistogramInspect() {
	for _, e := range m.RegisterHistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterHistogramCounter := mm_atomic.LoadUint64(&m.afterRegisterHistogramCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterHistogramMock.defaultExpectation != nil && afterRegisterHistogramCounter < 1 {
		if m.RegisterHistogramMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s", m.RegisterHistogramMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s with params: %#v", m.RegisterHistogramMock.defaultExpectation.expectationOrigins.origin, *m.RegisterHistogramMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterHistogram != nil && afterRegisterHistogramCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s", m.funcRegisterHistogramOrigin)
	}

	if !m.RegisterHistogramMock.invocationsDone() && afterRegisterHistogramCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RegisterHistogram at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterHistogramMock.expectedInvocations), m.RegisterHistogramMock.expectedInvocationsOrigin, afterRegisterHistogramCounter)
	}
}

type mStorageMockSendBatch struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockSendBatchExpectation
	expectations       []*StorageMockSendBatchExpectation

	callArgs []*StorageMockSendBatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockSendBatchExpectation specifies expectation struct of the Storage.SendBatch
type StorageMockSendBatchExpectation struct {
	mock               *StorageMock
	params             *StorageMockSendBatchParams
	paramPtrs          *StorageMockSendBatchParamPtrs
	expectationOrigins StorageMockSendBatchExpectationOrigins
	results            *StorageMockSendBatchResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockSendBatchParams contains parameters of the Storage.SendBatch
type StorageMockSendBatchParams struct {
	ops    []operation.MetricOperation
	labels map[string]string
}

// StorageMockSendBatchParamPtrs contains pointers to parameters of the Storage.SendBatch
type StorageMockSendBatchParamPtrs struct {
	ops    *[]operation.MetricOperation
	labels *map[string]string
}

// StorageMockSendBatchResults contains results of the Storage.SendBatch
type StorageMockSendBatchResults struct {
	err error
}

// StorageMockSendBatchOrigins contains origins of expectations of the Storage.SendBatch
type StorageMockSendBatchExpectationOrigins struct {
	origin       string
	originOps    string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendBatch *mStorageMockSendBatch) Optional() *mStorageMockSendBatch {
	mmSendBatch.optional = true
	return mmSendBatch
}

// Expect sets up expected params for Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) Expect(ops []operation.MetricOperation, labels map[string]string) *mStorageMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &StorageMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.paramPtrs != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by ExpectParams functions")
	}

	mmSendBatch.defaultExpectation.params = &StorageMockSendBatchParams{ops, labels}
	mmSendBatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// ExpectOpsParam1 sets up expected param ops for Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) ExpectOpsParam1(ops []operation.MetricOperation) *mStorageMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &StorageMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &StorageMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.ops = &ops
	mmSendBatch.defaultExpectation.expectationOrigins.originOps = minimock.CallerInfo(1)

	return mmSendBatch
}

// ExpectLabelsParam2 sets up expected param labels for Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) ExpectLabelsParam2(labels map[string]string) *mStorageMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &StorageMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &StorageMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.labels = &labels
	mmSendBatch.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) Inspect(f func(ops []operation.MetricOperation, labels map[string]string)) *mStorageMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for StorageMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) Return(err error) *StorageMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &StorageMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &StorageMockSendBatchResults{err}
	mmSendBatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// Set uses given function f to mock the Storage.SendBatch method
func (mmSendBatch *mStorageMockSendBatch) Set(f func(ops []operation.MetricOperation, labels map[string]string) (err error)) *StorageMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the Storage.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the Storage.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	mmSendBatch.mock.funcSendBatchOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// When sets expectation for the Storage.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mStorageMockSendBatch) When(ops []operation.MetricOperation, labels map[string]string) *StorageMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	expectation := &StorageMockSendBatchExpectation{
		mock:               mmSendBatch.mock,
		params:             &StorageMockSendBatchParams{ops, labels},
		expectationOrigins: StorageMockSendBatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up Storage.SendBatch return parameters for the expectation previously defined by the When method
func (e *StorageMockSendBatchExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSendBatchResults{err}
	return e.mock
}

// Times sets number of times Storage.SendBatch should be invoked
func (mmSendBatch *mStorageMockSendBatch) Times(n uint64) *mStorageMockSendBatch {
	if n == 0 {
		mmSendBatch.mock.t.Fatalf("Times of StorageMock.SendBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendBatch.expectedInvocations, n)
	mmSendBatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendBatch
}

func (mmSendBatch *mStorageMockSendBatch) invocationsDone() bool {
	if len(mmSendBatch.expectations) == 0 && mmSendBatch.defaultExpectation == nil && mmSendBatch.mock.funcSendBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendBatch.mock.afterSendBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendBatch implements Storage
func (mmSendBatch *StorageMock) SendBatch(ops []operation.MetricOperation, labels map[string]string) (err error) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	mmSendBatch.t.Helper()

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ops, labels)
	}

	mm_params := StorageMockSendBatchParams{ops, labels}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, &mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_want_ptrs := mmSendBatch.SendBatchMock.defaultExpectation.paramPtrs

		mm_got := StorageMockSendBatchParams{ops, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ops != nil && !minimock.Equal(*mm_want_ptrs.ops, mm_got.ops) {
				mmSendBatch.t.Errorf("StorageMock.SendBatch got unexpected parameter ops, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originOps, *mm_want_ptrs.ops, mm_got.ops, minimock.Diff(*mm_want_ptrs.ops, mm_got.ops))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmSendBatch.t.Errorf("StorageMock.SendBatch got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("StorageMock.SendBatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the StorageMock.SendBatch")
		}
		return (*mm_results).err
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ops, labels)
	}
	mmSendBatch.t.Fatalf("Unexpected call to StorageMock.SendBatch. %v %v", ops, labels)
	return
}

// SendBatchAfterCounter returns a count of finished StorageMock.SendBatch invocations
func (mmSendBatch *StorageMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of StorageMock.SendBatch invocations
func (mmSendBatch *StorageMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mStorageMockSendBatch) Calls() []*StorageMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*StorageMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSendBatchDone() bool {
	if m.SendBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendBatchMock.invocationsDone()
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *StorageMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SendBatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendBatchCounter := mm_atomic.LoadUint64(&m.afterSendBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && afterSendBatchCounter < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.SendBatch at\n%s", m.SendBatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.SendBatch at\n%s with params: %#v", m.SendBatchMock.defaultExpectation.expectationOrigins.origin, *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && afterSendBatchCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.SendBatch at\n%s", m.funcSendBatchOrigin)
	}

	if !m.SendBatchMock.invocationsDone() && afterSendBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.SendBatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendBatchMock.expectedInvocations), m.SendBatchMock.expectedInvocationsOrigin, afterSendBatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockApplyOperationInspect()

			m.MinimockCounterInspect()

			m.MinimockCounterAddInspect()

			m.MinimockGaugeInspect()

			m.MinimockGaugeAddInspect()

			m.MinimockGaugeSetInspect()

			m.MinimockGroupedInspect()

			m.MinimockHandlerInspect()

			m.MinimockHistogramInspect()

			m.MinimockHistogramObserveInspect()

			m.MinimockRegisterCounterInspect()

			m.MinimockRegisterGaugeInspect()

			m.MinimockRegisterHistogramInspect()

			m.MinimockSendBatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockApplyOperationDone() &&
		m.MinimockCounterDone() &&
		m.MinimockCounterAddDone() &&
		m.MinimockGaugeDone() &&
		m.MinimockGaugeAddDone() &&
		m.MinimockGaugeSetDone() &&
		m.MinimockGroupedDone() &&
		m.MinimockHandlerDone() &&
		m.MinimockHistogramDone() &&
		m.MinimockHistogramObserveDone() &&
		m.MinimockRegisterCounterDone() &&
		m.MinimockRegisterGaugeDone() &&
		m.MinimockRegisterHistogramDone() &&
		m.MinimockSendBatchDone()
}
