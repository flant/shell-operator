// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package metric

//go:generate minimock -i github.com/deckhouse/deckhouse/pkg/metrics-storage.Storage -o storage_mock.go -n StorageMock -p metric

import (
	"net/http"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	mm_metricsstorage "github.com/deckhouse/deckhouse/pkg/metrics-storage"
	"github.com/deckhouse/deckhouse/pkg/metrics-storage/collectors"
	"github.com/deckhouse/deckhouse/pkg/metrics-storage/operation"
	"github.com/deckhouse/deckhouse/pkg/metrics-storage/options"
	"github.com/gojuno/minimock/v3"
	"github.com/prometheus/client_golang/prometheus"
)

// StorageMock implements mm_metricsstorage.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAddCollectorFunc          func(fn mm_metricsstorage.CollectorFunc)
	funcAddCollectorFuncOrigin    string
	inspectFuncAddCollectorFunc   func(fn mm_metricsstorage.CollectorFunc)
	afterAddCollectorFuncCounter  uint64
	beforeAddCollectorFuncCounter uint64
	AddCollectorFuncMock          mStorageMockAddCollectorFunc

	funcApplyBatchOperations          func(ops []operation.MetricOperation, labels map[string]string) (err error)
	funcApplyBatchOperationsOrigin    string
	inspectFuncApplyBatchOperations   func(ops []operation.MetricOperation, labels map[string]string)
	afterApplyBatchOperationsCounter  uint64
	beforeApplyBatchOperationsCounter uint64
	ApplyBatchOperationsMock          mStorageMockApplyBatchOperations

	funcApplyOperation          func(op operation.MetricOperation, commonLabels map[string]string) (err error)
	funcApplyOperationOrigin    string
	inspectFuncApplyOperation   func(op operation.MetricOperation, commonLabels map[string]string)
	afterApplyOperationCounter  uint64
	beforeApplyOperationCounter uint64
	ApplyOperationMock          mStorageMockApplyOperation

	funcCollector          func() (c1 prometheus.Collector)
	funcCollectorOrigin    string
	inspectFuncCollector   func()
	afterCollectorCounter  uint64
	beforeCollectorCounter uint64
	CollectorMock          mStorageMockCollector

	funcCounter          func(metric string, labels map[string]string) (cp1 *collectors.ConstCounterCollector)
	funcCounterOrigin    string
	inspectFuncCounter   func(metric string, labels map[string]string)
	afterCounterCounter  uint64
	beforeCounterCounter uint64
	CounterMock          mStorageMockCounter

	funcCounterAdd          func(metric string, value float64, labels map[string]string)
	funcCounterAddOrigin    string
	inspectFuncCounterAdd   func(metric string, value float64, labels map[string]string)
	afterCounterAddCounter  uint64
	beforeCounterAddCounter uint64
	CounterAddMock          mStorageMockCounterAdd

	funcGauge          func(metric string, labels map[string]string) (cp1 *collectors.ConstGaugeCollector)
	funcGaugeOrigin    string
	inspectFuncGauge   func(metric string, labels map[string]string)
	afterGaugeCounter  uint64
	beforeGaugeCounter uint64
	GaugeMock          mStorageMockGauge

	funcGaugeAdd          func(metric string, value float64, labels map[string]string)
	funcGaugeAddOrigin    string
	inspectFuncGaugeAdd   func(metric string, value float64, labels map[string]string)
	afterGaugeAddCounter  uint64
	beforeGaugeAddCounter uint64
	GaugeAddMock          mStorageMockGaugeAdd

	funcGaugeSet          func(metric string, value float64, labels map[string]string)
	funcGaugeSetOrigin    string
	inspectFuncGaugeSet   func(metric string, value float64, labels map[string]string)
	afterGaugeSetCounter  uint64
	beforeGaugeSetCounter uint64
	GaugeSetMock          mStorageMockGaugeSet

	funcGrouped          func() (g1 mm_metricsstorage.GroupedStorage)
	funcGroupedOrigin    string
	inspectFuncGrouped   func()
	afterGroupedCounter  uint64
	beforeGroupedCounter uint64
	GroupedMock          mStorageMockGrouped

	funcHandler          func() (h1 http.Handler)
	funcHandlerOrigin    string
	inspectFuncHandler   func()
	afterHandlerCounter  uint64
	beforeHandlerCounter uint64
	HandlerMock          mStorageMockHandler

	funcHistogram          func(metric string, labels map[string]string, buckets []float64) (cp1 *collectors.ConstHistogramCollector)
	funcHistogramOrigin    string
	inspectFuncHistogram   func(metric string, labels map[string]string, buckets []float64)
	afterHistogramCounter  uint64
	beforeHistogramCounter uint64
	HistogramMock          mStorageMockHistogram

	funcHistogramObserve          func(metric string, value float64, labels map[string]string, buckets []float64)
	funcHistogramObserveOrigin    string
	inspectFuncHistogramObserve   func(metric string, value float64, labels map[string]string, buckets []float64)
	afterHistogramObserveCounter  uint64
	beforeHistogramObserveCounter uint64
	HistogramObserveMock          mStorageMockHistogramObserve

	funcRegisterCounter          func(metric string, labelNames []string, opts ...options.RegisterOption) (cp1 *collectors.ConstCounterCollector, err error)
	funcRegisterCounterOrigin    string
	inspectFuncRegisterCounter   func(metric string, labelNames []string, opts ...options.RegisterOption)
	afterRegisterCounterCounter  uint64
	beforeRegisterCounterCounter uint64
	RegisterCounterMock          mStorageMockRegisterCounter

	funcRegisterGauge          func(metric string, labelNames []string, opts ...options.RegisterOption) (cp1 *collectors.ConstGaugeCollector, err error)
	funcRegisterGaugeOrigin    string
	inspectFuncRegisterGauge   func(metric string, labelNames []string, opts ...options.RegisterOption)
	afterRegisterGaugeCounter  uint64
	beforeRegisterGaugeCounter uint64
	RegisterGaugeMock          mStorageMockRegisterGauge

	funcRegisterHistogram          func(metric string, labelNames []string, buckets []float64, opts ...options.RegisterOption) (cp1 *collectors.ConstHistogramCollector, err error)
	funcRegisterHistogramOrigin    string
	inspectFuncRegisterHistogram   func(metric string, labelNames []string, buckets []float64, opts ...options.RegisterOption)
	afterRegisterHistogramCounter  uint64
	beforeRegisterHistogramCounter uint64
	RegisterHistogramMock          mStorageMockRegisterHistogram
}

// NewStorageMock returns a mock for mm_metricsstorage.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddCollectorFuncMock = mStorageMockAddCollectorFunc{mock: m}
	m.AddCollectorFuncMock.callArgs = []*StorageMockAddCollectorFuncParams{}

	m.ApplyBatchOperationsMock = mStorageMockApplyBatchOperations{mock: m}
	m.ApplyBatchOperationsMock.callArgs = []*StorageMockApplyBatchOperationsParams{}

	m.ApplyOperationMock = mStorageMockApplyOperation{mock: m}
	m.ApplyOperationMock.callArgs = []*StorageMockApplyOperationParams{}

	m.CollectorMock = mStorageMockCollector{mock: m}

	m.CounterMock = mStorageMockCounter{mock: m}
	m.CounterMock.callArgs = []*StorageMockCounterParams{}

	m.CounterAddMock = mStorageMockCounterAdd{mock: m}
	m.CounterAddMock.callArgs = []*StorageMockCounterAddParams{}

	m.GaugeMock = mStorageMockGauge{mock: m}
	m.GaugeMock.callArgs = []*StorageMockGaugeParams{}

	m.GaugeAddMock = mStorageMockGaugeAdd{mock: m}
	m.GaugeAddMock.callArgs = []*StorageMockGaugeAddParams{}

	m.GaugeSetMock = mStorageMockGaugeSet{mock: m}
	m.GaugeSetMock.callArgs = []*StorageMockGaugeSetParams{}

	m.GroupedMock = mStorageMockGrouped{mock: m}

	m.HandlerMock = mStorageMockHandler{mock: m}

	m.HistogramMock = mStorageMockHistogram{mock: m}
	m.HistogramMock.callArgs = []*StorageMockHistogramParams{}

	m.HistogramObserveMock = mStorageMockHistogramObserve{mock: m}
	m.HistogramObserveMock.callArgs = []*StorageMockHistogramObserveParams{}

	m.RegisterCounterMock = mStorageMockRegisterCounter{mock: m}
	m.RegisterCounterMock.callArgs = []*StorageMockRegisterCounterParams{}

	m.RegisterGaugeMock = mStorageMockRegisterGauge{mock: m}
	m.RegisterGaugeMock.callArgs = []*StorageMockRegisterGaugeParams{}

	m.RegisterHistogramMock = mStorageMockRegisterHistogram{mock: m}
	m.RegisterHistogramMock.callArgs = []*StorageMockRegisterHistogramParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockAddCollectorFunc struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockAddCollectorFuncExpectation
	expectations       []*StorageMockAddCollectorFuncExpectation

	callArgs []*StorageMockAddCollectorFuncParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockAddCollectorFuncExpectation specifies expectation struct of the Storage.AddCollectorFunc
type StorageMockAddCollectorFuncExpectation struct {
	mock               *StorageMock
	params             *StorageMockAddCollectorFuncParams
	paramPtrs          *StorageMockAddCollectorFuncParamPtrs
	expectationOrigins StorageMockAddCollectorFuncExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockAddCollectorFuncParams contains parameters of the Storage.AddCollectorFunc
type StorageMockAddCollectorFuncParams struct {
	fn mm_metricsstorage.CollectorFunc
}

// StorageMockAddCollectorFuncParamPtrs contains pointers to parameters of the Storage.AddCollectorFunc
type StorageMockAddCollectorFuncParamPtrs struct {
	fn *mm_metricsstorage.CollectorFunc
}

// StorageMockAddCollectorFuncOrigins contains origins of expectations of the Storage.AddCollectorFunc
type StorageMockAddCollectorFuncExpectationOrigins struct {
	origin   string
	originFn string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) Optional() *mStorageMockAddCollectorFunc {
	mmAddCollectorFunc.optional = true
	return mmAddCollectorFunc
}

// Expect sets up expected params for Storage.AddCollectorFunc
func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) Expect(fn mm_metricsstorage.CollectorFunc) *mStorageMockAddCollectorFunc {
	if mmAddCollectorFunc.mock.funcAddCollectorFunc != nil {
		mmAddCollectorFunc.mock.t.Fatalf("StorageMock.AddCollectorFunc mock is already set by Set")
	}

	if mmAddCollectorFunc.defaultExpectation == nil {
		mmAddCollectorFunc.defaultExpectation = &StorageMockAddCollectorFuncExpectation{}
	}

	if mmAddCollectorFunc.defaultExpectation.paramPtrs != nil {
		mmAddCollectorFunc.mock.t.Fatalf("StorageMock.AddCollectorFunc mock is already set by ExpectParams functions")
	}

	mmAddCollectorFunc.defaultExpectation.params = &StorageMockAddCollectorFuncParams{fn}
	mmAddCollectorFunc.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAddCollectorFunc.expectations {
		if minimock.Equal(e.params, mmAddCollectorFunc.defaultExpectation.params) {
			mmAddCollectorFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAddCollectorFunc.defaultExpectation.params)
		}
	}

	return mmAddCollectorFunc
}

// ExpectFnParam1 sets up expected param fn for Storage.AddCollectorFunc
func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) ExpectFnParam1(fn mm_metricsstorage.CollectorFunc) *mStorageMockAddCollectorFunc {
	if mmAddCollectorFunc.mock.funcAddCollectorFunc != nil {
		mmAddCollectorFunc.mock.t.Fatalf("StorageMock.AddCollectorFunc mock is already set by Set")
	}

	if mmAddCollectorFunc.defaultExpectation == nil {
		mmAddCollectorFunc.defaultExpectation = &StorageMockAddCollectorFuncExpectation{}
	}

	if mmAddCollectorFunc.defaultExpectation.params != nil {
		mmAddCollectorFunc.mock.t.Fatalf("StorageMock.AddCollectorFunc mock is already set by Expect")
	}

	if mmAddCollectorFunc.defaultExpectation.paramPtrs == nil {
		mmAddCollectorFunc.defaultExpectation.paramPtrs = &StorageMockAddCollectorFuncParamPtrs{}
	}
	mmAddCollectorFunc.defaultExpectation.paramPtrs.fn = &fn
	mmAddCollectorFunc.defaultExpectation.expectationOrigins.originFn = minimock.CallerInfo(1)

	return mmAddCollectorFunc
}

// Inspect accepts an inspector function that has same arguments as the Storage.AddCollectorFunc
func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) Inspect(f func(fn mm_metricsstorage.CollectorFunc)) *mStorageMockAddCollectorFunc {
	if mmAddCollectorFunc.mock.inspectFuncAddCollectorFunc != nil {
		mmAddCollectorFunc.mock.t.Fatalf("Inspect function is already set for StorageMock.AddCollectorFunc")
	}

	mmAddCollectorFunc.mock.inspectFuncAddCollectorFunc = f

	return mmAddCollectorFunc
}

// Return sets up results that will be returned by Storage.AddCollectorFunc
func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) Return() *StorageMock {
	if mmAddCollectorFunc.mock.funcAddCollectorFunc != nil {
		mmAddCollectorFunc.mock.t.Fatalf("StorageMock.AddCollectorFunc mock is already set by Set")
	}

	if mmAddCollectorFunc.defaultExpectation == nil {
		mmAddCollectorFunc.defaultExpectation = &StorageMockAddCollectorFuncExpectation{mock: mmAddCollectorFunc.mock}
	}

	mmAddCollectorFunc.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAddCollectorFunc.mock
}

// Set uses given function f to mock the Storage.AddCollectorFunc method
func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) Set(f func(fn mm_metricsstorage.CollectorFunc)) *StorageMock {
	if mmAddCollectorFunc.defaultExpectation != nil {
		mmAddCollectorFunc.mock.t.Fatalf("Default expectation is already set for the Storage.AddCollectorFunc method")
	}

	if len(mmAddCollectorFunc.expectations) > 0 {
		mmAddCollectorFunc.mock.t.Fatalf("Some expectations are already set for the Storage.AddCollectorFunc method")
	}

	mmAddCollectorFunc.mock.funcAddCollectorFunc = f
	mmAddCollectorFunc.mock.funcAddCollectorFuncOrigin = minimock.CallerInfo(1)
	return mmAddCollectorFunc.mock
}

// When sets expectation for the Storage.AddCollectorFunc which will trigger the result defined by the following
// Then helper
func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) When(fn mm_metricsstorage.CollectorFunc) *StorageMockAddCollectorFuncExpectation {
	if mmAddCollectorFunc.mock.funcAddCollectorFunc != nil {
		mmAddCollectorFunc.mock.t.Fatalf("StorageMock.AddCollectorFunc mock is already set by Set")
	}

	expectation := &StorageMockAddCollectorFuncExpectation{
		mock:               mmAddCollectorFunc.mock,
		params:             &StorageMockAddCollectorFuncParams{fn},
		expectationOrigins: StorageMockAddCollectorFuncExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAddCollectorFunc.expectations = append(mmAddCollectorFunc.expectations, expectation)
	return expectation
}

// Then sets up Storage.AddCollectorFunc return parameters for the expectation previously defined by the When method

func (e *StorageMockAddCollectorFuncExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.AddCollectorFunc should be invoked
func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) Times(n uint64) *mStorageMockAddCollectorFunc {
	if n == 0 {
		mmAddCollectorFunc.mock.t.Fatalf("Times of StorageMock.AddCollectorFunc mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAddCollectorFunc.expectedInvocations, n)
	mmAddCollectorFunc.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAddCollectorFunc
}

func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) invocationsDone() bool {
	if len(mmAddCollectorFunc.expectations) == 0 && mmAddCollectorFunc.defaultExpectation == nil && mmAddCollectorFunc.mock.funcAddCollectorFunc == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAddCollectorFunc.mock.afterAddCollectorFuncCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAddCollectorFunc.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// AddCollectorFunc implements mm_metricsstorage.Storage
func (mmAddCollectorFunc *StorageMock) AddCollectorFunc(fn mm_metricsstorage.CollectorFunc) {
	mm_atomic.AddUint64(&mmAddCollectorFunc.beforeAddCollectorFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmAddCollectorFunc.afterAddCollectorFuncCounter, 1)

	mmAddCollectorFunc.t.Helper()

	if mmAddCollectorFunc.inspectFuncAddCollectorFunc != nil {
		mmAddCollectorFunc.inspectFuncAddCollectorFunc(fn)
	}

	mm_params := StorageMockAddCollectorFuncParams{fn}

	// Record call args
	mmAddCollectorFunc.AddCollectorFuncMock.mutex.Lock()
	mmAddCollectorFunc.AddCollectorFuncMock.callArgs = append(mmAddCollectorFunc.AddCollectorFuncMock.callArgs, &mm_params)
	mmAddCollectorFunc.AddCollectorFuncMock.mutex.Unlock()

	for _, e := range mmAddCollectorFunc.AddCollectorFuncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmAddCollectorFunc.AddCollectorFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAddCollectorFunc.AddCollectorFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmAddCollectorFunc.AddCollectorFuncMock.defaultExpectation.params
		mm_want_ptrs := mmAddCollectorFunc.AddCollectorFuncMock.defaultExpectation.paramPtrs

		mm_got := StorageMockAddCollectorFuncParams{fn}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.fn != nil && !minimock.Equal(*mm_want_ptrs.fn, mm_got.fn) {
				mmAddCollectorFunc.t.Errorf("StorageMock.AddCollectorFunc got unexpected parameter fn, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAddCollectorFunc.AddCollectorFuncMock.defaultExpectation.expectationOrigins.originFn, *mm_want_ptrs.fn, mm_got.fn, minimock.Diff(*mm_want_ptrs.fn, mm_got.fn))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAddCollectorFunc.t.Errorf("StorageMock.AddCollectorFunc got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAddCollectorFunc.AddCollectorFuncMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmAddCollectorFunc.funcAddCollectorFunc != nil {
		mmAddCollectorFunc.funcAddCollectorFunc(fn)
		return
	}
	mmAddCollectorFunc.t.Fatalf("Unexpected call to StorageMock.AddCollectorFunc. %v", fn)

}

// AddCollectorFuncAfterCounter returns a count of finished StorageMock.AddCollectorFunc invocations
func (mmAddCollectorFunc *StorageMock) AddCollectorFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCollectorFunc.afterAddCollectorFuncCounter)
}

// AddCollectorFuncBeforeCounter returns a count of StorageMock.AddCollectorFunc invocations
func (mmAddCollectorFunc *StorageMock) AddCollectorFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAddCollectorFunc.beforeAddCollectorFuncCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.AddCollectorFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAddCollectorFunc *mStorageMockAddCollectorFunc) Calls() []*StorageMockAddCollectorFuncParams {
	mmAddCollectorFunc.mutex.RLock()

	argCopy := make([]*StorageMockAddCollectorFuncParams, len(mmAddCollectorFunc.callArgs))
	copy(argCopy, mmAddCollectorFunc.callArgs)

	mmAddCollectorFunc.mutex.RUnlock()

	return argCopy
}

// MinimockAddCollectorFuncDone returns true if the count of the AddCollectorFunc invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockAddCollectorFuncDone() bool {
	if m.AddCollectorFuncMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddCollectorFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddCollectorFuncMock.invocationsDone()
}

// MinimockAddCollectorFuncInspect logs each unmet expectation
func (m *StorageMock) MinimockAddCollectorFuncInspect() {
	for _, e := range m.AddCollectorFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.AddCollectorFunc at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCollectorFuncCounter := mm_atomic.LoadUint64(&m.afterAddCollectorFuncCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddCollectorFuncMock.defaultExpectation != nil && afterAddCollectorFuncCounter < 1 {
		if m.AddCollectorFuncMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.AddCollectorFunc at\n%s", m.AddCollectorFuncMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.AddCollectorFunc at\n%s with params: %#v", m.AddCollectorFuncMock.defaultExpectation.expectationOrigins.origin, *m.AddCollectorFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAddCollectorFunc != nil && afterAddCollectorFuncCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.AddCollectorFunc at\n%s", m.funcAddCollectorFuncOrigin)
	}

	if !m.AddCollectorFuncMock.invocationsDone() && afterAddCollectorFuncCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.AddCollectorFunc at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddCollectorFuncMock.expectedInvocations), m.AddCollectorFuncMock.expectedInvocationsOrigin, afterAddCollectorFuncCounter)
	}
}

type mStorageMockApplyBatchOperations struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockApplyBatchOperationsExpectation
	expectations       []*StorageMockApplyBatchOperationsExpectation

	callArgs []*StorageMockApplyBatchOperationsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockApplyBatchOperationsExpectation specifies expectation struct of the Storage.ApplyBatchOperations
type StorageMockApplyBatchOperationsExpectation struct {
	mock               *StorageMock
	params             *StorageMockApplyBatchOperationsParams
	paramPtrs          *StorageMockApplyBatchOperationsParamPtrs
	expectationOrigins StorageMockApplyBatchOperationsExpectationOrigins
	results            *StorageMockApplyBatchOperationsResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockApplyBatchOperationsParams contains parameters of the Storage.ApplyBatchOperations
type StorageMockApplyBatchOperationsParams struct {
	ops    []operation.MetricOperation
	labels map[string]string
}

// StorageMockApplyBatchOperationsParamPtrs contains pointers to parameters of the Storage.ApplyBatchOperations
type StorageMockApplyBatchOperationsParamPtrs struct {
	ops    *[]operation.MetricOperation
	labels *map[string]string
}

// StorageMockApplyBatchOperationsResults contains results of the Storage.ApplyBatchOperations
type StorageMockApplyBatchOperationsResults struct {
	err error
}

// StorageMockApplyBatchOperationsOrigins contains origins of expectations of the Storage.ApplyBatchOperations
type StorageMockApplyBatchOperationsExpectationOrigins struct {
	origin       string
	originOps    string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) Optional() *mStorageMockApplyBatchOperations {
	mmApplyBatchOperations.optional = true
	return mmApplyBatchOperations
}

// Expect sets up expected params for Storage.ApplyBatchOperations
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) Expect(ops []operation.MetricOperation, labels map[string]string) *mStorageMockApplyBatchOperations {
	if mmApplyBatchOperations.mock.funcApplyBatchOperations != nil {
		mmApplyBatchOperations.mock.t.Fatalf("StorageMock.ApplyBatchOperations mock is already set by Set")
	}

	if mmApplyBatchOperations.defaultExpectation == nil {
		mmApplyBatchOperations.defaultExpectation = &StorageMockApplyBatchOperationsExpectation{}
	}

	if mmApplyBatchOperations.defaultExpectation.paramPtrs != nil {
		mmApplyBatchOperations.mock.t.Fatalf("StorageMock.ApplyBatchOperations mock is already set by ExpectParams functions")
	}

	mmApplyBatchOperations.defaultExpectation.params = &StorageMockApplyBatchOperationsParams{ops, labels}
	mmApplyBatchOperations.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmApplyBatchOperations.expectations {
		if minimock.Equal(e.params, mmApplyBatchOperations.defaultExpectation.params) {
			mmApplyBatchOperations.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyBatchOperations.defaultExpectation.params)
		}
	}

	return mmApplyBatchOperations
}

// ExpectOpsParam1 sets up expected param ops for Storage.ApplyBatchOperations
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) ExpectOpsParam1(ops []operation.MetricOperation) *mStorageMockApplyBatchOperations {
	if mmApplyBatchOperations.mock.funcApplyBatchOperations != nil {
		mmApplyBatchOperations.mock.t.Fatalf("StorageMock.ApplyBatchOperations mock is already set by Set")
	}

	if mmApplyBatchOperations.defaultExpectation == nil {
		mmApplyBatchOperations.defaultExpectation = &StorageMockApplyBatchOperationsExpectation{}
	}

	if mmApplyBatchOperations.defaultExpectation.params != nil {
		mmApplyBatchOperations.mock.t.Fatalf("StorageMock.ApplyBatchOperations mock is already set by Expect")
	}

	if mmApplyBatchOperations.defaultExpectation.paramPtrs == nil {
		mmApplyBatchOperations.defaultExpectation.paramPtrs = &StorageMockApplyBatchOperationsParamPtrs{}
	}
	mmApplyBatchOperations.defaultExpectation.paramPtrs.ops = &ops
	mmApplyBatchOperations.defaultExpectation.expectationOrigins.originOps = minimock.CallerInfo(1)

	return mmApplyBatchOperations
}

// ExpectLabelsParam2 sets up expected param labels for Storage.ApplyBatchOperations
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) ExpectLabelsParam2(labels map[string]string) *mStorageMockApplyBatchOperations {
	if mmApplyBatchOperations.mock.funcApplyBatchOperations != nil {
		mmApplyBatchOperations.mock.t.Fatalf("StorageMock.ApplyBatchOperations mock is already set by Set")
	}

	if mmApplyBatchOperations.defaultExpectation == nil {
		mmApplyBatchOperations.defaultExpectation = &StorageMockApplyBatchOperationsExpectation{}
	}

	if mmApplyBatchOperations.defaultExpectation.params != nil {
		mmApplyBatchOperations.mock.t.Fatalf("StorageMock.ApplyBatchOperations mock is already set by Expect")
	}

	if mmApplyBatchOperations.defaultExpectation.paramPtrs == nil {
		mmApplyBatchOperations.defaultExpectation.paramPtrs = &StorageMockApplyBatchOperationsParamPtrs{}
	}
	mmApplyBatchOperations.defaultExpectation.paramPtrs.labels = &labels
	mmApplyBatchOperations.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmApplyBatchOperations
}

// Inspect accepts an inspector function that has same arguments as the Storage.ApplyBatchOperations
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) Inspect(f func(ops []operation.MetricOperation, labels map[string]string)) *mStorageMockApplyBatchOperations {
	if mmApplyBatchOperations.mock.inspectFuncApplyBatchOperations != nil {
		mmApplyBatchOperations.mock.t.Fatalf("Inspect function is already set for StorageMock.ApplyBatchOperations")
	}

	mmApplyBatchOperations.mock.inspectFuncApplyBatchOperations = f

	return mmApplyBatchOperations
}

// Return sets up results that will be returned by Storage.ApplyBatchOperations
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) Return(err error) *StorageMock {
	if mmApplyBatchOperations.mock.funcApplyBatchOperations != nil {
		mmApplyBatchOperations.mock.t.Fatalf("StorageMock.ApplyBatchOperations mock is already set by Set")
	}

	if mmApplyBatchOperations.defaultExpectation == nil {
		mmApplyBatchOperations.defaultExpectation = &StorageMockApplyBatchOperationsExpectation{mock: mmApplyBatchOperations.mock}
	}
	mmApplyBatchOperations.defaultExpectation.results = &StorageMockApplyBatchOperationsResults{err}
	mmApplyBatchOperations.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmApplyBatchOperations.mock
}

// Set uses given function f to mock the Storage.ApplyBatchOperations method
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) Set(f func(ops []operation.MetricOperation, labels map[string]string) (err error)) *StorageMock {
	if mmApplyBatchOperations.defaultExpectation != nil {
		mmApplyBatchOperations.mock.t.Fatalf("Default expectation is already set for the Storage.ApplyBatchOperations method")
	}

	if len(mmApplyBatchOperations.expectations) > 0 {
		mmApplyBatchOperations.mock.t.Fatalf("Some expectations are already set for the Storage.ApplyBatchOperations method")
	}

	mmApplyBatchOperations.mock.funcApplyBatchOperations = f
	mmApplyBatchOperations.mock.funcApplyBatchOperationsOrigin = minimock.CallerInfo(1)
	return mmApplyBatchOperations.mock
}

// When sets expectation for the Storage.ApplyBatchOperations which will trigger the result defined by the following
// Then helper
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) When(ops []operation.MetricOperation, labels map[string]string) *StorageMockApplyBatchOperationsExpectation {
	if mmApplyBatchOperations.mock.funcApplyBatchOperations != nil {
		mmApplyBatchOperations.mock.t.Fatalf("StorageMock.ApplyBatchOperations mock is already set by Set")
	}

	expectation := &StorageMockApplyBatchOperationsExpectation{
		mock:               mmApplyBatchOperations.mock,
		params:             &StorageMockApplyBatchOperationsParams{ops, labels},
		expectationOrigins: StorageMockApplyBatchOperationsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmApplyBatchOperations.expectations = append(mmApplyBatchOperations.expectations, expectation)
	return expectation
}

// Then sets up Storage.ApplyBatchOperations return parameters for the expectation previously defined by the When method
func (e *StorageMockApplyBatchOperationsExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockApplyBatchOperationsResults{err}
	return e.mock
}

// Times sets number of times Storage.ApplyBatchOperations should be invoked
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) Times(n uint64) *mStorageMockApplyBatchOperations {
	if n == 0 {
		mmApplyBatchOperations.mock.t.Fatalf("Times of StorageMock.ApplyBatchOperations mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmApplyBatchOperations.expectedInvocations, n)
	mmApplyBatchOperations.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmApplyBatchOperations
}

func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) invocationsDone() bool {
	if len(mmApplyBatchOperations.expectations) == 0 && mmApplyBatchOperations.defaultExpectation == nil && mmApplyBatchOperations.mock.funcApplyBatchOperations == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmApplyBatchOperations.mock.afterApplyBatchOperationsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmApplyBatchOperations.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ApplyBatchOperations implements mm_metricsstorage.Storage
func (mmApplyBatchOperations *StorageMock) ApplyBatchOperations(ops []operation.MetricOperation, labels map[string]string) (err error) {
	mm_atomic.AddUint64(&mmApplyBatchOperations.beforeApplyBatchOperationsCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyBatchOperations.afterApplyBatchOperationsCounter, 1)

	mmApplyBatchOperations.t.Helper()

	if mmApplyBatchOperations.inspectFuncApplyBatchOperations != nil {
		mmApplyBatchOperations.inspectFuncApplyBatchOperations(ops, labels)
	}

	mm_params := StorageMockApplyBatchOperationsParams{ops, labels}

	// Record call args
	mmApplyBatchOperations.ApplyBatchOperationsMock.mutex.Lock()
	mmApplyBatchOperations.ApplyBatchOperationsMock.callArgs = append(mmApplyBatchOperations.ApplyBatchOperationsMock.callArgs, &mm_params)
	mmApplyBatchOperations.ApplyBatchOperationsMock.mutex.Unlock()

	for _, e := range mmApplyBatchOperations.ApplyBatchOperationsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmApplyBatchOperations.ApplyBatchOperationsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyBatchOperations.ApplyBatchOperationsMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyBatchOperations.ApplyBatchOperationsMock.defaultExpectation.params
		mm_want_ptrs := mmApplyBatchOperations.ApplyBatchOperationsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockApplyBatchOperationsParams{ops, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ops != nil && !minimock.Equal(*mm_want_ptrs.ops, mm_got.ops) {
				mmApplyBatchOperations.t.Errorf("StorageMock.ApplyBatchOperations got unexpected parameter ops, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyBatchOperations.ApplyBatchOperationsMock.defaultExpectation.expectationOrigins.originOps, *mm_want_ptrs.ops, mm_got.ops, minimock.Diff(*mm_want_ptrs.ops, mm_got.ops))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmApplyBatchOperations.t.Errorf("StorageMock.ApplyBatchOperations got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyBatchOperations.ApplyBatchOperationsMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyBatchOperations.t.Errorf("StorageMock.ApplyBatchOperations got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmApplyBatchOperations.ApplyBatchOperationsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApplyBatchOperations.ApplyBatchOperationsMock.defaultExpectation.results
		if mm_results == nil {
			mmApplyBatchOperations.t.Fatal("No results are set for the StorageMock.ApplyBatchOperations")
		}
		return (*mm_results).err
	}
	if mmApplyBatchOperations.funcApplyBatchOperations != nil {
		return mmApplyBatchOperations.funcApplyBatchOperations(ops, labels)
	}
	mmApplyBatchOperations.t.Fatalf("Unexpected call to StorageMock.ApplyBatchOperations. %v %v", ops, labels)
	return
}

// ApplyBatchOperationsAfterCounter returns a count of finished StorageMock.ApplyBatchOperations invocations
func (mmApplyBatchOperations *StorageMock) ApplyBatchOperationsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyBatchOperations.afterApplyBatchOperationsCounter)
}

// ApplyBatchOperationsBeforeCounter returns a count of StorageMock.ApplyBatchOperations invocations
func (mmApplyBatchOperations *StorageMock) ApplyBatchOperationsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyBatchOperations.beforeApplyBatchOperationsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ApplyBatchOperations.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyBatchOperations *mStorageMockApplyBatchOperations) Calls() []*StorageMockApplyBatchOperationsParams {
	mmApplyBatchOperations.mutex.RLock()

	argCopy := make([]*StorageMockApplyBatchOperationsParams, len(mmApplyBatchOperations.callArgs))
	copy(argCopy, mmApplyBatchOperations.callArgs)

	mmApplyBatchOperations.mutex.RUnlock()

	return argCopy
}

// MinimockApplyBatchOperationsDone returns true if the count of the ApplyBatchOperations invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockApplyBatchOperationsDone() bool {
	if m.ApplyBatchOperationsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ApplyBatchOperationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ApplyBatchOperationsMock.invocationsDone()
}

// MinimockApplyBatchOperationsInspect logs each unmet expectation
func (m *StorageMock) MinimockApplyBatchOperationsInspect() {
	for _, e := range m.ApplyBatchOperationsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ApplyBatchOperations at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterApplyBatchOperationsCounter := mm_atomic.LoadUint64(&m.afterApplyBatchOperationsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyBatchOperationsMock.defaultExpectation != nil && afterApplyBatchOperationsCounter < 1 {
		if m.ApplyBatchOperationsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ApplyBatchOperations at\n%s", m.ApplyBatchOperationsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ApplyBatchOperations at\n%s with params: %#v", m.ApplyBatchOperationsMock.defaultExpectation.expectationOrigins.origin, *m.ApplyBatchOperationsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyBatchOperations != nil && afterApplyBatchOperationsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ApplyBatchOperations at\n%s", m.funcApplyBatchOperationsOrigin)
	}

	if !m.ApplyBatchOperationsMock.invocationsDone() && afterApplyBatchOperationsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ApplyBatchOperations at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ApplyBatchOperationsMock.expectedInvocations), m.ApplyBatchOperationsMock.expectedInvocationsOrigin, afterApplyBatchOperationsCounter)
	}
}

type mStorageMockApplyOperation struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockApplyOperationExpectation
	expectations       []*StorageMockApplyOperationExpectation

	callArgs []*StorageMockApplyOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockApplyOperationExpectation specifies expectation struct of the Storage.ApplyOperation
type StorageMockApplyOperationExpectation struct {
	mock               *StorageMock
	params             *StorageMockApplyOperationParams
	paramPtrs          *StorageMockApplyOperationParamPtrs
	expectationOrigins StorageMockApplyOperationExpectationOrigins
	results            *StorageMockApplyOperationResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockApplyOperationParams contains parameters of the Storage.ApplyOperation
type StorageMockApplyOperationParams struct {
	op           operation.MetricOperation
	commonLabels map[string]string
}

// StorageMockApplyOperationParamPtrs contains pointers to parameters of the Storage.ApplyOperation
type StorageMockApplyOperationParamPtrs struct {
	op           *operation.MetricOperation
	commonLabels *map[string]string
}

// StorageMockApplyOperationResults contains results of the Storage.ApplyOperation
type StorageMockApplyOperationResults struct {
	err error
}

// StorageMockApplyOperationOrigins contains origins of expectations of the Storage.ApplyOperation
type StorageMockApplyOperationExpectationOrigins struct {
	origin             string
	originOp           string
	originCommonLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmApplyOperation *mStorageMockApplyOperation) Optional() *mStorageMockApplyOperation {
	mmApplyOperation.optional = true
	return mmApplyOperation
}

// Expect sets up expected params for Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) Expect(op operation.MetricOperation, commonLabels map[string]string) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.paramPtrs != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by ExpectParams functions")
	}

	mmApplyOperation.defaultExpectation.params = &StorageMockApplyOperationParams{op, commonLabels}
	mmApplyOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmApplyOperation.expectations {
		if minimock.Equal(e.params, mmApplyOperation.defaultExpectation.params) {
			mmApplyOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyOperation.defaultExpectation.params)
		}
	}

	return mmApplyOperation
}

// ExpectOpParam1 sets up expected param op for Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) ExpectOpParam1(op operation.MetricOperation) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.params != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Expect")
	}

	if mmApplyOperation.defaultExpectation.paramPtrs == nil {
		mmApplyOperation.defaultExpectation.paramPtrs = &StorageMockApplyOperationParamPtrs{}
	}
	mmApplyOperation.defaultExpectation.paramPtrs.op = &op
	mmApplyOperation.defaultExpectation.expectationOrigins.originOp = minimock.CallerInfo(1)

	return mmApplyOperation
}

// ExpectCommonLabelsParam2 sets up expected param commonLabels for Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) ExpectCommonLabelsParam2(commonLabels map[string]string) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.params != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Expect")
	}

	if mmApplyOperation.defaultExpectation.paramPtrs == nil {
		mmApplyOperation.defaultExpectation.paramPtrs = &StorageMockApplyOperationParamPtrs{}
	}
	mmApplyOperation.defaultExpectation.paramPtrs.commonLabels = &commonLabels
	mmApplyOperation.defaultExpectation.expectationOrigins.originCommonLabels = minimock.CallerInfo(1)

	return mmApplyOperation
}

// Inspect accepts an inspector function that has same arguments as the Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) Inspect(f func(op operation.MetricOperation, commonLabels map[string]string)) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.inspectFuncApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("Inspect function is already set for StorageMock.ApplyOperation")
	}

	mmApplyOperation.mock.inspectFuncApplyOperation = f

	return mmApplyOperation
}

// Return sets up results that will be returned by Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) Return(err error) *StorageMock {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{mock: mmApplyOperation.mock}
	}
	mmApplyOperation.defaultExpectation.results = &StorageMockApplyOperationResults{err}
	mmApplyOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmApplyOperation.mock
}

// Set uses given function f to mock the Storage.ApplyOperation method
func (mmApplyOperation *mStorageMockApplyOperation) Set(f func(op operation.MetricOperation, commonLabels map[string]string) (err error)) *StorageMock {
	if mmApplyOperation.defaultExpectation != nil {
		mmApplyOperation.mock.t.Fatalf("Default expectation is already set for the Storage.ApplyOperation method")
	}

	if len(mmApplyOperation.expectations) > 0 {
		mmApplyOperation.mock.t.Fatalf("Some expectations are already set for the Storage.ApplyOperation method")
	}

	mmApplyOperation.mock.funcApplyOperation = f
	mmApplyOperation.mock.funcApplyOperationOrigin = minimock.CallerInfo(1)
	return mmApplyOperation.mock
}

// When sets expectation for the Storage.ApplyOperation which will trigger the result defined by the following
// Then helper
func (mmApplyOperation *mStorageMockApplyOperation) When(op operation.MetricOperation, commonLabels map[string]string) *StorageMockApplyOperationExpectation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	expectation := &StorageMockApplyOperationExpectation{
		mock:               mmApplyOperation.mock,
		params:             &StorageMockApplyOperationParams{op, commonLabels},
		expectationOrigins: StorageMockApplyOperationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmApplyOperation.expectations = append(mmApplyOperation.expectations, expectation)
	return expectation
}

// Then sets up Storage.ApplyOperation return parameters for the expectation previously defined by the When method
func (e *StorageMockApplyOperationExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockApplyOperationResults{err}
	return e.mock
}

// Times sets number of times Storage.ApplyOperation should be invoked
func (mmApplyOperation *mStorageMockApplyOperation) Times(n uint64) *mStorageMockApplyOperation {
	if n == 0 {
		mmApplyOperation.mock.t.Fatalf("Times of StorageMock.ApplyOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmApplyOperation.expectedInvocations, n)
	mmApplyOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmApplyOperation
}

func (mmApplyOperation *mStorageMockApplyOperation) invocationsDone() bool {
	if len(mmApplyOperation.expectations) == 0 && mmApplyOperation.defaultExpectation == nil && mmApplyOperation.mock.funcApplyOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmApplyOperation.mock.afterApplyOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmApplyOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ApplyOperation implements mm_metricsstorage.Storage
func (mmApplyOperation *StorageMock) ApplyOperation(op operation.MetricOperation, commonLabels map[string]string) (err error) {
	mm_atomic.AddUint64(&mmApplyOperation.beforeApplyOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyOperation.afterApplyOperationCounter, 1)

	mmApplyOperation.t.Helper()

	if mmApplyOperation.inspectFuncApplyOperation != nil {
		mmApplyOperation.inspectFuncApplyOperation(op, commonLabels)
	}

	mm_params := StorageMockApplyOperationParams{op, commonLabels}

	// Record call args
	mmApplyOperation.ApplyOperationMock.mutex.Lock()
	mmApplyOperation.ApplyOperationMock.callArgs = append(mmApplyOperation.ApplyOperationMock.callArgs, &mm_params)
	mmApplyOperation.ApplyOperationMock.mutex.Unlock()

	for _, e := range mmApplyOperation.ApplyOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmApplyOperation.ApplyOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyOperation.ApplyOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyOperation.ApplyOperationMock.defaultExpectation.params
		mm_want_ptrs := mmApplyOperation.ApplyOperationMock.defaultExpectation.paramPtrs

		mm_got := StorageMockApplyOperationParams{op, commonLabels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.op != nil && !minimock.Equal(*mm_want_ptrs.op, mm_got.op) {
				mmApplyOperation.t.Errorf("StorageMock.ApplyOperation got unexpected parameter op, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.originOp, *mm_want_ptrs.op, mm_got.op, minimock.Diff(*mm_want_ptrs.op, mm_got.op))
			}

			if mm_want_ptrs.commonLabels != nil && !minimock.Equal(*mm_want_ptrs.commonLabels, mm_got.commonLabels) {
				mmApplyOperation.t.Errorf("StorageMock.ApplyOperation got unexpected parameter commonLabels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.originCommonLabels, *mm_want_ptrs.commonLabels, mm_got.commonLabels, minimock.Diff(*mm_want_ptrs.commonLabels, mm_got.commonLabels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyOperation.t.Errorf("StorageMock.ApplyOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmApplyOperation.ApplyOperationMock.defaultExpectation.results
		if mm_results == nil {
			mmApplyOperation.t.Fatal("No results are set for the StorageMock.ApplyOperation")
		}
		return (*mm_results).err
	}
	if mmApplyOperation.funcApplyOperation != nil {
		return mmApplyOperation.funcApplyOperation(op, commonLabels)
	}
	mmApplyOperation.t.Fatalf("Unexpected call to StorageMock.ApplyOperation. %v %v", op, commonLabels)
	return
}

// ApplyOperationAfterCounter returns a count of finished StorageMock.ApplyOperation invocations
func (mmApplyOperation *StorageMock) ApplyOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOperation.afterApplyOperationCounter)
}

// ApplyOperationBeforeCounter returns a count of StorageMock.ApplyOperation invocations
func (mmApplyOperation *StorageMock) ApplyOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOperation.beforeApplyOperationCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ApplyOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyOperation *mStorageMockApplyOperation) Calls() []*StorageMockApplyOperationParams {
	mmApplyOperation.mutex.RLock()

	argCopy := make([]*StorageMockApplyOperationParams, len(mmApplyOperation.callArgs))
	copy(argCopy, mmApplyOperation.callArgs)

	mmApplyOperation.mutex.RUnlock()

	return argCopy
}

// MinimockApplyOperationDone returns true if the count of the ApplyOperation invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockApplyOperationDone() bool {
	if m.ApplyOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ApplyOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ApplyOperationMock.invocationsDone()
}

// MinimockApplyOperationInspect logs each unmet expectation
func (m *StorageMock) MinimockApplyOperationInspect() {
	for _, e := range m.ApplyOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterApplyOperationCounter := mm_atomic.LoadUint64(&m.afterApplyOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyOperationMock.defaultExpectation != nil && afterApplyOperationCounter < 1 {
		if m.ApplyOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s", m.ApplyOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s with params: %#v", m.ApplyOperationMock.defaultExpectation.expectationOrigins.origin, *m.ApplyOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyOperation != nil && afterApplyOperationCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s", m.funcApplyOperationOrigin)
	}

	if !m.ApplyOperationMock.invocationsDone() && afterApplyOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ApplyOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ApplyOperationMock.expectedInvocations), m.ApplyOperationMock.expectedInvocationsOrigin, afterApplyOperationCounter)
	}
}

type mStorageMockCollector struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCollectorExpectation
	expectations       []*StorageMockCollectorExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCollectorExpectation specifies expectation struct of the Storage.Collector
type StorageMockCollectorExpectation struct {
	mock *StorageMock

	results      *StorageMockCollectorResults
	returnOrigin string
	Counter      uint64
}

// StorageMockCollectorResults contains results of the Storage.Collector
type StorageMockCollectorResults struct {
	c1 prometheus.Collector
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCollector *mStorageMockCollector) Optional() *mStorageMockCollector {
	mmCollector.optional = true
	return mmCollector
}

// Expect sets up expected params for Storage.Collector
func (mmCollector *mStorageMockCollector) Expect() *mStorageMockCollector {
	if mmCollector.mock.funcCollector != nil {
		mmCollector.mock.t.Fatalf("StorageMock.Collector mock is already set by Set")
	}

	if mmCollector.defaultExpectation == nil {
		mmCollector.defaultExpectation = &StorageMockCollectorExpectation{}
	}

	return mmCollector
}

// Inspect accepts an inspector function that has same arguments as the Storage.Collector
func (mmCollector *mStorageMockCollector) Inspect(f func()) *mStorageMockCollector {
	if mmCollector.mock.inspectFuncCollector != nil {
		mmCollector.mock.t.Fatalf("Inspect function is already set for StorageMock.Collector")
	}

	mmCollector.mock.inspectFuncCollector = f

	return mmCollector
}

// Return sets up results that will be returned by Storage.Collector
func (mmCollector *mStorageMockCollector) Return(c1 prometheus.Collector) *StorageMock {
	if mmCollector.mock.funcCollector != nil {
		mmCollector.mock.t.Fatalf("StorageMock.Collector mock is already set by Set")
	}

	if mmCollector.defaultExpectation == nil {
		mmCollector.defaultExpectation = &StorageMockCollectorExpectation{mock: mmCollector.mock}
	}
	mmCollector.defaultExpectation.results = &StorageMockCollectorResults{c1}
	mmCollector.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCollector.mock
}

// Set uses given function f to mock the Storage.Collector method
func (mmCollector *mStorageMockCollector) Set(f func() (c1 prometheus.Collector)) *StorageMock {
	if mmCollector.defaultExpectation != nil {
		mmCollector.mock.t.Fatalf("Default expectation is already set for the Storage.Collector method")
	}

	if len(mmCollector.expectations) > 0 {
		mmCollector.mock.t.Fatalf("Some expectations are already set for the Storage.Collector method")
	}

	mmCollector.mock.funcCollector = f
	mmCollector.mock.funcCollectorOrigin = minimock.CallerInfo(1)
	return mmCollector.mock
}

// Times sets number of times Storage.Collector should be invoked
func (mmCollector *mStorageMockCollector) Times(n uint64) *mStorageMockCollector {
	if n == 0 {
		mmCollector.mock.t.Fatalf("Times of StorageMock.Collector mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCollector.expectedInvocations, n)
	mmCollector.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCollector
}

func (mmCollector *mStorageMockCollector) invocationsDone() bool {
	if len(mmCollector.expectations) == 0 && mmCollector.defaultExpectation == nil && mmCollector.mock.funcCollector == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCollector.mock.afterCollectorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCollector.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Collector implements mm_metricsstorage.Storage
func (mmCollector *StorageMock) Collector() (c1 prometheus.Collector) {
	mm_atomic.AddUint64(&mmCollector.beforeCollectorCounter, 1)
	defer mm_atomic.AddUint64(&mmCollector.afterCollectorCounter, 1)

	mmCollector.t.Helper()

	if mmCollector.inspectFuncCollector != nil {
		mmCollector.inspectFuncCollector()
	}

	if mmCollector.CollectorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCollector.CollectorMock.defaultExpectation.Counter, 1)

		mm_results := mmCollector.CollectorMock.defaultExpectation.results
		if mm_results == nil {
			mmCollector.t.Fatal("No results are set for the StorageMock.Collector")
		}
		return (*mm_results).c1
	}
	if mmCollector.funcCollector != nil {
		return mmCollector.funcCollector()
	}
	mmCollector.t.Fatalf("Unexpected call to StorageMock.Collector.")
	return
}

// CollectorAfterCounter returns a count of finished StorageMock.Collector invocations
func (mmCollector *StorageMock) CollectorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollector.afterCollectorCounter)
}

// CollectorBeforeCounter returns a count of StorageMock.Collector invocations
func (mmCollector *StorageMock) CollectorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCollector.beforeCollectorCounter)
}

// MinimockCollectorDone returns true if the count of the Collector invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCollectorDone() bool {
	if m.CollectorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CollectorMock.invocationsDone()
}

// MinimockCollectorInspect logs each unmet expectation
func (m *StorageMock) MinimockCollectorInspect() {
	for _, e := range m.CollectorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.Collector")
		}
	}

	afterCollectorCounter := mm_atomic.LoadUint64(&m.afterCollectorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CollectorMock.defaultExpectation != nil && afterCollectorCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Collector at\n%s", m.CollectorMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCollector != nil && afterCollectorCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Collector at\n%s", m.funcCollectorOrigin)
	}

	if !m.CollectorMock.invocationsDone() && afterCollectorCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Collector at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CollectorMock.expectedInvocations), m.CollectorMock.expectedInvocationsOrigin, afterCollectorCounter)
	}
}

type mStorageMockCounter struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCounterExpectation
	expectations       []*StorageMockCounterExpectation

	callArgs []*StorageMockCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCounterExpectation specifies expectation struct of the Storage.Counter
type StorageMockCounterExpectation struct {
	mock               *StorageMock
	params             *StorageMockCounterParams
	paramPtrs          *StorageMockCounterParamPtrs
	expectationOrigins StorageMockCounterExpectationOrigins
	results            *StorageMockCounterResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCounterParams contains parameters of the Storage.Counter
type StorageMockCounterParams struct {
	metric string
	labels map[string]string
}

// StorageMockCounterParamPtrs contains pointers to parameters of the Storage.Counter
type StorageMockCounterParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockCounterResults contains results of the Storage.Counter
type StorageMockCounterResults struct {
	cp1 *collectors.ConstCounterCollector
}

// StorageMockCounterOrigins contains origins of expectations of the Storage.Counter
type StorageMockCounterExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounter *mStorageMockCounter) Optional() *mStorageMockCounter {
	mmCounter.optional = true
	return mmCounter
}

// Expect sets up expected params for Storage.Counter
func (mmCounter *mStorageMockCounter) Expect(metric string, labels map[string]string) *mStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.paramPtrs != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by ExpectParams functions")
	}

	mmCounter.defaultExpectation.params = &StorageMockCounterParams{metric, labels}
	mmCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounter.expectations {
		if minimock.Equal(e.params, mmCounter.defaultExpectation.params) {
			mmCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounter.defaultExpectation.params)
		}
	}

	return mmCounter
}

// ExpectMetricParam1 sets up expected param metric for Storage.Counter
func (mmCounter *mStorageMockCounter) ExpectMetricParam1(metric string) *mStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.params != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Expect")
	}

	if mmCounter.defaultExpectation.paramPtrs == nil {
		mmCounter.defaultExpectation.paramPtrs = &StorageMockCounterParamPtrs{}
	}
	mmCounter.defaultExpectation.paramPtrs.metric = &metric
	mmCounter.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmCounter
}

// ExpectLabelsParam2 sets up expected param labels for Storage.Counter
func (mmCounter *mStorageMockCounter) ExpectLabelsParam2(labels map[string]string) *mStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.params != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Expect")
	}

	if mmCounter.defaultExpectation.paramPtrs == nil {
		mmCounter.defaultExpectation.paramPtrs = &StorageMockCounterParamPtrs{}
	}
	mmCounter.defaultExpectation.paramPtrs.labels = &labels
	mmCounter.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounter
}

// Inspect accepts an inspector function that has same arguments as the Storage.Counter
func (mmCounter *mStorageMockCounter) Inspect(f func(metric string, labels map[string]string)) *mStorageMockCounter {
	if mmCounter.mock.inspectFuncCounter != nil {
		mmCounter.mock.t.Fatalf("Inspect function is already set for StorageMock.Counter")
	}

	mmCounter.mock.inspectFuncCounter = f

	return mmCounter
}

// Return sets up results that will be returned by Storage.Counter
func (mmCounter *mStorageMockCounter) Return(cp1 *collectors.ConstCounterCollector) *StorageMock {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{mock: mmCounter.mock}
	}
	mmCounter.defaultExpectation.results = &StorageMockCounterResults{cp1}
	mmCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounter.mock
}

// Set uses given function f to mock the Storage.Counter method
func (mmCounter *mStorageMockCounter) Set(f func(metric string, labels map[string]string) (cp1 *collectors.ConstCounterCollector)) *StorageMock {
	if mmCounter.defaultExpectation != nil {
		mmCounter.mock.t.Fatalf("Default expectation is already set for the Storage.Counter method")
	}

	if len(mmCounter.expectations) > 0 {
		mmCounter.mock.t.Fatalf("Some expectations are already set for the Storage.Counter method")
	}

	mmCounter.mock.funcCounter = f
	mmCounter.mock.funcCounterOrigin = minimock.CallerInfo(1)
	return mmCounter.mock
}

// When sets expectation for the Storage.Counter which will trigger the result defined by the following
// Then helper
func (mmCounter *mStorageMockCounter) When(metric string, labels map[string]string) *StorageMockCounterExpectation {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	expectation := &StorageMockCounterExpectation{
		mock:               mmCounter.mock,
		params:             &StorageMockCounterParams{metric, labels},
		expectationOrigins: StorageMockCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCounter.expectations = append(mmCounter.expectations, expectation)
	return expectation
}

// Then sets up Storage.Counter return parameters for the expectation previously defined by the When method
func (e *StorageMockCounterExpectation) Then(cp1 *collectors.ConstCounterCollector) *StorageMock {
	e.results = &StorageMockCounterResults{cp1}
	return e.mock
}

// Times sets number of times Storage.Counter should be invoked
func (mmCounter *mStorageMockCounter) Times(n uint64) *mStorageMockCounter {
	if n == 0 {
		mmCounter.mock.t.Fatalf("Times of StorageMock.Counter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounter.expectedInvocations, n)
	mmCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounter
}

func (mmCounter *mStorageMockCounter) invocationsDone() bool {
	if len(mmCounter.expectations) == 0 && mmCounter.defaultExpectation == nil && mmCounter.mock.funcCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounter.mock.afterCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Counter implements mm_metricsstorage.Storage
func (mmCounter *StorageMock) Counter(metric string, labels map[string]string) (cp1 *collectors.ConstCounterCollector) {
	mm_atomic.AddUint64(&mmCounter.beforeCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmCounter.afterCounterCounter, 1)

	mmCounter.t.Helper()

	if mmCounter.inspectFuncCounter != nil {
		mmCounter.inspectFuncCounter(metric, labels)
	}

	mm_params := StorageMockCounterParams{metric, labels}

	// Record call args
	mmCounter.CounterMock.mutex.Lock()
	mmCounter.CounterMock.callArgs = append(mmCounter.CounterMock.callArgs, &mm_params)
	mmCounter.CounterMock.mutex.Unlock()

	for _, e := range mmCounter.CounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1
		}
	}

	if mmCounter.CounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounter.CounterMock.defaultExpectation.Counter, 1)
		mm_want := mmCounter.CounterMock.defaultExpectation.params
		mm_want_ptrs := mmCounter.CounterMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCounterParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmCounter.t.Errorf("StorageMock.Counter got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounter.CounterMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounter.t.Errorf("StorageMock.Counter got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounter.CounterMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounter.t.Errorf("StorageMock.Counter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounter.CounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCounter.CounterMock.defaultExpectation.results
		if mm_results == nil {
			mmCounter.t.Fatal("No results are set for the StorageMock.Counter")
		}
		return (*mm_results).cp1
	}
	if mmCounter.funcCounter != nil {
		return mmCounter.funcCounter(metric, labels)
	}
	mmCounter.t.Fatalf("Unexpected call to StorageMock.Counter. %v %v", metric, labels)
	return
}

// CounterAfterCounter returns a count of finished StorageMock.Counter invocations
func (mmCounter *StorageMock) CounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounter.afterCounterCounter)
}

// CounterBeforeCounter returns a count of StorageMock.Counter invocations
func (mmCounter *StorageMock) CounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounter.beforeCounterCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Counter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounter *mStorageMockCounter) Calls() []*StorageMockCounterParams {
	mmCounter.mutex.RLock()

	argCopy := make([]*StorageMockCounterParams, len(mmCounter.callArgs))
	copy(argCopy, mmCounter.callArgs)

	mmCounter.mutex.RUnlock()

	return argCopy
}

// MinimockCounterDone returns true if the count of the Counter invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCounterDone() bool {
	if m.CounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterMock.invocationsDone()
}

// MinimockCounterInspect logs each unmet expectation
func (m *StorageMock) MinimockCounterInspect() {
	for _, e := range m.CounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Counter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterCounter := mm_atomic.LoadUint64(&m.afterCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterMock.defaultExpectation != nil && afterCounterCounter < 1 {
		if m.CounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.Counter at\n%s", m.CounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.Counter at\n%s with params: %#v", m.CounterMock.defaultExpectation.expectationOrigins.origin, *m.CounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounter != nil && afterCounterCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Counter at\n%s", m.funcCounterOrigin)
	}

	if !m.CounterMock.invocationsDone() && afterCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Counter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterMock.expectedInvocations), m.CounterMock.expectedInvocationsOrigin, afterCounterCounter)
	}
}

type mStorageMockCounterAdd struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCounterAddExpectation
	expectations       []*StorageMockCounterAddExpectation

	callArgs []*StorageMockCounterAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCounterAddExpectation specifies expectation struct of the Storage.CounterAdd
type StorageMockCounterAddExpectation struct {
	mock               *StorageMock
	params             *StorageMockCounterAddParams
	paramPtrs          *StorageMockCounterAddParamPtrs
	expectationOrigins StorageMockCounterAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockCounterAddParams contains parameters of the Storage.CounterAdd
type StorageMockCounterAddParams struct {
	metric string
	value  float64
	labels map[string]string
}

// StorageMockCounterAddParamPtrs contains pointers to parameters of the Storage.CounterAdd
type StorageMockCounterAddParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// StorageMockCounterAddOrigins contains origins of expectations of the Storage.CounterAdd
type StorageMockCounterAddExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounterAdd *mStorageMockCounterAdd) Optional() *mStorageMockCounterAdd {
	mmCounterAdd.optional = true
	return mmCounterAdd
}

// Expect sets up expected params for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) Expect(metric string, value float64, labels map[string]string) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.paramPtrs != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by ExpectParams functions")
	}

	mmCounterAdd.defaultExpectation.params = &StorageMockCounterAddParams{metric, value, labels}
	mmCounterAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounterAdd.expectations {
		if minimock.Equal(e.params, mmCounterAdd.defaultExpectation.params) {
			mmCounterAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounterAdd.defaultExpectation.params)
		}
	}

	return mmCounterAdd
}

// ExpectMetricParam1 sets up expected param metric for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) ExpectMetricParam1(metric string) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &StorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.metric = &metric
	mmCounterAdd.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectValueParam2 sets up expected param value for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) ExpectValueParam2(value float64) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &StorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.value = &value
	mmCounterAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectLabelsParam3 sets up expected param labels for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) ExpectLabelsParam3(labels map[string]string) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &StorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.labels = &labels
	mmCounterAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounterAdd
}

// Inspect accepts an inspector function that has same arguments as the Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) Inspect(f func(metric string, value float64, labels map[string]string)) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.inspectFuncCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("Inspect function is already set for StorageMock.CounterAdd")
	}

	mmCounterAdd.mock.inspectFuncCounterAdd = f

	return mmCounterAdd
}

// Return sets up results that will be returned by Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) Return() *StorageMock {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{mock: mmCounterAdd.mock}
	}

	mmCounterAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// Set uses given function f to mock the Storage.CounterAdd method
func (mmCounterAdd *mStorageMockCounterAdd) Set(f func(metric string, value float64, labels map[string]string)) *StorageMock {
	if mmCounterAdd.defaultExpectation != nil {
		mmCounterAdd.mock.t.Fatalf("Default expectation is already set for the Storage.CounterAdd method")
	}

	if len(mmCounterAdd.expectations) > 0 {
		mmCounterAdd.mock.t.Fatalf("Some expectations are already set for the Storage.CounterAdd method")
	}

	mmCounterAdd.mock.funcCounterAdd = f
	mmCounterAdd.mock.funcCounterAddOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// When sets expectation for the Storage.CounterAdd which will trigger the result defined by the following
// Then helper
func (mmCounterAdd *mStorageMockCounterAdd) When(metric string, value float64, labels map[string]string) *StorageMockCounterAddExpectation {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	expectation := &StorageMockCounterAddExpectation{
		mock:               mmCounterAdd.mock,
		params:             &StorageMockCounterAddParams{metric, value, labels},
		expectationOrigins: StorageMockCounterAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCounterAdd.expectations = append(mmCounterAdd.expectations, expectation)
	return expectation
}

// Then sets up Storage.CounterAdd return parameters for the expectation previously defined by the When method

func (e *StorageMockCounterAddExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.CounterAdd should be invoked
func (mmCounterAdd *mStorageMockCounterAdd) Times(n uint64) *mStorageMockCounterAdd {
	if n == 0 {
		mmCounterAdd.mock.t.Fatalf("Times of StorageMock.CounterAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounterAdd.expectedInvocations, n)
	mmCounterAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounterAdd
}

func (mmCounterAdd *mStorageMockCounterAdd) invocationsDone() bool {
	if len(mmCounterAdd.expectations) == 0 && mmCounterAdd.defaultExpectation == nil && mmCounterAdd.mock.funcCounterAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounterAdd.mock.afterCounterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounterAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CounterAdd implements mm_metricsstorage.Storage
func (mmCounterAdd *StorageMock) CounterAdd(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmCounterAdd.beforeCounterAddCounter, 1)
	defer mm_atomic.AddUint64(&mmCounterAdd.afterCounterAddCounter, 1)

	mmCounterAdd.t.Helper()

	if mmCounterAdd.inspectFuncCounterAdd != nil {
		mmCounterAdd.inspectFuncCounterAdd(metric, value, labels)
	}

	mm_params := StorageMockCounterAddParams{metric, value, labels}

	// Record call args
	mmCounterAdd.CounterAddMock.mutex.Lock()
	mmCounterAdd.CounterAddMock.callArgs = append(mmCounterAdd.CounterAddMock.callArgs, &mm_params)
	mmCounterAdd.CounterAddMock.mutex.Unlock()

	for _, e := range mmCounterAdd.CounterAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCounterAdd.CounterAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounterAdd.CounterAddMock.defaultExpectation.Counter, 1)
		mm_want := mmCounterAdd.CounterAddMock.defaultExpectation.params
		mm_want_ptrs := mmCounterAdd.CounterAddMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCounterAddParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCounterAdd.funcCounterAdd != nil {
		mmCounterAdd.funcCounterAdd(metric, value, labels)
		return
	}
	mmCounterAdd.t.Fatalf("Unexpected call to StorageMock.CounterAdd. %v %v %v", metric, value, labels)

}

// CounterAddAfterCounter returns a count of finished StorageMock.CounterAdd invocations
func (mmCounterAdd *StorageMock) CounterAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.afterCounterAddCounter)
}

// CounterAddBeforeCounter returns a count of StorageMock.CounterAdd invocations
func (mmCounterAdd *StorageMock) CounterAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.beforeCounterAddCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CounterAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounterAdd *mStorageMockCounterAdd) Calls() []*StorageMockCounterAddParams {
	mmCounterAdd.mutex.RLock()

	argCopy := make([]*StorageMockCounterAddParams, len(mmCounterAdd.callArgs))
	copy(argCopy, mmCounterAdd.callArgs)

	mmCounterAdd.mutex.RUnlock()

	return argCopy
}

// MinimockCounterAddDone returns true if the count of the CounterAdd invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCounterAddDone() bool {
	if m.CounterAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterAddMock.invocationsDone()
}

// MinimockCounterAddInspect logs each unmet expectation
func (m *StorageMock) MinimockCounterAddInspect() {
	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterAddCounter := mm_atomic.LoadUint64(&m.afterCounterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterAddMock.defaultExpectation != nil && afterCounterAddCounter < 1 {
		if m.CounterAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s", m.CounterAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s with params: %#v", m.CounterAddMock.defaultExpectation.expectationOrigins.origin, *m.CounterAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounterAdd != nil && afterCounterAddCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s", m.funcCounterAddOrigin)
	}

	if !m.CounterAddMock.invocationsDone() && afterCounterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CounterAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterAddMock.expectedInvocations), m.CounterAddMock.expectedInvocationsOrigin, afterCounterAddCounter)
	}
}

type mStorageMockGauge struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGaugeExpectation
	expectations       []*StorageMockGaugeExpectation

	callArgs []*StorageMockGaugeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGaugeExpectation specifies expectation struct of the Storage.Gauge
type StorageMockGaugeExpectation struct {
	mock               *StorageMock
	params             *StorageMockGaugeParams
	paramPtrs          *StorageMockGaugeParamPtrs
	expectationOrigins StorageMockGaugeExpectationOrigins
	results            *StorageMockGaugeResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGaugeParams contains parameters of the Storage.Gauge
type StorageMockGaugeParams struct {
	metric string
	labels map[string]string
}

// StorageMockGaugeParamPtrs contains pointers to parameters of the Storage.Gauge
type StorageMockGaugeParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockGaugeResults contains results of the Storage.Gauge
type StorageMockGaugeResults struct {
	cp1 *collectors.ConstGaugeCollector
}

// StorageMockGaugeOrigins contains origins of expectations of the Storage.Gauge
type StorageMockGaugeExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGauge *mStorageMockGauge) Optional() *mStorageMockGauge {
	mmGauge.optional = true
	return mmGauge
}

// Expect sets up expected params for Storage.Gauge
func (mmGauge *mStorageMockGauge) Expect(metric string, labels map[string]string) *mStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.paramPtrs != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by ExpectParams functions")
	}

	mmGauge.defaultExpectation.params = &StorageMockGaugeParams{metric, labels}
	mmGauge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGauge.expectations {
		if minimock.Equal(e.params, mmGauge.defaultExpectation.params) {
			mmGauge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGauge.defaultExpectation.params)
		}
	}

	return mmGauge
}

// ExpectMetricParam1 sets up expected param metric for Storage.Gauge
func (mmGauge *mStorageMockGauge) ExpectMetricParam1(metric string) *mStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.params != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Expect")
	}

	if mmGauge.defaultExpectation.paramPtrs == nil {
		mmGauge.defaultExpectation.paramPtrs = &StorageMockGaugeParamPtrs{}
	}
	mmGauge.defaultExpectation.paramPtrs.metric = &metric
	mmGauge.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGauge
}

// ExpectLabelsParam2 sets up expected param labels for Storage.Gauge
func (mmGauge *mStorageMockGauge) ExpectLabelsParam2(labels map[string]string) *mStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.params != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Expect")
	}

	if mmGauge.defaultExpectation.paramPtrs == nil {
		mmGauge.defaultExpectation.paramPtrs = &StorageMockGaugeParamPtrs{}
	}
	mmGauge.defaultExpectation.paramPtrs.labels = &labels
	mmGauge.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGauge
}

// Inspect accepts an inspector function that has same arguments as the Storage.Gauge
func (mmGauge *mStorageMockGauge) Inspect(f func(metric string, labels map[string]string)) *mStorageMockGauge {
	if mmGauge.mock.inspectFuncGauge != nil {
		mmGauge.mock.t.Fatalf("Inspect function is already set for StorageMock.Gauge")
	}

	mmGauge.mock.inspectFuncGauge = f

	return mmGauge
}

// Return sets up results that will be returned by Storage.Gauge
func (mmGauge *mStorageMockGauge) Return(cp1 *collectors.ConstGaugeCollector) *StorageMock {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{mock: mmGauge.mock}
	}
	mmGauge.defaultExpectation.results = &StorageMockGaugeResults{cp1}
	mmGauge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGauge.mock
}

// Set uses given function f to mock the Storage.Gauge method
func (mmGauge *mStorageMockGauge) Set(f func(metric string, labels map[string]string) (cp1 *collectors.ConstGaugeCollector)) *StorageMock {
	if mmGauge.defaultExpectation != nil {
		mmGauge.mock.t.Fatalf("Default expectation is already set for the Storage.Gauge method")
	}

	if len(mmGauge.expectations) > 0 {
		mmGauge.mock.t.Fatalf("Some expectations are already set for the Storage.Gauge method")
	}

	mmGauge.mock.funcGauge = f
	mmGauge.mock.funcGaugeOrigin = minimock.CallerInfo(1)
	return mmGauge.mock
}

// When sets expectation for the Storage.Gauge which will trigger the result defined by the following
// Then helper
func (mmGauge *mStorageMockGauge) When(metric string, labels map[string]string) *StorageMockGaugeExpectation {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	expectation := &StorageMockGaugeExpectation{
		mock:               mmGauge.mock,
		params:             &StorageMockGaugeParams{metric, labels},
		expectationOrigins: StorageMockGaugeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGauge.expectations = append(mmGauge.expectations, expectation)
	return expectation
}

// Then sets up Storage.Gauge return parameters for the expectation previously defined by the When method
func (e *StorageMockGaugeExpectation) Then(cp1 *collectors.ConstGaugeCollector) *StorageMock {
	e.results = &StorageMockGaugeResults{cp1}
	return e.mock
}

// Times sets number of times Storage.Gauge should be invoked
func (mmGauge *mStorageMockGauge) Times(n uint64) *mStorageMockGauge {
	if n == 0 {
		mmGauge.mock.t.Fatalf("Times of StorageMock.Gauge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGauge.expectedInvocations, n)
	mmGauge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGauge
}

func (mmGauge *mStorageMockGauge) invocationsDone() bool {
	if len(mmGauge.expectations) == 0 && mmGauge.defaultExpectation == nil && mmGauge.mock.funcGauge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGauge.mock.afterGaugeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGauge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Gauge implements mm_metricsstorage.Storage
func (mmGauge *StorageMock) Gauge(metric string, labels map[string]string) (cp1 *collectors.ConstGaugeCollector) {
	mm_atomic.AddUint64(&mmGauge.beforeGaugeCounter, 1)
	defer mm_atomic.AddUint64(&mmGauge.afterGaugeCounter, 1)

	mmGauge.t.Helper()

	if mmGauge.inspectFuncGauge != nil {
		mmGauge.inspectFuncGauge(metric, labels)
	}

	mm_params := StorageMockGaugeParams{metric, labels}

	// Record call args
	mmGauge.GaugeMock.mutex.Lock()
	mmGauge.GaugeMock.callArgs = append(mmGauge.GaugeMock.callArgs, &mm_params)
	mmGauge.GaugeMock.mutex.Unlock()

	for _, e := range mmGauge.GaugeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1
		}
	}

	if mmGauge.GaugeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGauge.GaugeMock.defaultExpectation.Counter, 1)
		mm_want := mmGauge.GaugeMock.defaultExpectation.params
		mm_want_ptrs := mmGauge.GaugeMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGaugeParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGauge.t.Errorf("StorageMock.Gauge got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGauge.GaugeMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGauge.t.Errorf("StorageMock.Gauge got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGauge.GaugeMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGauge.t.Errorf("StorageMock.Gauge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGauge.GaugeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGauge.GaugeMock.defaultExpectation.results
		if mm_results == nil {
			mmGauge.t.Fatal("No results are set for the StorageMock.Gauge")
		}
		return (*mm_results).cp1
	}
	if mmGauge.funcGauge != nil {
		return mmGauge.funcGauge(metric, labels)
	}
	mmGauge.t.Fatalf("Unexpected call to StorageMock.Gauge. %v %v", metric, labels)
	return
}

// GaugeAfterCounter returns a count of finished StorageMock.Gauge invocations
func (mmGauge *StorageMock) GaugeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGauge.afterGaugeCounter)
}

// GaugeBeforeCounter returns a count of StorageMock.Gauge invocations
func (mmGauge *StorageMock) GaugeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGauge.beforeGaugeCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Gauge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGauge *mStorageMockGauge) Calls() []*StorageMockGaugeParams {
	mmGauge.mutex.RLock()

	argCopy := make([]*StorageMockGaugeParams, len(mmGauge.callArgs))
	copy(argCopy, mmGauge.callArgs)

	mmGauge.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeDone returns true if the count of the Gauge invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGaugeDone() bool {
	if m.GaugeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeMock.invocationsDone()
}

// MinimockGaugeInspect logs each unmet expectation
func (m *StorageMock) MinimockGaugeInspect() {
	for _, e := range m.GaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Gauge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeCounter := mm_atomic.LoadUint64(&m.afterGaugeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeMock.defaultExpectation != nil && afterGaugeCounter < 1 {
		if m.GaugeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.Gauge at\n%s", m.GaugeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.Gauge at\n%s with params: %#v", m.GaugeMock.defaultExpectation.expectationOrigins.origin, *m.GaugeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGauge != nil && afterGaugeCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Gauge at\n%s", m.funcGaugeOrigin)
	}

	if !m.GaugeMock.invocationsDone() && afterGaugeCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Gauge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeMock.expectedInvocations), m.GaugeMock.expectedInvocationsOrigin, afterGaugeCounter)
	}
}

type mStorageMockGaugeAdd struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGaugeAddExpectation
	expectations       []*StorageMockGaugeAddExpectation

	callArgs []*StorageMockGaugeAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGaugeAddExpectation specifies expectation struct of the Storage.GaugeAdd
type StorageMockGaugeAddExpectation struct {
	mock               *StorageMock
	params             *StorageMockGaugeAddParams
	paramPtrs          *StorageMockGaugeAddParamPtrs
	expectationOrigins StorageMockGaugeAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockGaugeAddParams contains parameters of the Storage.GaugeAdd
type StorageMockGaugeAddParams struct {
	metric string
	value  float64
	labels map[string]string
}

// StorageMockGaugeAddParamPtrs contains pointers to parameters of the Storage.GaugeAdd
type StorageMockGaugeAddParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// StorageMockGaugeAddOrigins contains origins of expectations of the Storage.GaugeAdd
type StorageMockGaugeAddExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeAdd *mStorageMockGaugeAdd) Optional() *mStorageMockGaugeAdd {
	mmGaugeAdd.optional = true
	return mmGaugeAdd
}

// Expect sets up expected params for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) Expect(metric string, value float64, labels map[string]string) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by ExpectParams functions")
	}

	mmGaugeAdd.defaultExpectation.params = &StorageMockGaugeAddParams{metric, value, labels}
	mmGaugeAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeAdd.expectations {
		if minimock.Equal(e.params, mmGaugeAdd.defaultExpectation.params) {
			mmGaugeAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeAdd.defaultExpectation.params)
		}
	}

	return mmGaugeAdd
}

// ExpectMetricParam1 sets up expected param metric for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) ExpectMetricParam1(metric string) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &StorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.metric = &metric
	mmGaugeAdd.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// ExpectValueParam2 sets up expected param value for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) ExpectValueParam2(value float64) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &StorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.value = &value
	mmGaugeAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// ExpectLabelsParam3 sets up expected param labels for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) ExpectLabelsParam3(labels map[string]string) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &StorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// Inspect accepts an inspector function that has same arguments as the Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) Inspect(f func(metric string, value float64, labels map[string]string)) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.inspectFuncGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("Inspect function is already set for StorageMock.GaugeAdd")
	}

	mmGaugeAdd.mock.inspectFuncGaugeAdd = f

	return mmGaugeAdd
}

// Return sets up results that will be returned by Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) Return() *StorageMock {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{mock: mmGaugeAdd.mock}
	}

	mmGaugeAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd.mock
}

// Set uses given function f to mock the Storage.GaugeAdd method
func (mmGaugeAdd *mStorageMockGaugeAdd) Set(f func(metric string, value float64, labels map[string]string)) *StorageMock {
	if mmGaugeAdd.defaultExpectation != nil {
		mmGaugeAdd.mock.t.Fatalf("Default expectation is already set for the Storage.GaugeAdd method")
	}

	if len(mmGaugeAdd.expectations) > 0 {
		mmGaugeAdd.mock.t.Fatalf("Some expectations are already set for the Storage.GaugeAdd method")
	}

	mmGaugeAdd.mock.funcGaugeAdd = f
	mmGaugeAdd.mock.funcGaugeAddOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd.mock
}

// When sets expectation for the Storage.GaugeAdd which will trigger the result defined by the following
// Then helper
func (mmGaugeAdd *mStorageMockGaugeAdd) When(metric string, value float64, labels map[string]string) *StorageMockGaugeAddExpectation {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	expectation := &StorageMockGaugeAddExpectation{
		mock:               mmGaugeAdd.mock,
		params:             &StorageMockGaugeAddParams{metric, value, labels},
		expectationOrigins: StorageMockGaugeAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGaugeAdd.expectations = append(mmGaugeAdd.expectations, expectation)
	return expectation
}

// Then sets up Storage.GaugeAdd return parameters for the expectation previously defined by the When method

func (e *StorageMockGaugeAddExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.GaugeAdd should be invoked
func (mmGaugeAdd *mStorageMockGaugeAdd) Times(n uint64) *mStorageMockGaugeAdd {
	if n == 0 {
		mmGaugeAdd.mock.t.Fatalf("Times of StorageMock.GaugeAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeAdd.expectedInvocations, n)
	mmGaugeAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd
}

func (mmGaugeAdd *mStorageMockGaugeAdd) invocationsDone() bool {
	if len(mmGaugeAdd.expectations) == 0 && mmGaugeAdd.defaultExpectation == nil && mmGaugeAdd.mock.funcGaugeAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeAdd.mock.afterGaugeAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeAdd implements mm_metricsstorage.Storage
func (mmGaugeAdd *StorageMock) GaugeAdd(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeAdd.beforeGaugeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeAdd.afterGaugeAddCounter, 1)

	mmGaugeAdd.t.Helper()

	if mmGaugeAdd.inspectFuncGaugeAdd != nil {
		mmGaugeAdd.inspectFuncGaugeAdd(metric, value, labels)
	}

	mm_params := StorageMockGaugeAddParams{metric, value, labels}

	// Record call args
	mmGaugeAdd.GaugeAddMock.mutex.Lock()
	mmGaugeAdd.GaugeAddMock.callArgs = append(mmGaugeAdd.GaugeAddMock.callArgs, &mm_params)
	mmGaugeAdd.GaugeAddMock.mutex.Unlock()

	for _, e := range mmGaugeAdd.GaugeAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeAdd.GaugeAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeAdd.GaugeAddMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeAdd.GaugeAddMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeAdd.GaugeAddMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGaugeAddParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeAdd.funcGaugeAdd != nil {
		mmGaugeAdd.funcGaugeAdd(metric, value, labels)
		return
	}
	mmGaugeAdd.t.Fatalf("Unexpected call to StorageMock.GaugeAdd. %v %v %v", metric, value, labels)

}

// GaugeAddAfterCounter returns a count of finished StorageMock.GaugeAdd invocations
func (mmGaugeAdd *StorageMock) GaugeAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeAdd.afterGaugeAddCounter)
}

// GaugeAddBeforeCounter returns a count of StorageMock.GaugeAdd invocations
func (mmGaugeAdd *StorageMock) GaugeAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeAdd.beforeGaugeAddCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GaugeAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeAdd *mStorageMockGaugeAdd) Calls() []*StorageMockGaugeAddParams {
	mmGaugeAdd.mutex.RLock()

	argCopy := make([]*StorageMockGaugeAddParams, len(mmGaugeAdd.callArgs))
	copy(argCopy, mmGaugeAdd.callArgs)

	mmGaugeAdd.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeAddDone returns true if the count of the GaugeAdd invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGaugeAddDone() bool {
	if m.GaugeAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeAddMock.invocationsDone()
}

// MinimockGaugeAddInspect logs each unmet expectation
func (m *StorageMock) MinimockGaugeAddInspect() {
	for _, e := range m.GaugeAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeAddCounter := mm_atomic.LoadUint64(&m.afterGaugeAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeAddMock.defaultExpectation != nil && afterGaugeAddCounter < 1 {
		if m.GaugeAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s", m.GaugeAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s with params: %#v", m.GaugeAddMock.defaultExpectation.expectationOrigins.origin, *m.GaugeAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeAdd != nil && afterGaugeAddCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s", m.funcGaugeAddOrigin)
	}

	if !m.GaugeAddMock.invocationsDone() && afterGaugeAddCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GaugeAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeAddMock.expectedInvocations), m.GaugeAddMock.expectedInvocationsOrigin, afterGaugeAddCounter)
	}
}

type mStorageMockGaugeSet struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGaugeSetExpectation
	expectations       []*StorageMockGaugeSetExpectation

	callArgs []*StorageMockGaugeSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGaugeSetExpectation specifies expectation struct of the Storage.GaugeSet
type StorageMockGaugeSetExpectation struct {
	mock               *StorageMock
	params             *StorageMockGaugeSetParams
	paramPtrs          *StorageMockGaugeSetParamPtrs
	expectationOrigins StorageMockGaugeSetExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockGaugeSetParams contains parameters of the Storage.GaugeSet
type StorageMockGaugeSetParams struct {
	metric string
	value  float64
	labels map[string]string
}

// StorageMockGaugeSetParamPtrs contains pointers to parameters of the Storage.GaugeSet
type StorageMockGaugeSetParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// StorageMockGaugeSetOrigins contains origins of expectations of the Storage.GaugeSet
type StorageMockGaugeSetExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeSet *mStorageMockGaugeSet) Optional() *mStorageMockGaugeSet {
	mmGaugeSet.optional = true
	return mmGaugeSet
}

// Expect sets up expected params for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) Expect(metric string, value float64, labels map[string]string) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.paramPtrs != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by ExpectParams functions")
	}

	mmGaugeSet.defaultExpectation.params = &StorageMockGaugeSetParams{metric, value, labels}
	mmGaugeSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeSet.expectations {
		if minimock.Equal(e.params, mmGaugeSet.defaultExpectation.params) {
			mmGaugeSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeSet.defaultExpectation.params)
		}
	}

	return mmGaugeSet
}

// ExpectMetricParam1 sets up expected param metric for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) ExpectMetricParam1(metric string) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &StorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.metric = &metric
	mmGaugeSet.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectValueParam2 sets up expected param value for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) ExpectValueParam2(value float64) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &StorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.value = &value
	mmGaugeSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectLabelsParam3 sets up expected param labels for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) ExpectLabelsParam3(labels map[string]string) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &StorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeSet.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeSet
}

// Inspect accepts an inspector function that has same arguments as the Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) Inspect(f func(metric string, value float64, labels map[string]string)) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.inspectFuncGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("Inspect function is already set for StorageMock.GaugeSet")
	}

	mmGaugeSet.mock.inspectFuncGaugeSet = f

	return mmGaugeSet
}

// Return sets up results that will be returned by Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) Return() *StorageMock {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{mock: mmGaugeSet.mock}
	}

	mmGaugeSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// Set uses given function f to mock the Storage.GaugeSet method
func (mmGaugeSet *mStorageMockGaugeSet) Set(f func(metric string, value float64, labels map[string]string)) *StorageMock {
	if mmGaugeSet.defaultExpectation != nil {
		mmGaugeSet.mock.t.Fatalf("Default expectation is already set for the Storage.GaugeSet method")
	}

	if len(mmGaugeSet.expectations) > 0 {
		mmGaugeSet.mock.t.Fatalf("Some expectations are already set for the Storage.GaugeSet method")
	}

	mmGaugeSet.mock.funcGaugeSet = f
	mmGaugeSet.mock.funcGaugeSetOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// When sets expectation for the Storage.GaugeSet which will trigger the result defined by the following
// Then helper
func (mmGaugeSet *mStorageMockGaugeSet) When(metric string, value float64, labels map[string]string) *StorageMockGaugeSetExpectation {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	expectation := &StorageMockGaugeSetExpectation{
		mock:               mmGaugeSet.mock,
		params:             &StorageMockGaugeSetParams{metric, value, labels},
		expectationOrigins: StorageMockGaugeSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGaugeSet.expectations = append(mmGaugeSet.expectations, expectation)
	return expectation
}

// Then sets up Storage.GaugeSet return parameters for the expectation previously defined by the When method

func (e *StorageMockGaugeSetExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.GaugeSet should be invoked
func (mmGaugeSet *mStorageMockGaugeSet) Times(n uint64) *mStorageMockGaugeSet {
	if n == 0 {
		mmGaugeSet.mock.t.Fatalf("Times of StorageMock.GaugeSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeSet.expectedInvocations, n)
	mmGaugeSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeSet
}

func (mmGaugeSet *mStorageMockGaugeSet) invocationsDone() bool {
	if len(mmGaugeSet.expectations) == 0 && mmGaugeSet.defaultExpectation == nil && mmGaugeSet.mock.funcGaugeSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeSet.mock.afterGaugeSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeSet implements mm_metricsstorage.Storage
func (mmGaugeSet *StorageMock) GaugeSet(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeSet.beforeGaugeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeSet.afterGaugeSetCounter, 1)

	mmGaugeSet.t.Helper()

	if mmGaugeSet.inspectFuncGaugeSet != nil {
		mmGaugeSet.inspectFuncGaugeSet(metric, value, labels)
	}

	mm_params := StorageMockGaugeSetParams{metric, value, labels}

	// Record call args
	mmGaugeSet.GaugeSetMock.mutex.Lock()
	mmGaugeSet.GaugeSetMock.callArgs = append(mmGaugeSet.GaugeSetMock.callArgs, &mm_params)
	mmGaugeSet.GaugeSetMock.mutex.Unlock()

	for _, e := range mmGaugeSet.GaugeSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeSet.GaugeSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeSet.GaugeSetMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeSet.GaugeSetMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeSet.GaugeSetMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGaugeSetParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeSet.funcGaugeSet != nil {
		mmGaugeSet.funcGaugeSet(metric, value, labels)
		return
	}
	mmGaugeSet.t.Fatalf("Unexpected call to StorageMock.GaugeSet. %v %v %v", metric, value, labels)

}

// GaugeSetAfterCounter returns a count of finished StorageMock.GaugeSet invocations
func (mmGaugeSet *StorageMock) GaugeSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.afterGaugeSetCounter)
}

// GaugeSetBeforeCounter returns a count of StorageMock.GaugeSet invocations
func (mmGaugeSet *StorageMock) GaugeSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.beforeGaugeSetCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GaugeSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeSet *mStorageMockGaugeSet) Calls() []*StorageMockGaugeSetParams {
	mmGaugeSet.mutex.RLock()

	argCopy := make([]*StorageMockGaugeSetParams, len(mmGaugeSet.callArgs))
	copy(argCopy, mmGaugeSet.callArgs)

	mmGaugeSet.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeSetDone returns true if the count of the GaugeSet invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGaugeSetDone() bool {
	if m.GaugeSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeSetMock.invocationsDone()
}

// MinimockGaugeSetInspect logs each unmet expectation
func (m *StorageMock) MinimockGaugeSetInspect() {
	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeSetCounter := mm_atomic.LoadUint64(&m.afterGaugeSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeSetMock.defaultExpectation != nil && afterGaugeSetCounter < 1 {
		if m.GaugeSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s", m.GaugeSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s with params: %#v", m.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *m.GaugeSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeSet != nil && afterGaugeSetCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s", m.funcGaugeSetOrigin)
	}

	if !m.GaugeSetMock.invocationsDone() && afterGaugeSetCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GaugeSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeSetMock.expectedInvocations), m.GaugeSetMock.expectedInvocationsOrigin, afterGaugeSetCounter)
	}
}

type mStorageMockGrouped struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGroupedExpectation
	expectations       []*StorageMockGroupedExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGroupedExpectation specifies expectation struct of the Storage.Grouped
type StorageMockGroupedExpectation struct {
	mock *StorageMock

	results      *StorageMockGroupedResults
	returnOrigin string
	Counter      uint64
}

// StorageMockGroupedResults contains results of the Storage.Grouped
type StorageMockGroupedResults struct {
	g1 mm_metricsstorage.GroupedStorage
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGrouped *mStorageMockGrouped) Optional() *mStorageMockGrouped {
	mmGrouped.optional = true
	return mmGrouped
}

// Expect sets up expected params for Storage.Grouped
func (mmGrouped *mStorageMockGrouped) Expect() *mStorageMockGrouped {
	if mmGrouped.mock.funcGrouped != nil {
		mmGrouped.mock.t.Fatalf("StorageMock.Grouped mock is already set by Set")
	}

	if mmGrouped.defaultExpectation == nil {
		mmGrouped.defaultExpectation = &StorageMockGroupedExpectation{}
	}

	return mmGrouped
}

// Inspect accepts an inspector function that has same arguments as the Storage.Grouped
func (mmGrouped *mStorageMockGrouped) Inspect(f func()) *mStorageMockGrouped {
	if mmGrouped.mock.inspectFuncGrouped != nil {
		mmGrouped.mock.t.Fatalf("Inspect function is already set for StorageMock.Grouped")
	}

	mmGrouped.mock.inspectFuncGrouped = f

	return mmGrouped
}

// Return sets up results that will be returned by Storage.Grouped
func (mmGrouped *mStorageMockGrouped) Return(g1 mm_metricsstorage.GroupedStorage) *StorageMock {
	if mmGrouped.mock.funcGrouped != nil {
		mmGrouped.mock.t.Fatalf("StorageMock.Grouped mock is already set by Set")
	}

	if mmGrouped.defaultExpectation == nil {
		mmGrouped.defaultExpectation = &StorageMockGroupedExpectation{mock: mmGrouped.mock}
	}
	mmGrouped.defaultExpectation.results = &StorageMockGroupedResults{g1}
	mmGrouped.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGrouped.mock
}

// Set uses given function f to mock the Storage.Grouped method
func (mmGrouped *mStorageMockGrouped) Set(f func() (g1 mm_metricsstorage.GroupedStorage)) *StorageMock {
	if mmGrouped.defaultExpectation != nil {
		mmGrouped.mock.t.Fatalf("Default expectation is already set for the Storage.Grouped method")
	}

	if len(mmGrouped.expectations) > 0 {
		mmGrouped.mock.t.Fatalf("Some expectations are already set for the Storage.Grouped method")
	}

	mmGrouped.mock.funcGrouped = f
	mmGrouped.mock.funcGroupedOrigin = minimock.CallerInfo(1)
	return mmGrouped.mock
}

// Times sets number of times Storage.Grouped should be invoked
func (mmGrouped *mStorageMockGrouped) Times(n uint64) *mStorageMockGrouped {
	if n == 0 {
		mmGrouped.mock.t.Fatalf("Times of StorageMock.Grouped mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGrouped.expectedInvocations, n)
	mmGrouped.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGrouped
}

func (mmGrouped *mStorageMockGrouped) invocationsDone() bool {
	if len(mmGrouped.expectations) == 0 && mmGrouped.defaultExpectation == nil && mmGrouped.mock.funcGrouped == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGrouped.mock.afterGroupedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGrouped.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Grouped implements mm_metricsstorage.Storage
func (mmGrouped *StorageMock) Grouped() (g1 mm_metricsstorage.GroupedStorage) {
	mm_atomic.AddUint64(&mmGrouped.beforeGroupedCounter, 1)
	defer mm_atomic.AddUint64(&mmGrouped.afterGroupedCounter, 1)

	mmGrouped.t.Helper()

	if mmGrouped.inspectFuncGrouped != nil {
		mmGrouped.inspectFuncGrouped()
	}

	if mmGrouped.GroupedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGrouped.GroupedMock.defaultExpectation.Counter, 1)

		mm_results := mmGrouped.GroupedMock.defaultExpectation.results
		if mm_results == nil {
			mmGrouped.t.Fatal("No results are set for the StorageMock.Grouped")
		}
		return (*mm_results).g1
	}
	if mmGrouped.funcGrouped != nil {
		return mmGrouped.funcGrouped()
	}
	mmGrouped.t.Fatalf("Unexpected call to StorageMock.Grouped.")
	return
}

// GroupedAfterCounter returns a count of finished StorageMock.Grouped invocations
func (mmGrouped *StorageMock) GroupedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrouped.afterGroupedCounter)
}

// GroupedBeforeCounter returns a count of StorageMock.Grouped invocations
func (mmGrouped *StorageMock) GroupedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrouped.beforeGroupedCounter)
}

// MinimockGroupedDone returns true if the count of the Grouped invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGroupedDone() bool {
	if m.GroupedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GroupedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GroupedMock.invocationsDone()
}

// MinimockGroupedInspect logs each unmet expectation
func (m *StorageMock) MinimockGroupedInspect() {
	for _, e := range m.GroupedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.Grouped")
		}
	}

	afterGroupedCounter := mm_atomic.LoadUint64(&m.afterGroupedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GroupedMock.defaultExpectation != nil && afterGroupedCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Grouped at\n%s", m.GroupedMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGrouped != nil && afterGroupedCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Grouped at\n%s", m.funcGroupedOrigin)
	}

	if !m.GroupedMock.invocationsDone() && afterGroupedCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Grouped at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GroupedMock.expectedInvocations), m.GroupedMock.expectedInvocationsOrigin, afterGroupedCounter)
	}
}

type mStorageMockHandler struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockHandlerExpectation
	expectations       []*StorageMockHandlerExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockHandlerExpectation specifies expectation struct of the Storage.Handler
type StorageMockHandlerExpectation struct {
	mock *StorageMock

	results      *StorageMockHandlerResults
	returnOrigin string
	Counter      uint64
}

// StorageMockHandlerResults contains results of the Storage.Handler
type StorageMockHandlerResults struct {
	h1 http.Handler
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHandler *mStorageMockHandler) Optional() *mStorageMockHandler {
	mmHandler.optional = true
	return mmHandler
}

// Expect sets up expected params for Storage.Handler
func (mmHandler *mStorageMockHandler) Expect() *mStorageMockHandler {
	if mmHandler.mock.funcHandler != nil {
		mmHandler.mock.t.Fatalf("StorageMock.Handler mock is already set by Set")
	}

	if mmHandler.defaultExpectation == nil {
		mmHandler.defaultExpectation = &StorageMockHandlerExpectation{}
	}

	return mmHandler
}

// Inspect accepts an inspector function that has same arguments as the Storage.Handler
func (mmHandler *mStorageMockHandler) Inspect(f func()) *mStorageMockHandler {
	if mmHandler.mock.inspectFuncHandler != nil {
		mmHandler.mock.t.Fatalf("Inspect function is already set for StorageMock.Handler")
	}

	mmHandler.mock.inspectFuncHandler = f

	return mmHandler
}

// Return sets up results that will be returned by Storage.Handler
func (mmHandler *mStorageMockHandler) Return(h1 http.Handler) *StorageMock {
	if mmHandler.mock.funcHandler != nil {
		mmHandler.mock.t.Fatalf("StorageMock.Handler mock is already set by Set")
	}

	if mmHandler.defaultExpectation == nil {
		mmHandler.defaultExpectation = &StorageMockHandlerExpectation{mock: mmHandler.mock}
	}
	mmHandler.defaultExpectation.results = &StorageMockHandlerResults{h1}
	mmHandler.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHandler.mock
}

// Set uses given function f to mock the Storage.Handler method
func (mmHandler *mStorageMockHandler) Set(f func() (h1 http.Handler)) *StorageMock {
	if mmHandler.defaultExpectation != nil {
		mmHandler.mock.t.Fatalf("Default expectation is already set for the Storage.Handler method")
	}

	if len(mmHandler.expectations) > 0 {
		mmHandler.mock.t.Fatalf("Some expectations are already set for the Storage.Handler method")
	}

	mmHandler.mock.funcHandler = f
	mmHandler.mock.funcHandlerOrigin = minimock.CallerInfo(1)
	return mmHandler.mock
}

// Times sets number of times Storage.Handler should be invoked
func (mmHandler *mStorageMockHandler) Times(n uint64) *mStorageMockHandler {
	if n == 0 {
		mmHandler.mock.t.Fatalf("Times of StorageMock.Handler mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHandler.expectedInvocations, n)
	mmHandler.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHandler
}

func (mmHandler *mStorageMockHandler) invocationsDone() bool {
	if len(mmHandler.expectations) == 0 && mmHandler.defaultExpectation == nil && mmHandler.mock.funcHandler == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHandler.mock.afterHandlerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHandler.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Handler implements mm_metricsstorage.Storage
func (mmHandler *StorageMock) Handler() (h1 http.Handler) {
	mm_atomic.AddUint64(&mmHandler.beforeHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmHandler.afterHandlerCounter, 1)

	mmHandler.t.Helper()

	if mmHandler.inspectFuncHandler != nil {
		mmHandler.inspectFuncHandler()
	}

	if mmHandler.HandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHandler.HandlerMock.defaultExpectation.Counter, 1)

		mm_results := mmHandler.HandlerMock.defaultExpectation.results
		if mm_results == nil {
			mmHandler.t.Fatal("No results are set for the StorageMock.Handler")
		}
		return (*mm_results).h1
	}
	if mmHandler.funcHandler != nil {
		return mmHandler.funcHandler()
	}
	mmHandler.t.Fatalf("Unexpected call to StorageMock.Handler.")
	return
}

// HandlerAfterCounter returns a count of finished StorageMock.Handler invocations
func (mmHandler *StorageMock) HandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandler.afterHandlerCounter)
}

// HandlerBeforeCounter returns a count of StorageMock.Handler invocations
func (mmHandler *StorageMock) HandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandler.beforeHandlerCounter)
}

// MinimockHandlerDone returns true if the count of the Handler invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockHandlerDone() bool {
	if m.HandlerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HandlerMock.invocationsDone()
}

// MinimockHandlerInspect logs each unmet expectation
func (m *StorageMock) MinimockHandlerInspect() {
	for _, e := range m.HandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.Handler")
		}
	}

	afterHandlerCounter := mm_atomic.LoadUint64(&m.afterHandlerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HandlerMock.defaultExpectation != nil && afterHandlerCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Handler at\n%s", m.HandlerMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHandler != nil && afterHandlerCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Handler at\n%s", m.funcHandlerOrigin)
	}

	if !m.HandlerMock.invocationsDone() && afterHandlerCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Handler at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HandlerMock.expectedInvocations), m.HandlerMock.expectedInvocationsOrigin, afterHandlerCounter)
	}
}

type mStorageMockHistogram struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockHistogramExpectation
	expectations       []*StorageMockHistogramExpectation

	callArgs []*StorageMockHistogramParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockHistogramExpectation specifies expectation struct of the Storage.Histogram
type StorageMockHistogramExpectation struct {
	mock               *StorageMock
	params             *StorageMockHistogramParams
	paramPtrs          *StorageMockHistogramParamPtrs
	expectationOrigins StorageMockHistogramExpectationOrigins
	results            *StorageMockHistogramResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockHistogramParams contains parameters of the Storage.Histogram
type StorageMockHistogramParams struct {
	metric  string
	labels  map[string]string
	buckets []float64
}

// StorageMockHistogramParamPtrs contains pointers to parameters of the Storage.Histogram
type StorageMockHistogramParamPtrs struct {
	metric  *string
	labels  *map[string]string
	buckets *[]float64
}

// StorageMockHistogramResults contains results of the Storage.Histogram
type StorageMockHistogramResults struct {
	cp1 *collectors.ConstHistogramCollector
}

// StorageMockHistogramOrigins contains origins of expectations of the Storage.Histogram
type StorageMockHistogramExpectationOrigins struct {
	origin        string
	originMetric  string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistogram *mStorageMockHistogram) Optional() *mStorageMockHistogram {
	mmHistogram.optional = true
	return mmHistogram
}

// Expect sets up expected params for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) Expect(metric string, labels map[string]string, buckets []float64) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.paramPtrs != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by ExpectParams functions")
	}

	mmHistogram.defaultExpectation.params = &StorageMockHistogramParams{metric, labels, buckets}
	mmHistogram.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistogram.expectations {
		if minimock.Equal(e.params, mmHistogram.defaultExpectation.params) {
			mmHistogram.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistogram.defaultExpectation.params)
		}
	}

	return mmHistogram
}

// ExpectMetricParam1 sets up expected param metric for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) ExpectMetricParam1(metric string) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &StorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.metric = &metric
	mmHistogram.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmHistogram
}

// ExpectLabelsParam2 sets up expected param labels for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) ExpectLabelsParam2(labels map[string]string) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &StorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.labels = &labels
	mmHistogram.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmHistogram
}

// ExpectBucketsParam3 sets up expected param buckets for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) ExpectBucketsParam3(buckets []float64) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &StorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.buckets = &buckets
	mmHistogram.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmHistogram
}

// Inspect accepts an inspector function that has same arguments as the Storage.Histogram
func (mmHistogram *mStorageMockHistogram) Inspect(f func(metric string, labels map[string]string, buckets []float64)) *mStorageMockHistogram {
	if mmHistogram.mock.inspectFuncHistogram != nil {
		mmHistogram.mock.t.Fatalf("Inspect function is already set for StorageMock.Histogram")
	}

	mmHistogram.mock.inspectFuncHistogram = f

	return mmHistogram
}

// Return sets up results that will be returned by Storage.Histogram
func (mmHistogram *mStorageMockHistogram) Return(cp1 *collectors.ConstHistogramCollector) *StorageMock {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{mock: mmHistogram.mock}
	}
	mmHistogram.defaultExpectation.results = &StorageMockHistogramResults{cp1}
	mmHistogram.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistogram.mock
}

// Set uses given function f to mock the Storage.Histogram method
func (mmHistogram *mStorageMockHistogram) Set(f func(metric string, labels map[string]string, buckets []float64) (cp1 *collectors.ConstHistogramCollector)) *StorageMock {
	if mmHistogram.defaultExpectation != nil {
		mmHistogram.mock.t.Fatalf("Default expectation is already set for the Storage.Histogram method")
	}

	if len(mmHistogram.expectations) > 0 {
		mmHistogram.mock.t.Fatalf("Some expectations are already set for the Storage.Histogram method")
	}

	mmHistogram.mock.funcHistogram = f
	mmHistogram.mock.funcHistogramOrigin = minimock.CallerInfo(1)
	return mmHistogram.mock
}

// When sets expectation for the Storage.Histogram which will trigger the result defined by the following
// Then helper
func (mmHistogram *mStorageMockHistogram) When(metric string, labels map[string]string, buckets []float64) *StorageMockHistogramExpectation {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	expectation := &StorageMockHistogramExpectation{
		mock:               mmHistogram.mock,
		params:             &StorageMockHistogramParams{metric, labels, buckets},
		expectationOrigins: StorageMockHistogramExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistogram.expectations = append(mmHistogram.expectations, expectation)
	return expectation
}

// Then sets up Storage.Histogram return parameters for the expectation previously defined by the When method
func (e *StorageMockHistogramExpectation) Then(cp1 *collectors.ConstHistogramCollector) *StorageMock {
	e.results = &StorageMockHistogramResults{cp1}
	return e.mock
}

// Times sets number of times Storage.Histogram should be invoked
func (mmHistogram *mStorageMockHistogram) Times(n uint64) *mStorageMockHistogram {
	if n == 0 {
		mmHistogram.mock.t.Fatalf("Times of StorageMock.Histogram mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistogram.expectedInvocations, n)
	mmHistogram.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistogram
}

func (mmHistogram *mStorageMockHistogram) invocationsDone() bool {
	if len(mmHistogram.expectations) == 0 && mmHistogram.defaultExpectation == nil && mmHistogram.mock.funcHistogram == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistogram.mock.afterHistogramCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistogram.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Histogram implements mm_metricsstorage.Storage
func (mmHistogram *StorageMock) Histogram(metric string, labels map[string]string, buckets []float64) (cp1 *collectors.ConstHistogramCollector) {
	mm_atomic.AddUint64(&mmHistogram.beforeHistogramCounter, 1)
	defer mm_atomic.AddUint64(&mmHistogram.afterHistogramCounter, 1)

	mmHistogram.t.Helper()

	if mmHistogram.inspectFuncHistogram != nil {
		mmHistogram.inspectFuncHistogram(metric, labels, buckets)
	}

	mm_params := StorageMockHistogramParams{metric, labels, buckets}

	// Record call args
	mmHistogram.HistogramMock.mutex.Lock()
	mmHistogram.HistogramMock.callArgs = append(mmHistogram.HistogramMock.callArgs, &mm_params)
	mmHistogram.HistogramMock.mutex.Unlock()

	for _, e := range mmHistogram.HistogramMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1
		}
	}

	if mmHistogram.HistogramMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistogram.HistogramMock.defaultExpectation.Counter, 1)
		mm_want := mmHistogram.HistogramMock.defaultExpectation.params
		mm_want_ptrs := mmHistogram.HistogramMock.defaultExpectation.paramPtrs

		mm_got := StorageMockHistogramParams{metric, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHistogram.HistogramMock.defaultExpectation.results
		if mm_results == nil {
			mmHistogram.t.Fatal("No results are set for the StorageMock.Histogram")
		}
		return (*mm_results).cp1
	}
	if mmHistogram.funcHistogram != nil {
		return mmHistogram.funcHistogram(metric, labels, buckets)
	}
	mmHistogram.t.Fatalf("Unexpected call to StorageMock.Histogram. %v %v %v", metric, labels, buckets)
	return
}

// HistogramAfterCounter returns a count of finished StorageMock.Histogram invocations
func (mmHistogram *StorageMock) HistogramAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogram.afterHistogramCounter)
}

// HistogramBeforeCounter returns a count of StorageMock.Histogram invocations
func (mmHistogram *StorageMock) HistogramBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogram.beforeHistogramCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Histogram.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistogram *mStorageMockHistogram) Calls() []*StorageMockHistogramParams {
	mmHistogram.mutex.RLock()

	argCopy := make([]*StorageMockHistogramParams, len(mmHistogram.callArgs))
	copy(argCopy, mmHistogram.callArgs)

	mmHistogram.mutex.RUnlock()

	return argCopy
}

// MinimockHistogramDone returns true if the count of the Histogram invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockHistogramDone() bool {
	if m.HistogramMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistogramMock.invocationsDone()
}

// MinimockHistogramInspect logs each unmet expectation
func (m *StorageMock) MinimockHistogramInspect() {
	for _, e := range m.HistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Histogram at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistogramCounter := mm_atomic.LoadUint64(&m.afterHistogramCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistogramMock.defaultExpectation != nil && afterHistogramCounter < 1 {
		if m.HistogramMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.Histogram at\n%s", m.HistogramMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.Histogram at\n%s with params: %#v", m.HistogramMock.defaultExpectation.expectationOrigins.origin, *m.HistogramMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistogram != nil && afterHistogramCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Histogram at\n%s", m.funcHistogramOrigin)
	}

	if !m.HistogramMock.invocationsDone() && afterHistogramCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Histogram at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistogramMock.expectedInvocations), m.HistogramMock.expectedInvocationsOrigin, afterHistogramCounter)
	}
}

type mStorageMockHistogramObserve struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockHistogramObserveExpectation
	expectations       []*StorageMockHistogramObserveExpectation

	callArgs []*StorageMockHistogramObserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockHistogramObserveExpectation specifies expectation struct of the Storage.HistogramObserve
type StorageMockHistogramObserveExpectation struct {
	mock               *StorageMock
	params             *StorageMockHistogramObserveParams
	paramPtrs          *StorageMockHistogramObserveParamPtrs
	expectationOrigins StorageMockHistogramObserveExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockHistogramObserveParams contains parameters of the Storage.HistogramObserve
type StorageMockHistogramObserveParams struct {
	metric  string
	value   float64
	labels  map[string]string
	buckets []float64
}

// StorageMockHistogramObserveParamPtrs contains pointers to parameters of the Storage.HistogramObserve
type StorageMockHistogramObserveParamPtrs struct {
	metric  *string
	value   *float64
	labels  *map[string]string
	buckets *[]float64
}

// StorageMockHistogramObserveOrigins contains origins of expectations of the Storage.HistogramObserve
type StorageMockHistogramObserveExpectationOrigins struct {
	origin        string
	originMetric  string
	originValue   string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistogramObserve *mStorageMockHistogramObserve) Optional() *mStorageMockHistogramObserve {
	mmHistogramObserve.optional = true
	return mmHistogramObserve
}

// Expect sets up expected params for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) Expect(metric string, value float64, labels map[string]string, buckets []float64) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by ExpectParams functions")
	}

	mmHistogramObserve.defaultExpectation.params = &StorageMockHistogramObserveParams{metric, value, labels, buckets}
	mmHistogramObserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistogramObserve.expectations {
		if minimock.Equal(e.params, mmHistogramObserve.defaultExpectation.params) {
			mmHistogramObserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistogramObserve.defaultExpectation.params)
		}
	}

	return mmHistogramObserve
}

// ExpectMetricParam1 sets up expected param metric for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectMetricParam1(metric string) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.metric = &metric
	mmHistogramObserve.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectValueParam2 sets up expected param value for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectValueParam2(value float64) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.value = &value
	mmHistogramObserve.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectLabelsParam3 sets up expected param labels for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectLabelsParam3(labels map[string]string) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.labels = &labels
	mmHistogramObserve.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectBucketsParam4 sets up expected param buckets for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectBucketsParam4(buckets []float64) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.buckets = &buckets
	mmHistogramObserve.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// Inspect accepts an inspector function that has same arguments as the Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) Inspect(f func(metric string, value float64, labels map[string]string, buckets []float64)) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.inspectFuncHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("Inspect function is already set for StorageMock.HistogramObserve")
	}

	mmHistogramObserve.mock.inspectFuncHistogramObserve = f

	return mmHistogramObserve
}

// Return sets up results that will be returned by Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) Return() *StorageMock {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{mock: mmHistogramObserve.mock}
	}

	mmHistogramObserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve.mock
}

// Set uses given function f to mock the Storage.HistogramObserve method
func (mmHistogramObserve *mStorageMockHistogramObserve) Set(f func(metric string, value float64, labels map[string]string, buckets []float64)) *StorageMock {
	if mmHistogramObserve.defaultExpectation != nil {
		mmHistogramObserve.mock.t.Fatalf("Default expectation is already set for the Storage.HistogramObserve method")
	}

	if len(mmHistogramObserve.expectations) > 0 {
		mmHistogramObserve.mock.t.Fatalf("Some expectations are already set for the Storage.HistogramObserve method")
	}

	mmHistogramObserve.mock.funcHistogramObserve = f
	mmHistogramObserve.mock.funcHistogramObserveOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve.mock
}

// When sets expectation for the Storage.HistogramObserve which will trigger the result defined by the following
// Then helper
func (mmHistogramObserve *mStorageMockHistogramObserve) When(metric string, value float64, labels map[string]string, buckets []float64) *StorageMockHistogramObserveExpectation {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	expectation := &StorageMockHistogramObserveExpectation{
		mock:               mmHistogramObserve.mock,
		params:             &StorageMockHistogramObserveParams{metric, value, labels, buckets},
		expectationOrigins: StorageMockHistogramObserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistogramObserve.expectations = append(mmHistogramObserve.expectations, expectation)
	return expectation
}

// Then sets up Storage.HistogramObserve return parameters for the expectation previously defined by the When method

func (e *StorageMockHistogramObserveExpectation) Then() *StorageMock {
	return e.mock
}

// Times sets number of times Storage.HistogramObserve should be invoked
func (mmHistogramObserve *mStorageMockHistogramObserve) Times(n uint64) *mStorageMockHistogramObserve {
	if n == 0 {
		mmHistogramObserve.mock.t.Fatalf("Times of StorageMock.HistogramObserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistogramObserve.expectedInvocations, n)
	mmHistogramObserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve
}

func (mmHistogramObserve *mStorageMockHistogramObserve) invocationsDone() bool {
	if len(mmHistogramObserve.expectations) == 0 && mmHistogramObserve.defaultExpectation == nil && mmHistogramObserve.mock.funcHistogramObserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistogramObserve.mock.afterHistogramObserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistogramObserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HistogramObserve implements mm_metricsstorage.Storage
func (mmHistogramObserve *StorageMock) HistogramObserve(metric string, value float64, labels map[string]string, buckets []float64) {
	mm_atomic.AddUint64(&mmHistogramObserve.beforeHistogramObserveCounter, 1)
	defer mm_atomic.AddUint64(&mmHistogramObserve.afterHistogramObserveCounter, 1)

	mmHistogramObserve.t.Helper()

	if mmHistogramObserve.inspectFuncHistogramObserve != nil {
		mmHistogramObserve.inspectFuncHistogramObserve(metric, value, labels, buckets)
	}

	mm_params := StorageMockHistogramObserveParams{metric, value, labels, buckets}

	// Record call args
	mmHistogramObserve.HistogramObserveMock.mutex.Lock()
	mmHistogramObserve.HistogramObserveMock.callArgs = append(mmHistogramObserve.HistogramObserveMock.callArgs, &mm_params)
	mmHistogramObserve.HistogramObserveMock.mutex.Unlock()

	for _, e := range mmHistogramObserve.HistogramObserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmHistogramObserve.HistogramObserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistogramObserve.HistogramObserveMock.defaultExpectation.Counter, 1)
		mm_want := mmHistogramObserve.HistogramObserveMock.defaultExpectation.params
		mm_want_ptrs := mmHistogramObserve.HistogramObserveMock.defaultExpectation.paramPtrs

		mm_got := StorageMockHistogramObserveParams{metric, value, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmHistogramObserve.funcHistogramObserve != nil {
		mmHistogramObserve.funcHistogramObserve(metric, value, labels, buckets)
		return
	}
	mmHistogramObserve.t.Fatalf("Unexpected call to StorageMock.HistogramObserve. %v %v %v %v", metric, value, labels, buckets)

}

// HistogramObserveAfterCounter returns a count of finished StorageMock.HistogramObserve invocations
func (mmHistogramObserve *StorageMock) HistogramObserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogramObserve.afterHistogramObserveCounter)
}

// HistogramObserveBeforeCounter returns a count of StorageMock.HistogramObserve invocations
func (mmHistogramObserve *StorageMock) HistogramObserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogramObserve.beforeHistogramObserveCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.HistogramObserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistogramObserve *mStorageMockHistogramObserve) Calls() []*StorageMockHistogramObserveParams {
	mmHistogramObserve.mutex.RLock()

	argCopy := make([]*StorageMockHistogramObserveParams, len(mmHistogramObserve.callArgs))
	copy(argCopy, mmHistogramObserve.callArgs)

	mmHistogramObserve.mutex.RUnlock()

	return argCopy
}

// MinimockHistogramObserveDone returns true if the count of the HistogramObserve invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockHistogramObserveDone() bool {
	if m.HistogramObserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistogramObserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistogramObserveMock.invocationsDone()
}

// MinimockHistogramObserveInspect logs each unmet expectation
func (m *StorageMock) MinimockHistogramObserveInspect() {
	for _, e := range m.HistogramObserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistogramObserveCounter := mm_atomic.LoadUint64(&m.afterHistogramObserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistogramObserveMock.defaultExpectation != nil && afterHistogramObserveCounter < 1 {
		if m.HistogramObserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s", m.HistogramObserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s with params: %#v", m.HistogramObserveMock.defaultExpectation.expectationOrigins.origin, *m.HistogramObserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistogramObserve != nil && afterHistogramObserveCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s", m.funcHistogramObserveOrigin)
	}

	if !m.HistogramObserveMock.invocationsDone() && afterHistogramObserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.HistogramObserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistogramObserveMock.expectedInvocations), m.HistogramObserveMock.expectedInvocationsOrigin, afterHistogramObserveCounter)
	}
}

type mStorageMockRegisterCounter struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRegisterCounterExpectation
	expectations       []*StorageMockRegisterCounterExpectation

	callArgs []*StorageMockRegisterCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRegisterCounterExpectation specifies expectation struct of the Storage.RegisterCounter
type StorageMockRegisterCounterExpectation struct {
	mock               *StorageMock
	params             *StorageMockRegisterCounterParams
	paramPtrs          *StorageMockRegisterCounterParamPtrs
	expectationOrigins StorageMockRegisterCounterExpectationOrigins
	results            *StorageMockRegisterCounterResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRegisterCounterParams contains parameters of the Storage.RegisterCounter
type StorageMockRegisterCounterParams struct {
	metric     string
	labelNames []string
	opts       []options.RegisterOption
}

// StorageMockRegisterCounterParamPtrs contains pointers to parameters of the Storage.RegisterCounter
type StorageMockRegisterCounterParamPtrs struct {
	metric     *string
	labelNames *[]string
	opts       *[]options.RegisterOption
}

// StorageMockRegisterCounterResults contains results of the Storage.RegisterCounter
type StorageMockRegisterCounterResults struct {
	cp1 *collectors.ConstCounterCollector
	err error
}

// StorageMockRegisterCounterOrigins contains origins of expectations of the Storage.RegisterCounter
type StorageMockRegisterCounterExpectationOrigins struct {
	origin           string
	originMetric     string
	originLabelNames string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterCounter *mStorageMockRegisterCounter) Optional() *mStorageMockRegisterCounter {
	mmRegisterCounter.optional = true
	return mmRegisterCounter
}

// Expect sets up expected params for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) Expect(metric string, labelNames []string, opts ...options.RegisterOption) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by ExpectParams functions")
	}

	mmRegisterCounter.defaultExpectation.params = &StorageMockRegisterCounterParams{metric, labelNames, opts}
	mmRegisterCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterCounter.expectations {
		if minimock.Equal(e.params, mmRegisterCounter.defaultExpectation.params) {
			mmRegisterCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterCounter.defaultExpectation.params)
		}
	}

	return mmRegisterCounter
}

// ExpectMetricParam1 sets up expected param metric for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) ExpectMetricParam1(metric string) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.params != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Expect")
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs == nil {
		mmRegisterCounter.defaultExpectation.paramPtrs = &StorageMockRegisterCounterParamPtrs{}
	}
	mmRegisterCounter.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterCounter.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterCounter
}

// ExpectLabelNamesParam2 sets up expected param labelNames for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) ExpectLabelNamesParam2(labelNames []string) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.params != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Expect")
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs == nil {
		mmRegisterCounter.defaultExpectation.paramPtrs = &StorageMockRegisterCounterParamPtrs{}
	}
	mmRegisterCounter.defaultExpectation.paramPtrs.labelNames = &labelNames
	mmRegisterCounter.defaultExpectation.expectationOrigins.originLabelNames = minimock.CallerInfo(1)

	return mmRegisterCounter
}

// ExpectOptsParam3 sets up expected param opts for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) ExpectOptsParam3(opts ...options.RegisterOption) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.params != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Expect")
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs == nil {
		mmRegisterCounter.defaultExpectation.paramPtrs = &StorageMockRegisterCounterParamPtrs{}
	}
	mmRegisterCounter.defaultExpectation.paramPtrs.opts = &opts
	mmRegisterCounter.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmRegisterCounter
}

// Inspect accepts an inspector function that has same arguments as the Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) Inspect(f func(metric string, labelNames []string, opts ...options.RegisterOption)) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.inspectFuncRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("Inspect function is already set for StorageMock.RegisterCounter")
	}

	mmRegisterCounter.mock.inspectFuncRegisterCounter = f

	return mmRegisterCounter
}

// Return sets up results that will be returned by Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) Return(cp1 *collectors.ConstCounterCollector, err error) *StorageMock {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{mock: mmRegisterCounter.mock}
	}
	mmRegisterCounter.defaultExpectation.results = &StorageMockRegisterCounterResults{cp1, err}
	mmRegisterCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter.mock
}

// Set uses given function f to mock the Storage.RegisterCounter method
func (mmRegisterCounter *mStorageMockRegisterCounter) Set(f func(metric string, labelNames []string, opts ...options.RegisterOption) (cp1 *collectors.ConstCounterCollector, err error)) *StorageMock {
	if mmRegisterCounter.defaultExpectation != nil {
		mmRegisterCounter.mock.t.Fatalf("Default expectation is already set for the Storage.RegisterCounter method")
	}

	if len(mmRegisterCounter.expectations) > 0 {
		mmRegisterCounter.mock.t.Fatalf("Some expectations are already set for the Storage.RegisterCounter method")
	}

	mmRegisterCounter.mock.funcRegisterCounter = f
	mmRegisterCounter.mock.funcRegisterCounterOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter.mock
}

// When sets expectation for the Storage.RegisterCounter which will trigger the result defined by the following
// Then helper
func (mmRegisterCounter *mStorageMockRegisterCounter) When(metric string, labelNames []string, opts ...options.RegisterOption) *StorageMockRegisterCounterExpectation {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	expectation := &StorageMockRegisterCounterExpectation{
		mock:               mmRegisterCounter.mock,
		params:             &StorageMockRegisterCounterParams{metric, labelNames, opts},
		expectationOrigins: StorageMockRegisterCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterCounter.expectations = append(mmRegisterCounter.expectations, expectation)
	return expectation
}

// Then sets up Storage.RegisterCounter return parameters for the expectation previously defined by the When method
func (e *StorageMockRegisterCounterExpectation) Then(cp1 *collectors.ConstCounterCollector, err error) *StorageMock {
	e.results = &StorageMockRegisterCounterResults{cp1, err}
	return e.mock
}

// Times sets number of times Storage.RegisterCounter should be invoked
func (mmRegisterCounter *mStorageMockRegisterCounter) Times(n uint64) *mStorageMockRegisterCounter {
	if n == 0 {
		mmRegisterCounter.mock.t.Fatalf("Times of StorageMock.RegisterCounter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterCounter.expectedInvocations, n)
	mmRegisterCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter
}

func (mmRegisterCounter *mStorageMockRegisterCounter) invocationsDone() bool {
	if len(mmRegisterCounter.expectations) == 0 && mmRegisterCounter.defaultExpectation == nil && mmRegisterCounter.mock.funcRegisterCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterCounter.mock.afterRegisterCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterCounter implements mm_metricsstorage.Storage
func (mmRegisterCounter *StorageMock) RegisterCounter(metric string, labelNames []string, opts ...options.RegisterOption) (cp1 *collectors.ConstCounterCollector, err error) {
	mm_atomic.AddUint64(&mmRegisterCounter.beforeRegisterCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterCounter.afterRegisterCounterCounter, 1)

	mmRegisterCounter.t.Helper()

	if mmRegisterCounter.inspectFuncRegisterCounter != nil {
		mmRegisterCounter.inspectFuncRegisterCounter(metric, labelNames, opts...)
	}

	mm_params := StorageMockRegisterCounterParams{metric, labelNames, opts}

	// Record call args
	mmRegisterCounter.RegisterCounterMock.mutex.Lock()
	mmRegisterCounter.RegisterCounterMock.callArgs = append(mmRegisterCounter.RegisterCounterMock.callArgs, &mm_params)
	mmRegisterCounter.RegisterCounterMock.mutex.Unlock()

	for _, e := range mmRegisterCounter.RegisterCounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmRegisterCounter.RegisterCounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterCounter.RegisterCounterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterCounter.RegisterCounterMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterCounter.RegisterCounterMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRegisterCounterParams{metric, labelNames, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labelNames != nil && !minimock.Equal(*mm_want_ptrs.labelNames, mm_got.labelNames) {
				mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameter labelNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.originLabelNames, *mm_want_ptrs.labelNames, mm_got.labelNames, minimock.Diff(*mm_want_ptrs.labelNames, mm_got.labelNames))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterCounter.RegisterCounterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterCounter.t.Fatal("No results are set for the StorageMock.RegisterCounter")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmRegisterCounter.funcRegisterCounter != nil {
		return mmRegisterCounter.funcRegisterCounter(metric, labelNames, opts...)
	}
	mmRegisterCounter.t.Fatalf("Unexpected call to StorageMock.RegisterCounter. %v %v %v", metric, labelNames, opts)
	return
}

// RegisterCounterAfterCounter returns a count of finished StorageMock.RegisterCounter invocations
func (mmRegisterCounter *StorageMock) RegisterCounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCounter.afterRegisterCounterCounter)
}

// RegisterCounterBeforeCounter returns a count of StorageMock.RegisterCounter invocations
func (mmRegisterCounter *StorageMock) RegisterCounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCounter.beforeRegisterCounterCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RegisterCounter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterCounter *mStorageMockRegisterCounter) Calls() []*StorageMockRegisterCounterParams {
	mmRegisterCounter.mutex.RLock()

	argCopy := make([]*StorageMockRegisterCounterParams, len(mmRegisterCounter.callArgs))
	copy(argCopy, mmRegisterCounter.callArgs)

	mmRegisterCounter.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterCounterDone returns true if the count of the RegisterCounter invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRegisterCounterDone() bool {
	if m.RegisterCounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterCounterMock.invocationsDone()
}

// MinimockRegisterCounterInspect logs each unmet expectation
func (m *StorageMock) MinimockRegisterCounterInspect() {
	for _, e := range m.RegisterCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterCounterCounter := mm_atomic.LoadUint64(&m.afterRegisterCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterCounterMock.defaultExpectation != nil && afterRegisterCounterCounter < 1 {
		if m.RegisterCounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s", m.RegisterCounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s with params: %#v", m.RegisterCounterMock.defaultExpectation.expectationOrigins.origin, *m.RegisterCounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterCounter != nil && afterRegisterCounterCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s", m.funcRegisterCounterOrigin)
	}

	if !m.RegisterCounterMock.invocationsDone() && afterRegisterCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RegisterCounter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterCounterMock.expectedInvocations), m.RegisterCounterMock.expectedInvocationsOrigin, afterRegisterCounterCounter)
	}
}

type mStorageMockRegisterGauge struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRegisterGaugeExpectation
	expectations       []*StorageMockRegisterGaugeExpectation

	callArgs []*StorageMockRegisterGaugeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRegisterGaugeExpectation specifies expectation struct of the Storage.RegisterGauge
type StorageMockRegisterGaugeExpectation struct {
	mock               *StorageMock
	params             *StorageMockRegisterGaugeParams
	paramPtrs          *StorageMockRegisterGaugeParamPtrs
	expectationOrigins StorageMockRegisterGaugeExpectationOrigins
	results            *StorageMockRegisterGaugeResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRegisterGaugeParams contains parameters of the Storage.RegisterGauge
type StorageMockRegisterGaugeParams struct {
	metric     string
	labelNames []string
	opts       []options.RegisterOption
}

// StorageMockRegisterGaugeParamPtrs contains pointers to parameters of the Storage.RegisterGauge
type StorageMockRegisterGaugeParamPtrs struct {
	metric     *string
	labelNames *[]string
	opts       *[]options.RegisterOption
}

// StorageMockRegisterGaugeResults contains results of the Storage.RegisterGauge
type StorageMockRegisterGaugeResults struct {
	cp1 *collectors.ConstGaugeCollector
	err error
}

// StorageMockRegisterGaugeOrigins contains origins of expectations of the Storage.RegisterGauge
type StorageMockRegisterGaugeExpectationOrigins struct {
	origin           string
	originMetric     string
	originLabelNames string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterGauge *mStorageMockRegisterGauge) Optional() *mStorageMockRegisterGauge {
	mmRegisterGauge.optional = true
	return mmRegisterGauge
}

// Expect sets up expected params for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) Expect(metric string, labelNames []string, opts ...options.RegisterOption) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by ExpectParams functions")
	}

	mmRegisterGauge.defaultExpectation.params = &StorageMockRegisterGaugeParams{metric, labelNames, opts}
	mmRegisterGauge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterGauge.expectations {
		if minimock.Equal(e.params, mmRegisterGauge.defaultExpectation.params) {
			mmRegisterGauge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterGauge.defaultExpectation.params)
		}
	}

	return mmRegisterGauge
}

// ExpectMetricParam1 sets up expected param metric for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) ExpectMetricParam1(metric string) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.params != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Expect")
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs == nil {
		mmRegisterGauge.defaultExpectation.paramPtrs = &StorageMockRegisterGaugeParamPtrs{}
	}
	mmRegisterGauge.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterGauge.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterGauge
}

// ExpectLabelNamesParam2 sets up expected param labelNames for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) ExpectLabelNamesParam2(labelNames []string) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.params != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Expect")
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs == nil {
		mmRegisterGauge.defaultExpectation.paramPtrs = &StorageMockRegisterGaugeParamPtrs{}
	}
	mmRegisterGauge.defaultExpectation.paramPtrs.labelNames = &labelNames
	mmRegisterGauge.defaultExpectation.expectationOrigins.originLabelNames = minimock.CallerInfo(1)

	return mmRegisterGauge
}

// ExpectOptsParam3 sets up expected param opts for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) ExpectOptsParam3(opts ...options.RegisterOption) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.params != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Expect")
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs == nil {
		mmRegisterGauge.defaultExpectation.paramPtrs = &StorageMockRegisterGaugeParamPtrs{}
	}
	mmRegisterGauge.defaultExpectation.paramPtrs.opts = &opts
	mmRegisterGauge.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmRegisterGauge
}

// Inspect accepts an inspector function that has same arguments as the Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) Inspect(f func(metric string, labelNames []string, opts ...options.RegisterOption)) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.inspectFuncRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("Inspect function is already set for StorageMock.RegisterGauge")
	}

	mmRegisterGauge.mock.inspectFuncRegisterGauge = f

	return mmRegisterGauge
}

// Return sets up results that will be returned by Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) Return(cp1 *collectors.ConstGaugeCollector, err error) *StorageMock {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{mock: mmRegisterGauge.mock}
	}
	mmRegisterGauge.defaultExpectation.results = &StorageMockRegisterGaugeResults{cp1, err}
	mmRegisterGauge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge.mock
}

// Set uses given function f to mock the Storage.RegisterGauge method
func (mmRegisterGauge *mStorageMockRegisterGauge) Set(f func(metric string, labelNames []string, opts ...options.RegisterOption) (cp1 *collectors.ConstGaugeCollector, err error)) *StorageMock {
	if mmRegisterGauge.defaultExpectation != nil {
		mmRegisterGauge.mock.t.Fatalf("Default expectation is already set for the Storage.RegisterGauge method")
	}

	if len(mmRegisterGauge.expectations) > 0 {
		mmRegisterGauge.mock.t.Fatalf("Some expectations are already set for the Storage.RegisterGauge method")
	}

	mmRegisterGauge.mock.funcRegisterGauge = f
	mmRegisterGauge.mock.funcRegisterGaugeOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge.mock
}

// When sets expectation for the Storage.RegisterGauge which will trigger the result defined by the following
// Then helper
func (mmRegisterGauge *mStorageMockRegisterGauge) When(metric string, labelNames []string, opts ...options.RegisterOption) *StorageMockRegisterGaugeExpectation {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	expectation := &StorageMockRegisterGaugeExpectation{
		mock:               mmRegisterGauge.mock,
		params:             &StorageMockRegisterGaugeParams{metric, labelNames, opts},
		expectationOrigins: StorageMockRegisterGaugeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterGauge.expectations = append(mmRegisterGauge.expectations, expectation)
	return expectation
}

// Then sets up Storage.RegisterGauge return parameters for the expectation previously defined by the When method
func (e *StorageMockRegisterGaugeExpectation) Then(cp1 *collectors.ConstGaugeCollector, err error) *StorageMock {
	e.results = &StorageMockRegisterGaugeResults{cp1, err}
	return e.mock
}

// Times sets number of times Storage.RegisterGauge should be invoked
func (mmRegisterGauge *mStorageMockRegisterGauge) Times(n uint64) *mStorageMockRegisterGauge {
	if n == 0 {
		mmRegisterGauge.mock.t.Fatalf("Times of StorageMock.RegisterGauge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterGauge.expectedInvocations, n)
	mmRegisterGauge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge
}

func (mmRegisterGauge *mStorageMockRegisterGauge) invocationsDone() bool {
	if len(mmRegisterGauge.expectations) == 0 && mmRegisterGauge.defaultExpectation == nil && mmRegisterGauge.mock.funcRegisterGauge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterGauge.mock.afterRegisterGaugeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterGauge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterGauge implements mm_metricsstorage.Storage
func (mmRegisterGauge *StorageMock) RegisterGauge(metric string, labelNames []string, opts ...options.RegisterOption) (cp1 *collectors.ConstGaugeCollector, err error) {
	mm_atomic.AddUint64(&mmRegisterGauge.beforeRegisterGaugeCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterGauge.afterRegisterGaugeCounter, 1)

	mmRegisterGauge.t.Helper()

	if mmRegisterGauge.inspectFuncRegisterGauge != nil {
		mmRegisterGauge.inspectFuncRegisterGauge(metric, labelNames, opts...)
	}

	mm_params := StorageMockRegisterGaugeParams{metric, labelNames, opts}

	// Record call args
	mmRegisterGauge.RegisterGaugeMock.mutex.Lock()
	mmRegisterGauge.RegisterGaugeMock.callArgs = append(mmRegisterGauge.RegisterGaugeMock.callArgs, &mm_params)
	mmRegisterGauge.RegisterGaugeMock.mutex.Unlock()

	for _, e := range mmRegisterGauge.RegisterGaugeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmRegisterGauge.RegisterGaugeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterGauge.RegisterGaugeMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRegisterGaugeParams{metric, labelNames, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labelNames != nil && !minimock.Equal(*mm_want_ptrs.labelNames, mm_got.labelNames) {
				mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameter labelNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.originLabelNames, *mm_want_ptrs.labelNames, mm_got.labelNames, minimock.Diff(*mm_want_ptrs.labelNames, mm_got.labelNames))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterGauge.t.Fatal("No results are set for the StorageMock.RegisterGauge")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmRegisterGauge.funcRegisterGauge != nil {
		return mmRegisterGauge.funcRegisterGauge(metric, labelNames, opts...)
	}
	mmRegisterGauge.t.Fatalf("Unexpected call to StorageMock.RegisterGauge. %v %v %v", metric, labelNames, opts)
	return
}

// RegisterGaugeAfterCounter returns a count of finished StorageMock.RegisterGauge invocations
func (mmRegisterGauge *StorageMock) RegisterGaugeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterGauge.afterRegisterGaugeCounter)
}

// RegisterGaugeBeforeCounter returns a count of StorageMock.RegisterGauge invocations
func (mmRegisterGauge *StorageMock) RegisterGaugeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterGauge.beforeRegisterGaugeCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RegisterGauge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterGauge *mStorageMockRegisterGauge) Calls() []*StorageMockRegisterGaugeParams {
	mmRegisterGauge.mutex.RLock()

	argCopy := make([]*StorageMockRegisterGaugeParams, len(mmRegisterGauge.callArgs))
	copy(argCopy, mmRegisterGauge.callArgs)

	mmRegisterGauge.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterGaugeDone returns true if the count of the RegisterGauge invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRegisterGaugeDone() bool {
	if m.RegisterGaugeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterGaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterGaugeMock.invocationsDone()
}

// MinimockRegisterGaugeInspect logs each unmet expectation
func (m *StorageMock) MinimockRegisterGaugeInspect() {
	for _, e := range m.RegisterGaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterGaugeCounter := mm_atomic.LoadUint64(&m.afterRegisterGaugeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterGaugeMock.defaultExpectation != nil && afterRegisterGaugeCounter < 1 {
		if m.RegisterGaugeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s", m.RegisterGaugeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s with params: %#v", m.RegisterGaugeMock.defaultExpectation.expectationOrigins.origin, *m.RegisterGaugeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterGauge != nil && afterRegisterGaugeCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s", m.funcRegisterGaugeOrigin)
	}

	if !m.RegisterGaugeMock.invocationsDone() && afterRegisterGaugeCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RegisterGauge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterGaugeMock.expectedInvocations), m.RegisterGaugeMock.expectedInvocationsOrigin, afterRegisterGaugeCounter)
	}
}

type mStorageMockRegisterHistogram struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRegisterHistogramExpectation
	expectations       []*StorageMockRegisterHistogramExpectation

	callArgs []*StorageMockRegisterHistogramParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRegisterHistogramExpectation specifies expectation struct of the Storage.RegisterHistogram
type StorageMockRegisterHistogramExpectation struct {
	mock               *StorageMock
	params             *StorageMockRegisterHistogramParams
	paramPtrs          *StorageMockRegisterHistogramParamPtrs
	expectationOrigins StorageMockRegisterHistogramExpectationOrigins
	results            *StorageMockRegisterHistogramResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRegisterHistogramParams contains parameters of the Storage.RegisterHistogram
type StorageMockRegisterHistogramParams struct {
	metric     string
	labelNames []string
	buckets    []float64
	opts       []options.RegisterOption
}

// StorageMockRegisterHistogramParamPtrs contains pointers to parameters of the Storage.RegisterHistogram
type StorageMockRegisterHistogramParamPtrs struct {
	metric     *string
	labelNames *[]string
	buckets    *[]float64
	opts       *[]options.RegisterOption
}

// StorageMockRegisterHistogramResults contains results of the Storage.RegisterHistogram
type StorageMockRegisterHistogramResults struct {
	cp1 *collectors.ConstHistogramCollector
	err error
}

// StorageMockRegisterHistogramOrigins contains origins of expectations of the Storage.RegisterHistogram
type StorageMockRegisterHistogramExpectationOrigins struct {
	origin           string
	originMetric     string
	originLabelNames string
	originBuckets    string
	originOpts       string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Optional() *mStorageMockRegisterHistogram {
	mmRegisterHistogram.optional = true
	return mmRegisterHistogram
}

// Expect sets up expected params for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Expect(metric string, labelNames []string, buckets []float64, opts ...options.RegisterOption) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by ExpectParams functions")
	}

	mmRegisterHistogram.defaultExpectation.params = &StorageMockRegisterHistogramParams{metric, labelNames, buckets, opts}
	mmRegisterHistogram.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterHistogram.expectations {
		if minimock.Equal(e.params, mmRegisterHistogram.defaultExpectation.params) {
			mmRegisterHistogram.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterHistogram.defaultExpectation.params)
		}
	}

	return mmRegisterHistogram
}

// ExpectMetricParam1 sets up expected param metric for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectMetricParam1(metric string) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// ExpectLabelNamesParam2 sets up expected param labelNames for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectLabelNamesParam2(labelNames []string) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.labelNames = &labelNames
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originLabelNames = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// ExpectBucketsParam3 sets up expected param buckets for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectBucketsParam3(buckets []float64) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.buckets = &buckets
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// ExpectOptsParam4 sets up expected param opts for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectOptsParam4(opts ...options.RegisterOption) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.opts = &opts
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originOpts = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// Inspect accepts an inspector function that has same arguments as the Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Inspect(f func(metric string, labelNames []string, buckets []float64, opts ...options.RegisterOption)) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.inspectFuncRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("Inspect function is already set for StorageMock.RegisterHistogram")
	}

	mmRegisterHistogram.mock.inspectFuncRegisterHistogram = f

	return mmRegisterHistogram
}

// Return sets up results that will be returned by Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Return(cp1 *collectors.ConstHistogramCollector, err error) *StorageMock {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{mock: mmRegisterHistogram.mock}
	}
	mmRegisterHistogram.defaultExpectation.results = &StorageMockRegisterHistogramResults{cp1, err}
	mmRegisterHistogram.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram.mock
}

// Set uses given function f to mock the Storage.RegisterHistogram method
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Set(f func(metric string, labelNames []string, buckets []float64, opts ...options.RegisterOption) (cp1 *collectors.ConstHistogramCollector, err error)) *StorageMock {
	if mmRegisterHistogram.defaultExpectation != nil {
		mmRegisterHistogram.mock.t.Fatalf("Default expectation is already set for the Storage.RegisterHistogram method")
	}

	if len(mmRegisterHistogram.expectations) > 0 {
		mmRegisterHistogram.mock.t.Fatalf("Some expectations are already set for the Storage.RegisterHistogram method")
	}

	mmRegisterHistogram.mock.funcRegisterHistogram = f
	mmRegisterHistogram.mock.funcRegisterHistogramOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram.mock
}

// When sets expectation for the Storage.RegisterHistogram which will trigger the result defined by the following
// Then helper
func (mmRegisterHistogram *mStorageMockRegisterHistogram) When(metric string, labelNames []string, buckets []float64, opts ...options.RegisterOption) *StorageMockRegisterHistogramExpectation {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	expectation := &StorageMockRegisterHistogramExpectation{
		mock:               mmRegisterHistogram.mock,
		params:             &StorageMockRegisterHistogramParams{metric, labelNames, buckets, opts},
		expectationOrigins: StorageMockRegisterHistogramExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterHistogram.expectations = append(mmRegisterHistogram.expectations, expectation)
	return expectation
}

// Then sets up Storage.RegisterHistogram return parameters for the expectation previously defined by the When method
func (e *StorageMockRegisterHistogramExpectation) Then(cp1 *collectors.ConstHistogramCollector, err error) *StorageMock {
	e.results = &StorageMockRegisterHistogramResults{cp1, err}
	return e.mock
}

// Times sets number of times Storage.RegisterHistogram should be invoked
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Times(n uint64) *mStorageMockRegisterHistogram {
	if n == 0 {
		mmRegisterHistogram.mock.t.Fatalf("Times of StorageMock.RegisterHistogram mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterHistogram.expectedInvocations, n)
	mmRegisterHistogram.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram
}

func (mmRegisterHistogram *mStorageMockRegisterHistogram) invocationsDone() bool {
	if len(mmRegisterHistogram.expectations) == 0 && mmRegisterHistogram.defaultExpectation == nil && mmRegisterHistogram.mock.funcRegisterHistogram == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterHistogram.mock.afterRegisterHistogramCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterHistogram.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterHistogram implements mm_metricsstorage.Storage
func (mmRegisterHistogram *StorageMock) RegisterHistogram(metric string, labelNames []string, buckets []float64, opts ...options.RegisterOption) (cp1 *collectors.ConstHistogramCollector, err error) {
	mm_atomic.AddUint64(&mmRegisterHistogram.beforeRegisterHistogramCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterHistogram.afterRegisterHistogramCounter, 1)

	mmRegisterHistogram.t.Helper()

	if mmRegisterHistogram.inspectFuncRegisterHistogram != nil {
		mmRegisterHistogram.inspectFuncRegisterHistogram(metric, labelNames, buckets, opts...)
	}

	mm_params := StorageMockRegisterHistogramParams{metric, labelNames, buckets, opts}

	// Record call args
	mmRegisterHistogram.RegisterHistogramMock.mutex.Lock()
	mmRegisterHistogram.RegisterHistogramMock.callArgs = append(mmRegisterHistogram.RegisterHistogramMock.callArgs, &mm_params)
	mmRegisterHistogram.RegisterHistogramMock.mutex.Unlock()

	for _, e := range mmRegisterHistogram.RegisterHistogramMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmRegisterHistogram.RegisterHistogramMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRegisterHistogramParams{metric, labelNames, buckets, opts}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labelNames != nil && !minimock.Equal(*mm_want_ptrs.labelNames, mm_got.labelNames) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter labelNames, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originLabelNames, *mm_want_ptrs.labelNames, mm_got.labelNames, minimock.Diff(*mm_want_ptrs.labelNames, mm_got.labelNames))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

			if mm_want_ptrs.opts != nil && !minimock.Equal(*mm_want_ptrs.opts, mm_got.opts) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter opts, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originOpts, *mm_want_ptrs.opts, mm_got.opts, minimock.Diff(*mm_want_ptrs.opts, mm_got.opts))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterHistogram.t.Fatal("No results are set for the StorageMock.RegisterHistogram")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmRegisterHistogram.funcRegisterHistogram != nil {
		return mmRegisterHistogram.funcRegisterHistogram(metric, labelNames, buckets, opts...)
	}
	mmRegisterHistogram.t.Fatalf("Unexpected call to StorageMock.RegisterHistogram. %v %v %v %v", metric, labelNames, buckets, opts)
	return
}

// RegisterHistogramAfterCounter returns a count of finished StorageMock.RegisterHistogram invocations
func (mmRegisterHistogram *StorageMock) RegisterHistogramAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterHistogram.afterRegisterHistogramCounter)
}

// RegisterHistogramBeforeCounter returns a count of StorageMock.RegisterHistogram invocations
func (mmRegisterHistogram *StorageMock) RegisterHistogramBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterHistogram.beforeRegisterHistogramCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RegisterHistogram.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Calls() []*StorageMockRegisterHistogramParams {
	mmRegisterHistogram.mutex.RLock()

	argCopy := make([]*StorageMockRegisterHistogramParams, len(mmRegisterHistogram.callArgs))
	copy(argCopy, mmRegisterHistogram.callArgs)

	mmRegisterHistogram.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterHistogramDone returns true if the count of the RegisterHistogram invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRegisterHistogramDone() bool {
	if m.RegisterHistogramMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterHistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterHistogramMock.invocationsDone()
}

// MinimockRegisterHistogramInspect logs each unmet expectation
func (m *StorageMock) MinimockRegisterHistogramInspect() {
	for _, e := range m.RegisterHistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterHistogramCounter := mm_atomic.LoadUint64(&m.afterRegisterHistogramCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterHistogramMock.defaultExpectation != nil && afterRegisterHistogramCounter < 1 {
		if m.RegisterHistogramMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s", m.RegisterHistogramMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s with params: %#v", m.RegisterHistogramMock.defaultExpectation.expectationOrigins.origin, *m.RegisterHistogramMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterHistogram != nil && afterRegisterHistogramCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s", m.funcRegisterHistogramOrigin)
	}

	if !m.RegisterHistogramMock.invocationsDone() && afterRegisterHistogramCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RegisterHistogram at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterHistogramMock.expectedInvocations), m.RegisterHistogramMock.expectedInvocationsOrigin, afterRegisterHistogramCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddCollectorFuncInspect()

			m.MinimockApplyBatchOperationsInspect()

			m.MinimockApplyOperationInspect()

			m.MinimockCollectorInspect()

			m.MinimockCounterInspect()

			m.MinimockCounterAddInspect()

			m.MinimockGaugeInspect()

			m.MinimockGaugeAddInspect()

			m.MinimockGaugeSetInspect()

			m.MinimockGroupedInspect()

			m.MinimockHandlerInspect()

			m.MinimockHistogramInspect()

			m.MinimockHistogramObserveInspect()

			m.MinimockRegisterCounterInspect()

			m.MinimockRegisterGaugeInspect()

			m.MinimockRegisterHistogramInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddCollectorFuncDone() &&
		m.MinimockApplyBatchOperationsDone() &&
		m.MinimockApplyOperationDone() &&
		m.MinimockCollectorDone() &&
		m.MinimockCounterDone() &&
		m.MinimockCounterAddDone() &&
		m.MinimockGaugeDone() &&
		m.MinimockGaugeAddDone() &&
		m.MinimockGaugeSetDone() &&
		m.MinimockGroupedDone() &&
		m.MinimockHandlerDone() &&
		m.MinimockHistogramDone() &&
		m.MinimockHistogramObserveDone() &&
		m.MinimockRegisterCounterDone() &&
		m.MinimockRegisterGaugeDone() &&
		m.MinimockRegisterHistogramDone()
}
