// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package metric

//go:generate minimock -i github.com/flant/shell-operator/pkg/metric.Storage -o storage_mock.go -n StorageMock -p metric

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/flant/shell-operator/pkg/metric-storage/operation"
	"github.com/gojuno/minimock/v3"
	"github.com/prometheus/client_golang/prometheus"
)

// StorageMock implements Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcApplyOperation          func(op operation.MetricOperation, commonLabels map[string]string)
	funcApplyOperationOrigin    string
	inspectFuncApplyOperation   func(op operation.MetricOperation, commonLabels map[string]string)
	afterApplyOperationCounter  uint64
	beforeApplyOperationCounter uint64
	ApplyOperationMock          mStorageMockApplyOperation

	funcCounter          func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)
	funcCounterOrigin    string
	inspectFuncCounter   func(metric string, labels map[string]string)
	afterCounterCounter  uint64
	beforeCounterCounter uint64
	CounterMock          mStorageMockCounter

	funcCounterAdd          func(metric string, value float64, labels map[string]string)
	funcCounterAddOrigin    string
	inspectFuncCounterAdd   func(metric string, value float64, labels map[string]string)
	afterCounterAddCounter  uint64
	beforeCounterAddCounter uint64
	CounterAddMock          mStorageMockCounterAdd

	funcGauge          func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)
	funcGaugeOrigin    string
	inspectFuncGauge   func(metric string, labels map[string]string)
	afterGaugeCounter  uint64
	beforeGaugeCounter uint64
	GaugeMock          mStorageMockGauge

	funcGaugeAdd          func(metric string, value float64, labels map[string]string)
	funcGaugeAddOrigin    string
	inspectFuncGaugeAdd   func(metric string, value float64, labels map[string]string)
	afterGaugeAddCounter  uint64
	beforeGaugeAddCounter uint64
	GaugeAddMock          mStorageMockGaugeAdd

	funcGaugeSet          func(metric string, value float64, labels map[string]string)
	funcGaugeSetOrigin    string
	inspectFuncGaugeSet   func(metric string, value float64, labels map[string]string)
	afterGaugeSetCounter  uint64
	beforeGaugeSetCounter uint64
	GaugeSetMock          mStorageMockGaugeSet

	funcGrouped          func() (g1 GroupedStorage)
	funcGroupedOrigin    string
	inspectFuncGrouped   func()
	afterGroupedCounter  uint64
	beforeGroupedCounter uint64
	GroupedMock          mStorageMockGrouped

	funcHistogram          func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)
	funcHistogramOrigin    string
	inspectFuncHistogram   func(metric string, labels map[string]string, buckets []float64)
	afterHistogramCounter  uint64
	beforeHistogramCounter uint64
	HistogramMock          mStorageMockHistogram

	funcHistogramObserve          func(metric string, value float64, labels map[string]string, buckets []float64)
	funcHistogramObserveOrigin    string
	inspectFuncHistogramObserve   func(metric string, value float64, labels map[string]string, buckets []float64)
	afterHistogramObserveCounter  uint64
	beforeHistogramObserveCounter uint64
	HistogramObserveMock          mStorageMockHistogramObserve

	funcRegisterCounter          func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)
	funcRegisterCounterOrigin    string
	inspectFuncRegisterCounter   func(metric string, labels map[string]string)
	afterRegisterCounterCounter  uint64
	beforeRegisterCounterCounter uint64
	RegisterCounterMock          mStorageMockRegisterCounter

	funcRegisterGauge          func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)
	funcRegisterGaugeOrigin    string
	inspectFuncRegisterGauge   func(metric string, labels map[string]string)
	afterRegisterGaugeCounter  uint64
	beforeRegisterGaugeCounter uint64
	RegisterGaugeMock          mStorageMockRegisterGauge

	funcRegisterHistogram          func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)
	funcRegisterHistogramOrigin    string
	inspectFuncRegisterHistogram   func(metric string, labels map[string]string, buckets []float64)
	afterRegisterHistogramCounter  uint64
	beforeRegisterHistogramCounter uint64
	RegisterHistogramMock          mStorageMockRegisterHistogram

	funcSendBatch          func(ops []operation.MetricOperation, labels map[string]string) (err error)
	funcSendBatchOrigin    string
	inspectFuncSendBatch   func(ops []operation.MetricOperation, labels map[string]string)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mStorageMockSendBatch
}

// NewStorageMock returns a mock for Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ApplyOperationMock = mStorageMockApplyOperation{mock: m}
	m.ApplyOperationMock.callArgs = []*StorageMockApplyOperationParams{}

	m.CounterMock = mStorageMockCounter{mock: m}
	m.CounterMock.callArgs = []*StorageMockCounterParams{}

	m.CounterAddMock = mStorageMockCounterAdd{mock: m}
	m.CounterAddMock.callArgs = []*StorageMockCounterAddParams{}

	m.GaugeMock = mStorageMockGauge{mock: m}
	m.GaugeMock.callArgs = []*StorageMockGaugeParams{}

	m.GaugeAddMock = mStorageMockGaugeAdd{mock: m}
	m.GaugeAddMock.callArgs = []*StorageMockGaugeAddParams{}

	m.GaugeSetMock = mStorageMockGaugeSet{mock: m}
	m.GaugeSetMock.callArgs = []*StorageMockGaugeSetParams{}

	m.GroupedMock = mStorageMockGrouped{mock: m}

	m.HistogramMock = mStorageMockHistogram{mock: m}
	m.HistogramMock.callArgs = []*StorageMockHistogramParams{}

	m.HistogramObserveMock = mStorageMockHistogramObserve{mock: m}
	m.HistogramObserveMock.callArgs = []*StorageMockHistogramObserveParams{}

	m.RegisterCounterMock = mStorageMockRegisterCounter{mock: m}
	m.RegisterCounterMock.callArgs = []*StorageMockRegisterCounterParams{}

	m.RegisterGaugeMock = mStorageMockRegisterGauge{mock: m}
	m.RegisterGaugeMock.callArgs = []*StorageMockRegisterGaugeParams{}

	m.RegisterHistogramMock = mStorageMockRegisterHistogram{mock: m}
	m.RegisterHistogramMock.callArgs = []*StorageMockRegisterHistogramParams{}

	m.SendBatchMock = mStorageMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*StorageMockSendBatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockApplyOperation struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockApplyOperationExpectation
	expectations       []*StorageMockApplyOperationExpectation

	callArgs []*StorageMockApplyOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockApplyOperationExpectation specifies expectation struct of the Storage.ApplyOperation
type StorageMockApplyOperationExpectation struct {
	mock               *StorageMock
	params             *StorageMockApplyOperationParams
	paramPtrs          *StorageMockApplyOperationParamPtrs
	expectationOrigins StorageMockApplyOperationExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockApplyOperationParams contains parameters of the Storage.ApplyOperation
type StorageMockApplyOperationParams struct {
	op           operation.MetricOperation
	commonLabels map[string]string
}

// StorageMockApplyOperationParamPtrs contains pointers to parameters of the Storage.ApplyOperation
type StorageMockApplyOperationParamPtrs struct {
	op           *operation.MetricOperation
	commonLabels *map[string]string
}

// StorageMockApplyOperationOrigins contains origins of expectations of the Storage.ApplyOperation
type StorageMockApplyOperationExpectationOrigins struct {
	origin             string
	originOp           string
	originCommonLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmApplyOperation *mStorageMockApplyOperation) Optional() *mStorageMockApplyOperation {
	mmApplyOperation.optional = true
	return mmApplyOperation
}

// Expect sets up expected params for Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) Expect(op operation.MetricOperation, commonLabels map[string]string) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.paramPtrs != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by ExpectParams functions")
	}

	mmApplyOperation.defaultExpectation.params = &StorageMockApplyOperationParams{op, commonLabels}
	mmApplyOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmApplyOperation.expectations {
		if minimock.Equal(e.params, mmApplyOperation.defaultExpectation.params) {
			mmApplyOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyOperation.defaultExpectation.params)
		}
	}

	return mmApplyOperation
}

// ExpectOpParam1 sets up expected param op for Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) ExpectOpParam1(op operation.MetricOperation) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.params != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Expect")
	}

	if mmApplyOperation.defaultExpectation.paramPtrs == nil {
		mmApplyOperation.defaultExpectation.paramPtrs = &StorageMockApplyOperationParamPtrs{}
	}
	mmApplyOperation.defaultExpectation.paramPtrs.op = &op
	mmApplyOperation.defaultExpectation.expectationOrigins.originOp = minimock.CallerInfo(1)

	return mmApplyOperation
}

// ExpectCommonLabelsParam2 sets up expected param commonLabels for Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) ExpectCommonLabelsParam2(commonLabels map[string]string) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.params != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Expect")
	}

	if mmApplyOperation.defaultExpectation.paramPtrs == nil {
		mmApplyOperation.defaultExpectation.paramPtrs = &StorageMockApplyOperationParamPtrs{}
	}
	mmApplyOperation.defaultExpectation.paramPtrs.commonLabels = &commonLabels
	mmApplyOperation.defaultExpectation.expectationOrigins.originCommonLabels = minimock.CallerInfo(1)

	return mmApplyOperation
}

// Inspect accepts an inspector function that has same arguments as the Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) Inspect(f func(op operation.MetricOperation, commonLabels map[string]string)) *mStorageMockApplyOperation {
	if mmApplyOperation.mock.inspectFuncApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("Inspect function is already set for StorageMock.ApplyOperation")
	}

	mmApplyOperation.mock.inspectFuncApplyOperation = f

	return mmApplyOperation
}

// Return sets up results that will be returned by Storage.ApplyOperation
func (mmApplyOperation *mStorageMockApplyOperation) Return() *StorageMock {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("StorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &StorageMockApplyOperationExpectation{mock: mmApplyOperation.mock}
	}

	mmApplyOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmApplyOperation.mock
}

// Set uses given function f to mock the Storage.ApplyOperation method
func (mmApplyOperation *mStorageMockApplyOperation) Set(f func(op operation.MetricOperation, commonLabels map[string]string)) *StorageMock {
	if mmApplyOperation.defaultExpectation != nil {
		mmApplyOperation.mock.t.Fatalf("Default expectation is already set for the Storage.ApplyOperation method")
	}

	if len(mmApplyOperation.expectations) > 0 {
		mmApplyOperation.mock.t.Fatalf("Some expectations are already set for the Storage.ApplyOperation method")
	}

	mmApplyOperation.mock.funcApplyOperation = f
	mmApplyOperation.mock.funcApplyOperationOrigin = minimock.CallerInfo(1)
	return mmApplyOperation.mock
}

// Times sets number of times Storage.ApplyOperation should be invoked
func (mmApplyOperation *mStorageMockApplyOperation) Times(n uint64) *mStorageMockApplyOperation {
	if n == 0 {
		mmApplyOperation.mock.t.Fatalf("Times of StorageMock.ApplyOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmApplyOperation.expectedInvocations, n)
	mmApplyOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmApplyOperation
}

func (mmApplyOperation *mStorageMockApplyOperation) invocationsDone() bool {
	if len(mmApplyOperation.expectations) == 0 && mmApplyOperation.defaultExpectation == nil && mmApplyOperation.mock.funcApplyOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmApplyOperation.mock.afterApplyOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmApplyOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ApplyOperation implements Storage
func (mmApplyOperation *StorageMock) ApplyOperation(op operation.MetricOperation, commonLabels map[string]string) {
	mm_atomic.AddUint64(&mmApplyOperation.beforeApplyOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyOperation.afterApplyOperationCounter, 1)

	mmApplyOperation.t.Helper()

	if mmApplyOperation.inspectFuncApplyOperation != nil {
		mmApplyOperation.inspectFuncApplyOperation(op, commonLabels)
	}

	mm_params := StorageMockApplyOperationParams{op, commonLabels}

	// Record call args
	mmApplyOperation.ApplyOperationMock.mutex.Lock()
	mmApplyOperation.ApplyOperationMock.callArgs = append(mmApplyOperation.ApplyOperationMock.callArgs, &mm_params)
	mmApplyOperation.ApplyOperationMock.mutex.Unlock()

	for _, e := range mmApplyOperation.ApplyOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmApplyOperation.ApplyOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyOperation.ApplyOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyOperation.ApplyOperationMock.defaultExpectation.params
		mm_want_ptrs := mmApplyOperation.ApplyOperationMock.defaultExpectation.paramPtrs

		mm_got := StorageMockApplyOperationParams{op, commonLabels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.op != nil && !minimock.Equal(*mm_want_ptrs.op, mm_got.op) {
				mmApplyOperation.t.Errorf("StorageMock.ApplyOperation got unexpected parameter op, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.originOp, *mm_want_ptrs.op, mm_got.op, minimock.Diff(*mm_want_ptrs.op, mm_got.op))
			}

			if mm_want_ptrs.commonLabels != nil && !minimock.Equal(*mm_want_ptrs.commonLabels, mm_got.commonLabels) {
				mmApplyOperation.t.Errorf("StorageMock.ApplyOperation got unexpected parameter commonLabels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.originCommonLabels, *mm_want_ptrs.commonLabels, mm_got.commonLabels, minimock.Diff(*mm_want_ptrs.commonLabels, mm_got.commonLabels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyOperation.t.Errorf("StorageMock.ApplyOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmApplyOperation.funcApplyOperation != nil {
		mmApplyOperation.funcApplyOperation(op, commonLabels)
		return
	}
	mmApplyOperation.t.Fatalf("Unexpected call to StorageMock.ApplyOperation. %v %v", op, commonLabels)

}

// ApplyOperationAfterCounter returns a count of finished StorageMock.ApplyOperation invocations
func (mmApplyOperation *StorageMock) ApplyOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOperation.afterApplyOperationCounter)
}

// ApplyOperationBeforeCounter returns a count of StorageMock.ApplyOperation invocations
func (mmApplyOperation *StorageMock) ApplyOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOperation.beforeApplyOperationCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.ApplyOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyOperation *mStorageMockApplyOperation) Calls() []*StorageMockApplyOperationParams {
	mmApplyOperation.mutex.RLock()

	argCopy := make([]*StorageMockApplyOperationParams, len(mmApplyOperation.callArgs))
	copy(argCopy, mmApplyOperation.callArgs)

	mmApplyOperation.mutex.RUnlock()

	return argCopy
}

// MinimockApplyOperationDone returns true if the count of the ApplyOperation invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockApplyOperationDone() bool {
	if m.ApplyOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ApplyOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ApplyOperationMock.invocationsDone()
}

// MinimockApplyOperationInspect logs each unmet expectation
func (m *StorageMock) MinimockApplyOperationInspect() {
	for _, e := range m.ApplyOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterApplyOperationCounter := mm_atomic.LoadUint64(&m.afterApplyOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyOperationMock.defaultExpectation != nil && afterApplyOperationCounter < 1 {
		if m.ApplyOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s", m.ApplyOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s with params: %#v", m.ApplyOperationMock.defaultExpectation.expectationOrigins.origin, *m.ApplyOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyOperation != nil && afterApplyOperationCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.ApplyOperation at\n%s", m.funcApplyOperationOrigin)
	}

	if !m.ApplyOperationMock.invocationsDone() && afterApplyOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.ApplyOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ApplyOperationMock.expectedInvocations), m.ApplyOperationMock.expectedInvocationsOrigin, afterApplyOperationCounter)
	}
}

type mStorageMockCounter struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCounterExpectation
	expectations       []*StorageMockCounterExpectation

	callArgs []*StorageMockCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCounterExpectation specifies expectation struct of the Storage.Counter
type StorageMockCounterExpectation struct {
	mock               *StorageMock
	params             *StorageMockCounterParams
	paramPtrs          *StorageMockCounterParamPtrs
	expectationOrigins StorageMockCounterExpectationOrigins
	results            *StorageMockCounterResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCounterParams contains parameters of the Storage.Counter
type StorageMockCounterParams struct {
	metric string
	labels map[string]string
}

// StorageMockCounterParamPtrs contains pointers to parameters of the Storage.Counter
type StorageMockCounterParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockCounterResults contains results of the Storage.Counter
type StorageMockCounterResults struct {
	cp1 *prometheus.CounterVec
}

// StorageMockCounterOrigins contains origins of expectations of the Storage.Counter
type StorageMockCounterExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounter *mStorageMockCounter) Optional() *mStorageMockCounter {
	mmCounter.optional = true
	return mmCounter
}

// Expect sets up expected params for Storage.Counter
func (mmCounter *mStorageMockCounter) Expect(metric string, labels map[string]string) *mStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.paramPtrs != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by ExpectParams functions")
	}

	mmCounter.defaultExpectation.params = &StorageMockCounterParams{metric, labels}
	mmCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounter.expectations {
		if minimock.Equal(e.params, mmCounter.defaultExpectation.params) {
			mmCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounter.defaultExpectation.params)
		}
	}

	return mmCounter
}

// ExpectMetricParam1 sets up expected param metric for Storage.Counter
func (mmCounter *mStorageMockCounter) ExpectMetricParam1(metric string) *mStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.params != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Expect")
	}

	if mmCounter.defaultExpectation.paramPtrs == nil {
		mmCounter.defaultExpectation.paramPtrs = &StorageMockCounterParamPtrs{}
	}
	mmCounter.defaultExpectation.paramPtrs.metric = &metric
	mmCounter.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmCounter
}

// ExpectLabelsParam2 sets up expected param labels for Storage.Counter
func (mmCounter *mStorageMockCounter) ExpectLabelsParam2(labels map[string]string) *mStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.params != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Expect")
	}

	if mmCounter.defaultExpectation.paramPtrs == nil {
		mmCounter.defaultExpectation.paramPtrs = &StorageMockCounterParamPtrs{}
	}
	mmCounter.defaultExpectation.paramPtrs.labels = &labels
	mmCounter.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounter
}

// Inspect accepts an inspector function that has same arguments as the Storage.Counter
func (mmCounter *mStorageMockCounter) Inspect(f func(metric string, labels map[string]string)) *mStorageMockCounter {
	if mmCounter.mock.inspectFuncCounter != nil {
		mmCounter.mock.t.Fatalf("Inspect function is already set for StorageMock.Counter")
	}

	mmCounter.mock.inspectFuncCounter = f

	return mmCounter
}

// Return sets up results that will be returned by Storage.Counter
func (mmCounter *mStorageMockCounter) Return(cp1 *prometheus.CounterVec) *StorageMock {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &StorageMockCounterExpectation{mock: mmCounter.mock}
	}
	mmCounter.defaultExpectation.results = &StorageMockCounterResults{cp1}
	mmCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounter.mock
}

// Set uses given function f to mock the Storage.Counter method
func (mmCounter *mStorageMockCounter) Set(f func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)) *StorageMock {
	if mmCounter.defaultExpectation != nil {
		mmCounter.mock.t.Fatalf("Default expectation is already set for the Storage.Counter method")
	}

	if len(mmCounter.expectations) > 0 {
		mmCounter.mock.t.Fatalf("Some expectations are already set for the Storage.Counter method")
	}

	mmCounter.mock.funcCounter = f
	mmCounter.mock.funcCounterOrigin = minimock.CallerInfo(1)
	return mmCounter.mock
}

// When sets expectation for the Storage.Counter which will trigger the result defined by the following
// Then helper
func (mmCounter *mStorageMockCounter) When(metric string, labels map[string]string) *StorageMockCounterExpectation {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("StorageMock.Counter mock is already set by Set")
	}

	expectation := &StorageMockCounterExpectation{
		mock:               mmCounter.mock,
		params:             &StorageMockCounterParams{metric, labels},
		expectationOrigins: StorageMockCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCounter.expectations = append(mmCounter.expectations, expectation)
	return expectation
}

// Then sets up Storage.Counter return parameters for the expectation previously defined by the When method
func (e *StorageMockCounterExpectation) Then(cp1 *prometheus.CounterVec) *StorageMock {
	e.results = &StorageMockCounterResults{cp1}
	return e.mock
}

// Times sets number of times Storage.Counter should be invoked
func (mmCounter *mStorageMockCounter) Times(n uint64) *mStorageMockCounter {
	if n == 0 {
		mmCounter.mock.t.Fatalf("Times of StorageMock.Counter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounter.expectedInvocations, n)
	mmCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounter
}

func (mmCounter *mStorageMockCounter) invocationsDone() bool {
	if len(mmCounter.expectations) == 0 && mmCounter.defaultExpectation == nil && mmCounter.mock.funcCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounter.mock.afterCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Counter implements Storage
func (mmCounter *StorageMock) Counter(metric string, labels map[string]string) (cp1 *prometheus.CounterVec) {
	mm_atomic.AddUint64(&mmCounter.beforeCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmCounter.afterCounterCounter, 1)

	mmCounter.t.Helper()

	if mmCounter.inspectFuncCounter != nil {
		mmCounter.inspectFuncCounter(metric, labels)
	}

	mm_params := StorageMockCounterParams{metric, labels}

	// Record call args
	mmCounter.CounterMock.mutex.Lock()
	mmCounter.CounterMock.callArgs = append(mmCounter.CounterMock.callArgs, &mm_params)
	mmCounter.CounterMock.mutex.Unlock()

	for _, e := range mmCounter.CounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1
		}
	}

	if mmCounter.CounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounter.CounterMock.defaultExpectation.Counter, 1)
		mm_want := mmCounter.CounterMock.defaultExpectation.params
		mm_want_ptrs := mmCounter.CounterMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCounterParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmCounter.t.Errorf("StorageMock.Counter got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounter.CounterMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounter.t.Errorf("StorageMock.Counter got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounter.CounterMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounter.t.Errorf("StorageMock.Counter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounter.CounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCounter.CounterMock.defaultExpectation.results
		if mm_results == nil {
			mmCounter.t.Fatal("No results are set for the StorageMock.Counter")
		}
		return (*mm_results).cp1
	}
	if mmCounter.funcCounter != nil {
		return mmCounter.funcCounter(metric, labels)
	}
	mmCounter.t.Fatalf("Unexpected call to StorageMock.Counter. %v %v", metric, labels)
	return
}

// CounterAfterCounter returns a count of finished StorageMock.Counter invocations
func (mmCounter *StorageMock) CounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounter.afterCounterCounter)
}

// CounterBeforeCounter returns a count of StorageMock.Counter invocations
func (mmCounter *StorageMock) CounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounter.beforeCounterCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Counter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounter *mStorageMockCounter) Calls() []*StorageMockCounterParams {
	mmCounter.mutex.RLock()

	argCopy := make([]*StorageMockCounterParams, len(mmCounter.callArgs))
	copy(argCopy, mmCounter.callArgs)

	mmCounter.mutex.RUnlock()

	return argCopy
}

// MinimockCounterDone returns true if the count of the Counter invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCounterDone() bool {
	if m.CounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterMock.invocationsDone()
}

// MinimockCounterInspect logs each unmet expectation
func (m *StorageMock) MinimockCounterInspect() {
	for _, e := range m.CounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Counter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterCounter := mm_atomic.LoadUint64(&m.afterCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterMock.defaultExpectation != nil && afterCounterCounter < 1 {
		if m.CounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.Counter at\n%s", m.CounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.Counter at\n%s with params: %#v", m.CounterMock.defaultExpectation.expectationOrigins.origin, *m.CounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounter != nil && afterCounterCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Counter at\n%s", m.funcCounterOrigin)
	}

	if !m.CounterMock.invocationsDone() && afterCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Counter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterMock.expectedInvocations), m.CounterMock.expectedInvocationsOrigin, afterCounterCounter)
	}
}

type mStorageMockCounterAdd struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCounterAddExpectation
	expectations       []*StorageMockCounterAddExpectation

	callArgs []*StorageMockCounterAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCounterAddExpectation specifies expectation struct of the Storage.CounterAdd
type StorageMockCounterAddExpectation struct {
	mock               *StorageMock
	params             *StorageMockCounterAddParams
	paramPtrs          *StorageMockCounterAddParamPtrs
	expectationOrigins StorageMockCounterAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockCounterAddParams contains parameters of the Storage.CounterAdd
type StorageMockCounterAddParams struct {
	metric string
	value  float64
	labels map[string]string
}

// StorageMockCounterAddParamPtrs contains pointers to parameters of the Storage.CounterAdd
type StorageMockCounterAddParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// StorageMockCounterAddOrigins contains origins of expectations of the Storage.CounterAdd
type StorageMockCounterAddExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounterAdd *mStorageMockCounterAdd) Optional() *mStorageMockCounterAdd {
	mmCounterAdd.optional = true
	return mmCounterAdd
}

// Expect sets up expected params for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) Expect(metric string, value float64, labels map[string]string) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.paramPtrs != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by ExpectParams functions")
	}

	mmCounterAdd.defaultExpectation.params = &StorageMockCounterAddParams{metric, value, labels}
	mmCounterAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounterAdd.expectations {
		if minimock.Equal(e.params, mmCounterAdd.defaultExpectation.params) {
			mmCounterAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounterAdd.defaultExpectation.params)
		}
	}

	return mmCounterAdd
}

// ExpectMetricParam1 sets up expected param metric for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) ExpectMetricParam1(metric string) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &StorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.metric = &metric
	mmCounterAdd.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectValueParam2 sets up expected param value for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) ExpectValueParam2(value float64) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &StorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.value = &value
	mmCounterAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectLabelsParam3 sets up expected param labels for Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) ExpectLabelsParam3(labels map[string]string) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &StorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.labels = &labels
	mmCounterAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounterAdd
}

// Inspect accepts an inspector function that has same arguments as the Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) Inspect(f func(metric string, value float64, labels map[string]string)) *mStorageMockCounterAdd {
	if mmCounterAdd.mock.inspectFuncCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("Inspect function is already set for StorageMock.CounterAdd")
	}

	mmCounterAdd.mock.inspectFuncCounterAdd = f

	return mmCounterAdd
}

// Return sets up results that will be returned by Storage.CounterAdd
func (mmCounterAdd *mStorageMockCounterAdd) Return() *StorageMock {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("StorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &StorageMockCounterAddExpectation{mock: mmCounterAdd.mock}
	}

	mmCounterAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// Set uses given function f to mock the Storage.CounterAdd method
func (mmCounterAdd *mStorageMockCounterAdd) Set(f func(metric string, value float64, labels map[string]string)) *StorageMock {
	if mmCounterAdd.defaultExpectation != nil {
		mmCounterAdd.mock.t.Fatalf("Default expectation is already set for the Storage.CounterAdd method")
	}

	if len(mmCounterAdd.expectations) > 0 {
		mmCounterAdd.mock.t.Fatalf("Some expectations are already set for the Storage.CounterAdd method")
	}

	mmCounterAdd.mock.funcCounterAdd = f
	mmCounterAdd.mock.funcCounterAddOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// Times sets number of times Storage.CounterAdd should be invoked
func (mmCounterAdd *mStorageMockCounterAdd) Times(n uint64) *mStorageMockCounterAdd {
	if n == 0 {
		mmCounterAdd.mock.t.Fatalf("Times of StorageMock.CounterAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounterAdd.expectedInvocations, n)
	mmCounterAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounterAdd
}

func (mmCounterAdd *mStorageMockCounterAdd) invocationsDone() bool {
	if len(mmCounterAdd.expectations) == 0 && mmCounterAdd.defaultExpectation == nil && mmCounterAdd.mock.funcCounterAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounterAdd.mock.afterCounterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounterAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CounterAdd implements Storage
func (mmCounterAdd *StorageMock) CounterAdd(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmCounterAdd.beforeCounterAddCounter, 1)
	defer mm_atomic.AddUint64(&mmCounterAdd.afterCounterAddCounter, 1)

	mmCounterAdd.t.Helper()

	if mmCounterAdd.inspectFuncCounterAdd != nil {
		mmCounterAdd.inspectFuncCounterAdd(metric, value, labels)
	}

	mm_params := StorageMockCounterAddParams{metric, value, labels}

	// Record call args
	mmCounterAdd.CounterAddMock.mutex.Lock()
	mmCounterAdd.CounterAddMock.callArgs = append(mmCounterAdd.CounterAddMock.callArgs, &mm_params)
	mmCounterAdd.CounterAddMock.mutex.Unlock()

	for _, e := range mmCounterAdd.CounterAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCounterAdd.CounterAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounterAdd.CounterAddMock.defaultExpectation.Counter, 1)
		mm_want := mmCounterAdd.CounterAddMock.defaultExpectation.params
		mm_want_ptrs := mmCounterAdd.CounterAddMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCounterAddParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounterAdd.t.Errorf("StorageMock.CounterAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCounterAdd.funcCounterAdd != nil {
		mmCounterAdd.funcCounterAdd(metric, value, labels)
		return
	}
	mmCounterAdd.t.Fatalf("Unexpected call to StorageMock.CounterAdd. %v %v %v", metric, value, labels)

}

// CounterAddAfterCounter returns a count of finished StorageMock.CounterAdd invocations
func (mmCounterAdd *StorageMock) CounterAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.afterCounterAddCounter)
}

// CounterAddBeforeCounter returns a count of StorageMock.CounterAdd invocations
func (mmCounterAdd *StorageMock) CounterAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.beforeCounterAddCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CounterAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounterAdd *mStorageMockCounterAdd) Calls() []*StorageMockCounterAddParams {
	mmCounterAdd.mutex.RLock()

	argCopy := make([]*StorageMockCounterAddParams, len(mmCounterAdd.callArgs))
	copy(argCopy, mmCounterAdd.callArgs)

	mmCounterAdd.mutex.RUnlock()

	return argCopy
}

// MinimockCounterAddDone returns true if the count of the CounterAdd invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCounterAddDone() bool {
	if m.CounterAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterAddMock.invocationsDone()
}

// MinimockCounterAddInspect logs each unmet expectation
func (m *StorageMock) MinimockCounterAddInspect() {
	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterAddCounter := mm_atomic.LoadUint64(&m.afterCounterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterAddMock.defaultExpectation != nil && afterCounterAddCounter < 1 {
		if m.CounterAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s", m.CounterAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s with params: %#v", m.CounterAddMock.defaultExpectation.expectationOrigins.origin, *m.CounterAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounterAdd != nil && afterCounterAddCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CounterAdd at\n%s", m.funcCounterAddOrigin)
	}

	if !m.CounterAddMock.invocationsDone() && afterCounterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CounterAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterAddMock.expectedInvocations), m.CounterAddMock.expectedInvocationsOrigin, afterCounterAddCounter)
	}
}

type mStorageMockGauge struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGaugeExpectation
	expectations       []*StorageMockGaugeExpectation

	callArgs []*StorageMockGaugeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGaugeExpectation specifies expectation struct of the Storage.Gauge
type StorageMockGaugeExpectation struct {
	mock               *StorageMock
	params             *StorageMockGaugeParams
	paramPtrs          *StorageMockGaugeParamPtrs
	expectationOrigins StorageMockGaugeExpectationOrigins
	results            *StorageMockGaugeResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGaugeParams contains parameters of the Storage.Gauge
type StorageMockGaugeParams struct {
	metric string
	labels map[string]string
}

// StorageMockGaugeParamPtrs contains pointers to parameters of the Storage.Gauge
type StorageMockGaugeParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockGaugeResults contains results of the Storage.Gauge
type StorageMockGaugeResults struct {
	gp1 *prometheus.GaugeVec
}

// StorageMockGaugeOrigins contains origins of expectations of the Storage.Gauge
type StorageMockGaugeExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGauge *mStorageMockGauge) Optional() *mStorageMockGauge {
	mmGauge.optional = true
	return mmGauge
}

// Expect sets up expected params for Storage.Gauge
func (mmGauge *mStorageMockGauge) Expect(metric string, labels map[string]string) *mStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.paramPtrs != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by ExpectParams functions")
	}

	mmGauge.defaultExpectation.params = &StorageMockGaugeParams{metric, labels}
	mmGauge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGauge.expectations {
		if minimock.Equal(e.params, mmGauge.defaultExpectation.params) {
			mmGauge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGauge.defaultExpectation.params)
		}
	}

	return mmGauge
}

// ExpectMetricParam1 sets up expected param metric for Storage.Gauge
func (mmGauge *mStorageMockGauge) ExpectMetricParam1(metric string) *mStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.params != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Expect")
	}

	if mmGauge.defaultExpectation.paramPtrs == nil {
		mmGauge.defaultExpectation.paramPtrs = &StorageMockGaugeParamPtrs{}
	}
	mmGauge.defaultExpectation.paramPtrs.metric = &metric
	mmGauge.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGauge
}

// ExpectLabelsParam2 sets up expected param labels for Storage.Gauge
func (mmGauge *mStorageMockGauge) ExpectLabelsParam2(labels map[string]string) *mStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.params != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Expect")
	}

	if mmGauge.defaultExpectation.paramPtrs == nil {
		mmGauge.defaultExpectation.paramPtrs = &StorageMockGaugeParamPtrs{}
	}
	mmGauge.defaultExpectation.paramPtrs.labels = &labels
	mmGauge.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGauge
}

// Inspect accepts an inspector function that has same arguments as the Storage.Gauge
func (mmGauge *mStorageMockGauge) Inspect(f func(metric string, labels map[string]string)) *mStorageMockGauge {
	if mmGauge.mock.inspectFuncGauge != nil {
		mmGauge.mock.t.Fatalf("Inspect function is already set for StorageMock.Gauge")
	}

	mmGauge.mock.inspectFuncGauge = f

	return mmGauge
}

// Return sets up results that will be returned by Storage.Gauge
func (mmGauge *mStorageMockGauge) Return(gp1 *prometheus.GaugeVec) *StorageMock {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &StorageMockGaugeExpectation{mock: mmGauge.mock}
	}
	mmGauge.defaultExpectation.results = &StorageMockGaugeResults{gp1}
	mmGauge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGauge.mock
}

// Set uses given function f to mock the Storage.Gauge method
func (mmGauge *mStorageMockGauge) Set(f func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)) *StorageMock {
	if mmGauge.defaultExpectation != nil {
		mmGauge.mock.t.Fatalf("Default expectation is already set for the Storage.Gauge method")
	}

	if len(mmGauge.expectations) > 0 {
		mmGauge.mock.t.Fatalf("Some expectations are already set for the Storage.Gauge method")
	}

	mmGauge.mock.funcGauge = f
	mmGauge.mock.funcGaugeOrigin = minimock.CallerInfo(1)
	return mmGauge.mock
}

// When sets expectation for the Storage.Gauge which will trigger the result defined by the following
// Then helper
func (mmGauge *mStorageMockGauge) When(metric string, labels map[string]string) *StorageMockGaugeExpectation {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("StorageMock.Gauge mock is already set by Set")
	}

	expectation := &StorageMockGaugeExpectation{
		mock:               mmGauge.mock,
		params:             &StorageMockGaugeParams{metric, labels},
		expectationOrigins: StorageMockGaugeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGauge.expectations = append(mmGauge.expectations, expectation)
	return expectation
}

// Then sets up Storage.Gauge return parameters for the expectation previously defined by the When method
func (e *StorageMockGaugeExpectation) Then(gp1 *prometheus.GaugeVec) *StorageMock {
	e.results = &StorageMockGaugeResults{gp1}
	return e.mock
}

// Times sets number of times Storage.Gauge should be invoked
func (mmGauge *mStorageMockGauge) Times(n uint64) *mStorageMockGauge {
	if n == 0 {
		mmGauge.mock.t.Fatalf("Times of StorageMock.Gauge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGauge.expectedInvocations, n)
	mmGauge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGauge
}

func (mmGauge *mStorageMockGauge) invocationsDone() bool {
	if len(mmGauge.expectations) == 0 && mmGauge.defaultExpectation == nil && mmGauge.mock.funcGauge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGauge.mock.afterGaugeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGauge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Gauge implements Storage
func (mmGauge *StorageMock) Gauge(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec) {
	mm_atomic.AddUint64(&mmGauge.beforeGaugeCounter, 1)
	defer mm_atomic.AddUint64(&mmGauge.afterGaugeCounter, 1)

	mmGauge.t.Helper()

	if mmGauge.inspectFuncGauge != nil {
		mmGauge.inspectFuncGauge(metric, labels)
	}

	mm_params := StorageMockGaugeParams{metric, labels}

	// Record call args
	mmGauge.GaugeMock.mutex.Lock()
	mmGauge.GaugeMock.callArgs = append(mmGauge.GaugeMock.callArgs, &mm_params)
	mmGauge.GaugeMock.mutex.Unlock()

	for _, e := range mmGauge.GaugeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1
		}
	}

	if mmGauge.GaugeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGauge.GaugeMock.defaultExpectation.Counter, 1)
		mm_want := mmGauge.GaugeMock.defaultExpectation.params
		mm_want_ptrs := mmGauge.GaugeMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGaugeParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGauge.t.Errorf("StorageMock.Gauge got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGauge.GaugeMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGauge.t.Errorf("StorageMock.Gauge got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGauge.GaugeMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGauge.t.Errorf("StorageMock.Gauge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGauge.GaugeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGauge.GaugeMock.defaultExpectation.results
		if mm_results == nil {
			mmGauge.t.Fatal("No results are set for the StorageMock.Gauge")
		}
		return (*mm_results).gp1
	}
	if mmGauge.funcGauge != nil {
		return mmGauge.funcGauge(metric, labels)
	}
	mmGauge.t.Fatalf("Unexpected call to StorageMock.Gauge. %v %v", metric, labels)
	return
}

// GaugeAfterCounter returns a count of finished StorageMock.Gauge invocations
func (mmGauge *StorageMock) GaugeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGauge.afterGaugeCounter)
}

// GaugeBeforeCounter returns a count of StorageMock.Gauge invocations
func (mmGauge *StorageMock) GaugeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGauge.beforeGaugeCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Gauge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGauge *mStorageMockGauge) Calls() []*StorageMockGaugeParams {
	mmGauge.mutex.RLock()

	argCopy := make([]*StorageMockGaugeParams, len(mmGauge.callArgs))
	copy(argCopy, mmGauge.callArgs)

	mmGauge.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeDone returns true if the count of the Gauge invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGaugeDone() bool {
	if m.GaugeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeMock.invocationsDone()
}

// MinimockGaugeInspect logs each unmet expectation
func (m *StorageMock) MinimockGaugeInspect() {
	for _, e := range m.GaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Gauge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeCounter := mm_atomic.LoadUint64(&m.afterGaugeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeMock.defaultExpectation != nil && afterGaugeCounter < 1 {
		if m.GaugeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.Gauge at\n%s", m.GaugeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.Gauge at\n%s with params: %#v", m.GaugeMock.defaultExpectation.expectationOrigins.origin, *m.GaugeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGauge != nil && afterGaugeCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Gauge at\n%s", m.funcGaugeOrigin)
	}

	if !m.GaugeMock.invocationsDone() && afterGaugeCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Gauge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeMock.expectedInvocations), m.GaugeMock.expectedInvocationsOrigin, afterGaugeCounter)
	}
}

type mStorageMockGaugeAdd struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGaugeAddExpectation
	expectations       []*StorageMockGaugeAddExpectation

	callArgs []*StorageMockGaugeAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGaugeAddExpectation specifies expectation struct of the Storage.GaugeAdd
type StorageMockGaugeAddExpectation struct {
	mock               *StorageMock
	params             *StorageMockGaugeAddParams
	paramPtrs          *StorageMockGaugeAddParamPtrs
	expectationOrigins StorageMockGaugeAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockGaugeAddParams contains parameters of the Storage.GaugeAdd
type StorageMockGaugeAddParams struct {
	metric string
	value  float64
	labels map[string]string
}

// StorageMockGaugeAddParamPtrs contains pointers to parameters of the Storage.GaugeAdd
type StorageMockGaugeAddParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// StorageMockGaugeAddOrigins contains origins of expectations of the Storage.GaugeAdd
type StorageMockGaugeAddExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeAdd *mStorageMockGaugeAdd) Optional() *mStorageMockGaugeAdd {
	mmGaugeAdd.optional = true
	return mmGaugeAdd
}

// Expect sets up expected params for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) Expect(metric string, value float64, labels map[string]string) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by ExpectParams functions")
	}

	mmGaugeAdd.defaultExpectation.params = &StorageMockGaugeAddParams{metric, value, labels}
	mmGaugeAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeAdd.expectations {
		if minimock.Equal(e.params, mmGaugeAdd.defaultExpectation.params) {
			mmGaugeAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeAdd.defaultExpectation.params)
		}
	}

	return mmGaugeAdd
}

// ExpectMetricParam1 sets up expected param metric for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) ExpectMetricParam1(metric string) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &StorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.metric = &metric
	mmGaugeAdd.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// ExpectValueParam2 sets up expected param value for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) ExpectValueParam2(value float64) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &StorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.value = &value
	mmGaugeAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// ExpectLabelsParam3 sets up expected param labels for Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) ExpectLabelsParam3(labels map[string]string) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &StorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// Inspect accepts an inspector function that has same arguments as the Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) Inspect(f func(metric string, value float64, labels map[string]string)) *mStorageMockGaugeAdd {
	if mmGaugeAdd.mock.inspectFuncGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("Inspect function is already set for StorageMock.GaugeAdd")
	}

	mmGaugeAdd.mock.inspectFuncGaugeAdd = f

	return mmGaugeAdd
}

// Return sets up results that will be returned by Storage.GaugeAdd
func (mmGaugeAdd *mStorageMockGaugeAdd) Return() *StorageMock {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("StorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &StorageMockGaugeAddExpectation{mock: mmGaugeAdd.mock}
	}

	mmGaugeAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd.mock
}

// Set uses given function f to mock the Storage.GaugeAdd method
func (mmGaugeAdd *mStorageMockGaugeAdd) Set(f func(metric string, value float64, labels map[string]string)) *StorageMock {
	if mmGaugeAdd.defaultExpectation != nil {
		mmGaugeAdd.mock.t.Fatalf("Default expectation is already set for the Storage.GaugeAdd method")
	}

	if len(mmGaugeAdd.expectations) > 0 {
		mmGaugeAdd.mock.t.Fatalf("Some expectations are already set for the Storage.GaugeAdd method")
	}

	mmGaugeAdd.mock.funcGaugeAdd = f
	mmGaugeAdd.mock.funcGaugeAddOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd.mock
}

// Times sets number of times Storage.GaugeAdd should be invoked
func (mmGaugeAdd *mStorageMockGaugeAdd) Times(n uint64) *mStorageMockGaugeAdd {
	if n == 0 {
		mmGaugeAdd.mock.t.Fatalf("Times of StorageMock.GaugeAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeAdd.expectedInvocations, n)
	mmGaugeAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd
}

func (mmGaugeAdd *mStorageMockGaugeAdd) invocationsDone() bool {
	if len(mmGaugeAdd.expectations) == 0 && mmGaugeAdd.defaultExpectation == nil && mmGaugeAdd.mock.funcGaugeAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeAdd.mock.afterGaugeAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeAdd implements Storage
func (mmGaugeAdd *StorageMock) GaugeAdd(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeAdd.beforeGaugeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeAdd.afterGaugeAddCounter, 1)

	mmGaugeAdd.t.Helper()

	if mmGaugeAdd.inspectFuncGaugeAdd != nil {
		mmGaugeAdd.inspectFuncGaugeAdd(metric, value, labels)
	}

	mm_params := StorageMockGaugeAddParams{metric, value, labels}

	// Record call args
	mmGaugeAdd.GaugeAddMock.mutex.Lock()
	mmGaugeAdd.GaugeAddMock.callArgs = append(mmGaugeAdd.GaugeAddMock.callArgs, &mm_params)
	mmGaugeAdd.GaugeAddMock.mutex.Unlock()

	for _, e := range mmGaugeAdd.GaugeAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeAdd.GaugeAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeAdd.GaugeAddMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeAdd.GaugeAddMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeAdd.GaugeAddMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGaugeAddParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeAdd.t.Errorf("StorageMock.GaugeAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeAdd.funcGaugeAdd != nil {
		mmGaugeAdd.funcGaugeAdd(metric, value, labels)
		return
	}
	mmGaugeAdd.t.Fatalf("Unexpected call to StorageMock.GaugeAdd. %v %v %v", metric, value, labels)

}

// GaugeAddAfterCounter returns a count of finished StorageMock.GaugeAdd invocations
func (mmGaugeAdd *StorageMock) GaugeAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeAdd.afterGaugeAddCounter)
}

// GaugeAddBeforeCounter returns a count of StorageMock.GaugeAdd invocations
func (mmGaugeAdd *StorageMock) GaugeAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeAdd.beforeGaugeAddCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GaugeAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeAdd *mStorageMockGaugeAdd) Calls() []*StorageMockGaugeAddParams {
	mmGaugeAdd.mutex.RLock()

	argCopy := make([]*StorageMockGaugeAddParams, len(mmGaugeAdd.callArgs))
	copy(argCopy, mmGaugeAdd.callArgs)

	mmGaugeAdd.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeAddDone returns true if the count of the GaugeAdd invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGaugeAddDone() bool {
	if m.GaugeAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeAddMock.invocationsDone()
}

// MinimockGaugeAddInspect logs each unmet expectation
func (m *StorageMock) MinimockGaugeAddInspect() {
	for _, e := range m.GaugeAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeAddCounter := mm_atomic.LoadUint64(&m.afterGaugeAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeAddMock.defaultExpectation != nil && afterGaugeAddCounter < 1 {
		if m.GaugeAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s", m.GaugeAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s with params: %#v", m.GaugeAddMock.defaultExpectation.expectationOrigins.origin, *m.GaugeAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeAdd != nil && afterGaugeAddCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GaugeAdd at\n%s", m.funcGaugeAddOrigin)
	}

	if !m.GaugeAddMock.invocationsDone() && afterGaugeAddCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GaugeAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeAddMock.expectedInvocations), m.GaugeAddMock.expectedInvocationsOrigin, afterGaugeAddCounter)
	}
}

type mStorageMockGaugeSet struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGaugeSetExpectation
	expectations       []*StorageMockGaugeSetExpectation

	callArgs []*StorageMockGaugeSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGaugeSetExpectation specifies expectation struct of the Storage.GaugeSet
type StorageMockGaugeSetExpectation struct {
	mock               *StorageMock
	params             *StorageMockGaugeSetParams
	paramPtrs          *StorageMockGaugeSetParamPtrs
	expectationOrigins StorageMockGaugeSetExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockGaugeSetParams contains parameters of the Storage.GaugeSet
type StorageMockGaugeSetParams struct {
	metric string
	value  float64
	labels map[string]string
}

// StorageMockGaugeSetParamPtrs contains pointers to parameters of the Storage.GaugeSet
type StorageMockGaugeSetParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// StorageMockGaugeSetOrigins contains origins of expectations of the Storage.GaugeSet
type StorageMockGaugeSetExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeSet *mStorageMockGaugeSet) Optional() *mStorageMockGaugeSet {
	mmGaugeSet.optional = true
	return mmGaugeSet
}

// Expect sets up expected params for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) Expect(metric string, value float64, labels map[string]string) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.paramPtrs != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by ExpectParams functions")
	}

	mmGaugeSet.defaultExpectation.params = &StorageMockGaugeSetParams{metric, value, labels}
	mmGaugeSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeSet.expectations {
		if minimock.Equal(e.params, mmGaugeSet.defaultExpectation.params) {
			mmGaugeSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeSet.defaultExpectation.params)
		}
	}

	return mmGaugeSet
}

// ExpectMetricParam1 sets up expected param metric for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) ExpectMetricParam1(metric string) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &StorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.metric = &metric
	mmGaugeSet.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectValueParam2 sets up expected param value for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) ExpectValueParam2(value float64) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &StorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.value = &value
	mmGaugeSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectLabelsParam3 sets up expected param labels for Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) ExpectLabelsParam3(labels map[string]string) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &StorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeSet.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeSet
}

// Inspect accepts an inspector function that has same arguments as the Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) Inspect(f func(metric string, value float64, labels map[string]string)) *mStorageMockGaugeSet {
	if mmGaugeSet.mock.inspectFuncGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("Inspect function is already set for StorageMock.GaugeSet")
	}

	mmGaugeSet.mock.inspectFuncGaugeSet = f

	return mmGaugeSet
}

// Return sets up results that will be returned by Storage.GaugeSet
func (mmGaugeSet *mStorageMockGaugeSet) Return() *StorageMock {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("StorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &StorageMockGaugeSetExpectation{mock: mmGaugeSet.mock}
	}

	mmGaugeSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// Set uses given function f to mock the Storage.GaugeSet method
func (mmGaugeSet *mStorageMockGaugeSet) Set(f func(metric string, value float64, labels map[string]string)) *StorageMock {
	if mmGaugeSet.defaultExpectation != nil {
		mmGaugeSet.mock.t.Fatalf("Default expectation is already set for the Storage.GaugeSet method")
	}

	if len(mmGaugeSet.expectations) > 0 {
		mmGaugeSet.mock.t.Fatalf("Some expectations are already set for the Storage.GaugeSet method")
	}

	mmGaugeSet.mock.funcGaugeSet = f
	mmGaugeSet.mock.funcGaugeSetOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// Times sets number of times Storage.GaugeSet should be invoked
func (mmGaugeSet *mStorageMockGaugeSet) Times(n uint64) *mStorageMockGaugeSet {
	if n == 0 {
		mmGaugeSet.mock.t.Fatalf("Times of StorageMock.GaugeSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeSet.expectedInvocations, n)
	mmGaugeSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeSet
}

func (mmGaugeSet *mStorageMockGaugeSet) invocationsDone() bool {
	if len(mmGaugeSet.expectations) == 0 && mmGaugeSet.defaultExpectation == nil && mmGaugeSet.mock.funcGaugeSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeSet.mock.afterGaugeSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeSet implements Storage
func (mmGaugeSet *StorageMock) GaugeSet(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeSet.beforeGaugeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeSet.afterGaugeSetCounter, 1)

	mmGaugeSet.t.Helper()

	if mmGaugeSet.inspectFuncGaugeSet != nil {
		mmGaugeSet.inspectFuncGaugeSet(metric, value, labels)
	}

	mm_params := StorageMockGaugeSetParams{metric, value, labels}

	// Record call args
	mmGaugeSet.GaugeSetMock.mutex.Lock()
	mmGaugeSet.GaugeSetMock.callArgs = append(mmGaugeSet.GaugeSetMock.callArgs, &mm_params)
	mmGaugeSet.GaugeSetMock.mutex.Unlock()

	for _, e := range mmGaugeSet.GaugeSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeSet.GaugeSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeSet.GaugeSetMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeSet.GaugeSetMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeSet.GaugeSetMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGaugeSetParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeSet.t.Errorf("StorageMock.GaugeSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeSet.funcGaugeSet != nil {
		mmGaugeSet.funcGaugeSet(metric, value, labels)
		return
	}
	mmGaugeSet.t.Fatalf("Unexpected call to StorageMock.GaugeSet. %v %v %v", metric, value, labels)

}

// GaugeSetAfterCounter returns a count of finished StorageMock.GaugeSet invocations
func (mmGaugeSet *StorageMock) GaugeSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.afterGaugeSetCounter)
}

// GaugeSetBeforeCounter returns a count of StorageMock.GaugeSet invocations
func (mmGaugeSet *StorageMock) GaugeSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.beforeGaugeSetCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GaugeSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeSet *mStorageMockGaugeSet) Calls() []*StorageMockGaugeSetParams {
	mmGaugeSet.mutex.RLock()

	argCopy := make([]*StorageMockGaugeSetParams, len(mmGaugeSet.callArgs))
	copy(argCopy, mmGaugeSet.callArgs)

	mmGaugeSet.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeSetDone returns true if the count of the GaugeSet invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGaugeSetDone() bool {
	if m.GaugeSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeSetMock.invocationsDone()
}

// MinimockGaugeSetInspect logs each unmet expectation
func (m *StorageMock) MinimockGaugeSetInspect() {
	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeSetCounter := mm_atomic.LoadUint64(&m.afterGaugeSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeSetMock.defaultExpectation != nil && afterGaugeSetCounter < 1 {
		if m.GaugeSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s", m.GaugeSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s with params: %#v", m.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *m.GaugeSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeSet != nil && afterGaugeSetCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GaugeSet at\n%s", m.funcGaugeSetOrigin)
	}

	if !m.GaugeSetMock.invocationsDone() && afterGaugeSetCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GaugeSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeSetMock.expectedInvocations), m.GaugeSetMock.expectedInvocationsOrigin, afterGaugeSetCounter)
	}
}

type mStorageMockGrouped struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGroupedExpectation
	expectations       []*StorageMockGroupedExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGroupedExpectation specifies expectation struct of the Storage.Grouped
type StorageMockGroupedExpectation struct {
	mock *StorageMock

	results      *StorageMockGroupedResults
	returnOrigin string
	Counter      uint64
}

// StorageMockGroupedResults contains results of the Storage.Grouped
type StorageMockGroupedResults struct {
	g1 GroupedStorage
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGrouped *mStorageMockGrouped) Optional() *mStorageMockGrouped {
	mmGrouped.optional = true
	return mmGrouped
}

// Expect sets up expected params for Storage.Grouped
func (mmGrouped *mStorageMockGrouped) Expect() *mStorageMockGrouped {
	if mmGrouped.mock.funcGrouped != nil {
		mmGrouped.mock.t.Fatalf("StorageMock.Grouped mock is already set by Set")
	}

	if mmGrouped.defaultExpectation == nil {
		mmGrouped.defaultExpectation = &StorageMockGroupedExpectation{}
	}

	return mmGrouped
}

// Inspect accepts an inspector function that has same arguments as the Storage.Grouped
func (mmGrouped *mStorageMockGrouped) Inspect(f func()) *mStorageMockGrouped {
	if mmGrouped.mock.inspectFuncGrouped != nil {
		mmGrouped.mock.t.Fatalf("Inspect function is already set for StorageMock.Grouped")
	}

	mmGrouped.mock.inspectFuncGrouped = f

	return mmGrouped
}

// Return sets up results that will be returned by Storage.Grouped
func (mmGrouped *mStorageMockGrouped) Return(g1 GroupedStorage) *StorageMock {
	if mmGrouped.mock.funcGrouped != nil {
		mmGrouped.mock.t.Fatalf("StorageMock.Grouped mock is already set by Set")
	}

	if mmGrouped.defaultExpectation == nil {
		mmGrouped.defaultExpectation = &StorageMockGroupedExpectation{mock: mmGrouped.mock}
	}
	mmGrouped.defaultExpectation.results = &StorageMockGroupedResults{g1}
	mmGrouped.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGrouped.mock
}

// Set uses given function f to mock the Storage.Grouped method
func (mmGrouped *mStorageMockGrouped) Set(f func() (g1 GroupedStorage)) *StorageMock {
	if mmGrouped.defaultExpectation != nil {
		mmGrouped.mock.t.Fatalf("Default expectation is already set for the Storage.Grouped method")
	}

	if len(mmGrouped.expectations) > 0 {
		mmGrouped.mock.t.Fatalf("Some expectations are already set for the Storage.Grouped method")
	}

	mmGrouped.mock.funcGrouped = f
	mmGrouped.mock.funcGroupedOrigin = minimock.CallerInfo(1)
	return mmGrouped.mock
}

// Times sets number of times Storage.Grouped should be invoked
func (mmGrouped *mStorageMockGrouped) Times(n uint64) *mStorageMockGrouped {
	if n == 0 {
		mmGrouped.mock.t.Fatalf("Times of StorageMock.Grouped mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGrouped.expectedInvocations, n)
	mmGrouped.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGrouped
}

func (mmGrouped *mStorageMockGrouped) invocationsDone() bool {
	if len(mmGrouped.expectations) == 0 && mmGrouped.defaultExpectation == nil && mmGrouped.mock.funcGrouped == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGrouped.mock.afterGroupedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGrouped.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Grouped implements Storage
func (mmGrouped *StorageMock) Grouped() (g1 GroupedStorage) {
	mm_atomic.AddUint64(&mmGrouped.beforeGroupedCounter, 1)
	defer mm_atomic.AddUint64(&mmGrouped.afterGroupedCounter, 1)

	mmGrouped.t.Helper()

	if mmGrouped.inspectFuncGrouped != nil {
		mmGrouped.inspectFuncGrouped()
	}

	if mmGrouped.GroupedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGrouped.GroupedMock.defaultExpectation.Counter, 1)

		mm_results := mmGrouped.GroupedMock.defaultExpectation.results
		if mm_results == nil {
			mmGrouped.t.Fatal("No results are set for the StorageMock.Grouped")
		}
		return (*mm_results).g1
	}
	if mmGrouped.funcGrouped != nil {
		return mmGrouped.funcGrouped()
	}
	mmGrouped.t.Fatalf("Unexpected call to StorageMock.Grouped.")
	return
}

// GroupedAfterCounter returns a count of finished StorageMock.Grouped invocations
func (mmGrouped *StorageMock) GroupedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrouped.afterGroupedCounter)
}

// GroupedBeforeCounter returns a count of StorageMock.Grouped invocations
func (mmGrouped *StorageMock) GroupedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrouped.beforeGroupedCounter)
}

// MinimockGroupedDone returns true if the count of the Grouped invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGroupedDone() bool {
	if m.GroupedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GroupedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GroupedMock.invocationsDone()
}

// MinimockGroupedInspect logs each unmet expectation
func (m *StorageMock) MinimockGroupedInspect() {
	for _, e := range m.GroupedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to StorageMock.Grouped")
		}
	}

	afterGroupedCounter := mm_atomic.LoadUint64(&m.afterGroupedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GroupedMock.defaultExpectation != nil && afterGroupedCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Grouped at\n%s", m.GroupedMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGrouped != nil && afterGroupedCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Grouped at\n%s", m.funcGroupedOrigin)
	}

	if !m.GroupedMock.invocationsDone() && afterGroupedCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Grouped at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GroupedMock.expectedInvocations), m.GroupedMock.expectedInvocationsOrigin, afterGroupedCounter)
	}
}

type mStorageMockHistogram struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockHistogramExpectation
	expectations       []*StorageMockHistogramExpectation

	callArgs []*StorageMockHistogramParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockHistogramExpectation specifies expectation struct of the Storage.Histogram
type StorageMockHistogramExpectation struct {
	mock               *StorageMock
	params             *StorageMockHistogramParams
	paramPtrs          *StorageMockHistogramParamPtrs
	expectationOrigins StorageMockHistogramExpectationOrigins
	results            *StorageMockHistogramResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockHistogramParams contains parameters of the Storage.Histogram
type StorageMockHistogramParams struct {
	metric  string
	labels  map[string]string
	buckets []float64
}

// StorageMockHistogramParamPtrs contains pointers to parameters of the Storage.Histogram
type StorageMockHistogramParamPtrs struct {
	metric  *string
	labels  *map[string]string
	buckets *[]float64
}

// StorageMockHistogramResults contains results of the Storage.Histogram
type StorageMockHistogramResults struct {
	hp1 *prometheus.HistogramVec
}

// StorageMockHistogramOrigins contains origins of expectations of the Storage.Histogram
type StorageMockHistogramExpectationOrigins struct {
	origin        string
	originMetric  string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistogram *mStorageMockHistogram) Optional() *mStorageMockHistogram {
	mmHistogram.optional = true
	return mmHistogram
}

// Expect sets up expected params for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) Expect(metric string, labels map[string]string, buckets []float64) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.paramPtrs != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by ExpectParams functions")
	}

	mmHistogram.defaultExpectation.params = &StorageMockHistogramParams{metric, labels, buckets}
	mmHistogram.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistogram.expectations {
		if minimock.Equal(e.params, mmHistogram.defaultExpectation.params) {
			mmHistogram.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistogram.defaultExpectation.params)
		}
	}

	return mmHistogram
}

// ExpectMetricParam1 sets up expected param metric for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) ExpectMetricParam1(metric string) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &StorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.metric = &metric
	mmHistogram.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmHistogram
}

// ExpectLabelsParam2 sets up expected param labels for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) ExpectLabelsParam2(labels map[string]string) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &StorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.labels = &labels
	mmHistogram.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmHistogram
}

// ExpectBucketsParam3 sets up expected param buckets for Storage.Histogram
func (mmHistogram *mStorageMockHistogram) ExpectBucketsParam3(buckets []float64) *mStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &StorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.buckets = &buckets
	mmHistogram.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmHistogram
}

// Inspect accepts an inspector function that has same arguments as the Storage.Histogram
func (mmHistogram *mStorageMockHistogram) Inspect(f func(metric string, labels map[string]string, buckets []float64)) *mStorageMockHistogram {
	if mmHistogram.mock.inspectFuncHistogram != nil {
		mmHistogram.mock.t.Fatalf("Inspect function is already set for StorageMock.Histogram")
	}

	mmHistogram.mock.inspectFuncHistogram = f

	return mmHistogram
}

// Return sets up results that will be returned by Storage.Histogram
func (mmHistogram *mStorageMockHistogram) Return(hp1 *prometheus.HistogramVec) *StorageMock {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &StorageMockHistogramExpectation{mock: mmHistogram.mock}
	}
	mmHistogram.defaultExpectation.results = &StorageMockHistogramResults{hp1}
	mmHistogram.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistogram.mock
}

// Set uses given function f to mock the Storage.Histogram method
func (mmHistogram *mStorageMockHistogram) Set(f func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)) *StorageMock {
	if mmHistogram.defaultExpectation != nil {
		mmHistogram.mock.t.Fatalf("Default expectation is already set for the Storage.Histogram method")
	}

	if len(mmHistogram.expectations) > 0 {
		mmHistogram.mock.t.Fatalf("Some expectations are already set for the Storage.Histogram method")
	}

	mmHistogram.mock.funcHistogram = f
	mmHistogram.mock.funcHistogramOrigin = minimock.CallerInfo(1)
	return mmHistogram.mock
}

// When sets expectation for the Storage.Histogram which will trigger the result defined by the following
// Then helper
func (mmHistogram *mStorageMockHistogram) When(metric string, labels map[string]string, buckets []float64) *StorageMockHistogramExpectation {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("StorageMock.Histogram mock is already set by Set")
	}

	expectation := &StorageMockHistogramExpectation{
		mock:               mmHistogram.mock,
		params:             &StorageMockHistogramParams{metric, labels, buckets},
		expectationOrigins: StorageMockHistogramExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistogram.expectations = append(mmHistogram.expectations, expectation)
	return expectation
}

// Then sets up Storage.Histogram return parameters for the expectation previously defined by the When method
func (e *StorageMockHistogramExpectation) Then(hp1 *prometheus.HistogramVec) *StorageMock {
	e.results = &StorageMockHistogramResults{hp1}
	return e.mock
}

// Times sets number of times Storage.Histogram should be invoked
func (mmHistogram *mStorageMockHistogram) Times(n uint64) *mStorageMockHistogram {
	if n == 0 {
		mmHistogram.mock.t.Fatalf("Times of StorageMock.Histogram mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistogram.expectedInvocations, n)
	mmHistogram.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistogram
}

func (mmHistogram *mStorageMockHistogram) invocationsDone() bool {
	if len(mmHistogram.expectations) == 0 && mmHistogram.defaultExpectation == nil && mmHistogram.mock.funcHistogram == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistogram.mock.afterHistogramCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistogram.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Histogram implements Storage
func (mmHistogram *StorageMock) Histogram(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec) {
	mm_atomic.AddUint64(&mmHistogram.beforeHistogramCounter, 1)
	defer mm_atomic.AddUint64(&mmHistogram.afterHistogramCounter, 1)

	mmHistogram.t.Helper()

	if mmHistogram.inspectFuncHistogram != nil {
		mmHistogram.inspectFuncHistogram(metric, labels, buckets)
	}

	mm_params := StorageMockHistogramParams{metric, labels, buckets}

	// Record call args
	mmHistogram.HistogramMock.mutex.Lock()
	mmHistogram.HistogramMock.callArgs = append(mmHistogram.HistogramMock.callArgs, &mm_params)
	mmHistogram.HistogramMock.mutex.Unlock()

	for _, e := range mmHistogram.HistogramMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1
		}
	}

	if mmHistogram.HistogramMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistogram.HistogramMock.defaultExpectation.Counter, 1)
		mm_want := mmHistogram.HistogramMock.defaultExpectation.params
		mm_want_ptrs := mmHistogram.HistogramMock.defaultExpectation.paramPtrs

		mm_got := StorageMockHistogramParams{metric, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistogram.t.Errorf("StorageMock.Histogram got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHistogram.HistogramMock.defaultExpectation.results
		if mm_results == nil {
			mmHistogram.t.Fatal("No results are set for the StorageMock.Histogram")
		}
		return (*mm_results).hp1
	}
	if mmHistogram.funcHistogram != nil {
		return mmHistogram.funcHistogram(metric, labels, buckets)
	}
	mmHistogram.t.Fatalf("Unexpected call to StorageMock.Histogram. %v %v %v", metric, labels, buckets)
	return
}

// HistogramAfterCounter returns a count of finished StorageMock.Histogram invocations
func (mmHistogram *StorageMock) HistogramAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogram.afterHistogramCounter)
}

// HistogramBeforeCounter returns a count of StorageMock.Histogram invocations
func (mmHistogram *StorageMock) HistogramBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogram.beforeHistogramCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.Histogram.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistogram *mStorageMockHistogram) Calls() []*StorageMockHistogramParams {
	mmHistogram.mutex.RLock()

	argCopy := make([]*StorageMockHistogramParams, len(mmHistogram.callArgs))
	copy(argCopy, mmHistogram.callArgs)

	mmHistogram.mutex.RUnlock()

	return argCopy
}

// MinimockHistogramDone returns true if the count of the Histogram invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockHistogramDone() bool {
	if m.HistogramMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistogramMock.invocationsDone()
}

// MinimockHistogramInspect logs each unmet expectation
func (m *StorageMock) MinimockHistogramInspect() {
	for _, e := range m.HistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.Histogram at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistogramCounter := mm_atomic.LoadUint64(&m.afterHistogramCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistogramMock.defaultExpectation != nil && afterHistogramCounter < 1 {
		if m.HistogramMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.Histogram at\n%s", m.HistogramMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.Histogram at\n%s with params: %#v", m.HistogramMock.defaultExpectation.expectationOrigins.origin, *m.HistogramMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistogram != nil && afterHistogramCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.Histogram at\n%s", m.funcHistogramOrigin)
	}

	if !m.HistogramMock.invocationsDone() && afterHistogramCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.Histogram at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistogramMock.expectedInvocations), m.HistogramMock.expectedInvocationsOrigin, afterHistogramCounter)
	}
}

type mStorageMockHistogramObserve struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockHistogramObserveExpectation
	expectations       []*StorageMockHistogramObserveExpectation

	callArgs []*StorageMockHistogramObserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockHistogramObserveExpectation specifies expectation struct of the Storage.HistogramObserve
type StorageMockHistogramObserveExpectation struct {
	mock               *StorageMock
	params             *StorageMockHistogramObserveParams
	paramPtrs          *StorageMockHistogramObserveParamPtrs
	expectationOrigins StorageMockHistogramObserveExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// StorageMockHistogramObserveParams contains parameters of the Storage.HistogramObserve
type StorageMockHistogramObserveParams struct {
	metric  string
	value   float64
	labels  map[string]string
	buckets []float64
}

// StorageMockHistogramObserveParamPtrs contains pointers to parameters of the Storage.HistogramObserve
type StorageMockHistogramObserveParamPtrs struct {
	metric  *string
	value   *float64
	labels  *map[string]string
	buckets *[]float64
}

// StorageMockHistogramObserveOrigins contains origins of expectations of the Storage.HistogramObserve
type StorageMockHistogramObserveExpectationOrigins struct {
	origin        string
	originMetric  string
	originValue   string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistogramObserve *mStorageMockHistogramObserve) Optional() *mStorageMockHistogramObserve {
	mmHistogramObserve.optional = true
	return mmHistogramObserve
}

// Expect sets up expected params for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) Expect(metric string, value float64, labels map[string]string, buckets []float64) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by ExpectParams functions")
	}

	mmHistogramObserve.defaultExpectation.params = &StorageMockHistogramObserveParams{metric, value, labels, buckets}
	mmHistogramObserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistogramObserve.expectations {
		if minimock.Equal(e.params, mmHistogramObserve.defaultExpectation.params) {
			mmHistogramObserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistogramObserve.defaultExpectation.params)
		}
	}

	return mmHistogramObserve
}

// ExpectMetricParam1 sets up expected param metric for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectMetricParam1(metric string) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.metric = &metric
	mmHistogramObserve.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectValueParam2 sets up expected param value for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectValueParam2(value float64) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.value = &value
	mmHistogramObserve.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectLabelsParam3 sets up expected param labels for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectLabelsParam3(labels map[string]string) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.labels = &labels
	mmHistogramObserve.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectBucketsParam4 sets up expected param buckets for Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) ExpectBucketsParam4(buckets []float64) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &StorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.buckets = &buckets
	mmHistogramObserve.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// Inspect accepts an inspector function that has same arguments as the Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) Inspect(f func(metric string, value float64, labels map[string]string, buckets []float64)) *mStorageMockHistogramObserve {
	if mmHistogramObserve.mock.inspectFuncHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("Inspect function is already set for StorageMock.HistogramObserve")
	}

	mmHistogramObserve.mock.inspectFuncHistogramObserve = f

	return mmHistogramObserve
}

// Return sets up results that will be returned by Storage.HistogramObserve
func (mmHistogramObserve *mStorageMockHistogramObserve) Return() *StorageMock {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("StorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &StorageMockHistogramObserveExpectation{mock: mmHistogramObserve.mock}
	}

	mmHistogramObserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve.mock
}

// Set uses given function f to mock the Storage.HistogramObserve method
func (mmHistogramObserve *mStorageMockHistogramObserve) Set(f func(metric string, value float64, labels map[string]string, buckets []float64)) *StorageMock {
	if mmHistogramObserve.defaultExpectation != nil {
		mmHistogramObserve.mock.t.Fatalf("Default expectation is already set for the Storage.HistogramObserve method")
	}

	if len(mmHistogramObserve.expectations) > 0 {
		mmHistogramObserve.mock.t.Fatalf("Some expectations are already set for the Storage.HistogramObserve method")
	}

	mmHistogramObserve.mock.funcHistogramObserve = f
	mmHistogramObserve.mock.funcHistogramObserveOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve.mock
}

// Times sets number of times Storage.HistogramObserve should be invoked
func (mmHistogramObserve *mStorageMockHistogramObserve) Times(n uint64) *mStorageMockHistogramObserve {
	if n == 0 {
		mmHistogramObserve.mock.t.Fatalf("Times of StorageMock.HistogramObserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistogramObserve.expectedInvocations, n)
	mmHistogramObserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve
}

func (mmHistogramObserve *mStorageMockHistogramObserve) invocationsDone() bool {
	if len(mmHistogramObserve.expectations) == 0 && mmHistogramObserve.defaultExpectation == nil && mmHistogramObserve.mock.funcHistogramObserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistogramObserve.mock.afterHistogramObserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistogramObserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HistogramObserve implements Storage
func (mmHistogramObserve *StorageMock) HistogramObserve(metric string, value float64, labels map[string]string, buckets []float64) {
	mm_atomic.AddUint64(&mmHistogramObserve.beforeHistogramObserveCounter, 1)
	defer mm_atomic.AddUint64(&mmHistogramObserve.afterHistogramObserveCounter, 1)

	mmHistogramObserve.t.Helper()

	if mmHistogramObserve.inspectFuncHistogramObserve != nil {
		mmHistogramObserve.inspectFuncHistogramObserve(metric, value, labels, buckets)
	}

	mm_params := StorageMockHistogramObserveParams{metric, value, labels, buckets}

	// Record call args
	mmHistogramObserve.HistogramObserveMock.mutex.Lock()
	mmHistogramObserve.HistogramObserveMock.callArgs = append(mmHistogramObserve.HistogramObserveMock.callArgs, &mm_params)
	mmHistogramObserve.HistogramObserveMock.mutex.Unlock()

	for _, e := range mmHistogramObserve.HistogramObserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmHistogramObserve.HistogramObserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistogramObserve.HistogramObserveMock.defaultExpectation.Counter, 1)
		mm_want := mmHistogramObserve.HistogramObserveMock.defaultExpectation.params
		mm_want_ptrs := mmHistogramObserve.HistogramObserveMock.defaultExpectation.paramPtrs

		mm_got := StorageMockHistogramObserveParams{metric, value, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistogramObserve.t.Errorf("StorageMock.HistogramObserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmHistogramObserve.funcHistogramObserve != nil {
		mmHistogramObserve.funcHistogramObserve(metric, value, labels, buckets)
		return
	}
	mmHistogramObserve.t.Fatalf("Unexpected call to StorageMock.HistogramObserve. %v %v %v %v", metric, value, labels, buckets)

}

// HistogramObserveAfterCounter returns a count of finished StorageMock.HistogramObserve invocations
func (mmHistogramObserve *StorageMock) HistogramObserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogramObserve.afterHistogramObserveCounter)
}

// HistogramObserveBeforeCounter returns a count of StorageMock.HistogramObserve invocations
func (mmHistogramObserve *StorageMock) HistogramObserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogramObserve.beforeHistogramObserveCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.HistogramObserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistogramObserve *mStorageMockHistogramObserve) Calls() []*StorageMockHistogramObserveParams {
	mmHistogramObserve.mutex.RLock()

	argCopy := make([]*StorageMockHistogramObserveParams, len(mmHistogramObserve.callArgs))
	copy(argCopy, mmHistogramObserve.callArgs)

	mmHistogramObserve.mutex.RUnlock()

	return argCopy
}

// MinimockHistogramObserveDone returns true if the count of the HistogramObserve invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockHistogramObserveDone() bool {
	if m.HistogramObserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistogramObserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistogramObserveMock.invocationsDone()
}

// MinimockHistogramObserveInspect logs each unmet expectation
func (m *StorageMock) MinimockHistogramObserveInspect() {
	for _, e := range m.HistogramObserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistogramObserveCounter := mm_atomic.LoadUint64(&m.afterHistogramObserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistogramObserveMock.defaultExpectation != nil && afterHistogramObserveCounter < 1 {
		if m.HistogramObserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s", m.HistogramObserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s with params: %#v", m.HistogramObserveMock.defaultExpectation.expectationOrigins.origin, *m.HistogramObserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistogramObserve != nil && afterHistogramObserveCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.HistogramObserve at\n%s", m.funcHistogramObserveOrigin)
	}

	if !m.HistogramObserveMock.invocationsDone() && afterHistogramObserveCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.HistogramObserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistogramObserveMock.expectedInvocations), m.HistogramObserveMock.expectedInvocationsOrigin, afterHistogramObserveCounter)
	}
}

type mStorageMockRegisterCounter struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRegisterCounterExpectation
	expectations       []*StorageMockRegisterCounterExpectation

	callArgs []*StorageMockRegisterCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRegisterCounterExpectation specifies expectation struct of the Storage.RegisterCounter
type StorageMockRegisterCounterExpectation struct {
	mock               *StorageMock
	params             *StorageMockRegisterCounterParams
	paramPtrs          *StorageMockRegisterCounterParamPtrs
	expectationOrigins StorageMockRegisterCounterExpectationOrigins
	results            *StorageMockRegisterCounterResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRegisterCounterParams contains parameters of the Storage.RegisterCounter
type StorageMockRegisterCounterParams struct {
	metric string
	labels map[string]string
}

// StorageMockRegisterCounterParamPtrs contains pointers to parameters of the Storage.RegisterCounter
type StorageMockRegisterCounterParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockRegisterCounterResults contains results of the Storage.RegisterCounter
type StorageMockRegisterCounterResults struct {
	cp1 *prometheus.CounterVec
}

// StorageMockRegisterCounterOrigins contains origins of expectations of the Storage.RegisterCounter
type StorageMockRegisterCounterExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterCounter *mStorageMockRegisterCounter) Optional() *mStorageMockRegisterCounter {
	mmRegisterCounter.optional = true
	return mmRegisterCounter
}

// Expect sets up expected params for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) Expect(metric string, labels map[string]string) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by ExpectParams functions")
	}

	mmRegisterCounter.defaultExpectation.params = &StorageMockRegisterCounterParams{metric, labels}
	mmRegisterCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterCounter.expectations {
		if minimock.Equal(e.params, mmRegisterCounter.defaultExpectation.params) {
			mmRegisterCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterCounter.defaultExpectation.params)
		}
	}

	return mmRegisterCounter
}

// ExpectMetricParam1 sets up expected param metric for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) ExpectMetricParam1(metric string) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.params != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Expect")
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs == nil {
		mmRegisterCounter.defaultExpectation.paramPtrs = &StorageMockRegisterCounterParamPtrs{}
	}
	mmRegisterCounter.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterCounter.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterCounter
}

// ExpectLabelsParam2 sets up expected param labels for Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) ExpectLabelsParam2(labels map[string]string) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.params != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Expect")
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs == nil {
		mmRegisterCounter.defaultExpectation.paramPtrs = &StorageMockRegisterCounterParamPtrs{}
	}
	mmRegisterCounter.defaultExpectation.paramPtrs.labels = &labels
	mmRegisterCounter.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmRegisterCounter
}

// Inspect accepts an inspector function that has same arguments as the Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) Inspect(f func(metric string, labels map[string]string)) *mStorageMockRegisterCounter {
	if mmRegisterCounter.mock.inspectFuncRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("Inspect function is already set for StorageMock.RegisterCounter")
	}

	mmRegisterCounter.mock.inspectFuncRegisterCounter = f

	return mmRegisterCounter
}

// Return sets up results that will be returned by Storage.RegisterCounter
func (mmRegisterCounter *mStorageMockRegisterCounter) Return(cp1 *prometheus.CounterVec) *StorageMock {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &StorageMockRegisterCounterExpectation{mock: mmRegisterCounter.mock}
	}
	mmRegisterCounter.defaultExpectation.results = &StorageMockRegisterCounterResults{cp1}
	mmRegisterCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter.mock
}

// Set uses given function f to mock the Storage.RegisterCounter method
func (mmRegisterCounter *mStorageMockRegisterCounter) Set(f func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)) *StorageMock {
	if mmRegisterCounter.defaultExpectation != nil {
		mmRegisterCounter.mock.t.Fatalf("Default expectation is already set for the Storage.RegisterCounter method")
	}

	if len(mmRegisterCounter.expectations) > 0 {
		mmRegisterCounter.mock.t.Fatalf("Some expectations are already set for the Storage.RegisterCounter method")
	}

	mmRegisterCounter.mock.funcRegisterCounter = f
	mmRegisterCounter.mock.funcRegisterCounterOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter.mock
}

// When sets expectation for the Storage.RegisterCounter which will trigger the result defined by the following
// Then helper
func (mmRegisterCounter *mStorageMockRegisterCounter) When(metric string, labels map[string]string) *StorageMockRegisterCounterExpectation {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("StorageMock.RegisterCounter mock is already set by Set")
	}

	expectation := &StorageMockRegisterCounterExpectation{
		mock:               mmRegisterCounter.mock,
		params:             &StorageMockRegisterCounterParams{metric, labels},
		expectationOrigins: StorageMockRegisterCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterCounter.expectations = append(mmRegisterCounter.expectations, expectation)
	return expectation
}

// Then sets up Storage.RegisterCounter return parameters for the expectation previously defined by the When method
func (e *StorageMockRegisterCounterExpectation) Then(cp1 *prometheus.CounterVec) *StorageMock {
	e.results = &StorageMockRegisterCounterResults{cp1}
	return e.mock
}

// Times sets number of times Storage.RegisterCounter should be invoked
func (mmRegisterCounter *mStorageMockRegisterCounter) Times(n uint64) *mStorageMockRegisterCounter {
	if n == 0 {
		mmRegisterCounter.mock.t.Fatalf("Times of StorageMock.RegisterCounter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterCounter.expectedInvocations, n)
	mmRegisterCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter
}

func (mmRegisterCounter *mStorageMockRegisterCounter) invocationsDone() bool {
	if len(mmRegisterCounter.expectations) == 0 && mmRegisterCounter.defaultExpectation == nil && mmRegisterCounter.mock.funcRegisterCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterCounter.mock.afterRegisterCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterCounter implements Storage
func (mmRegisterCounter *StorageMock) RegisterCounter(metric string, labels map[string]string) (cp1 *prometheus.CounterVec) {
	mm_atomic.AddUint64(&mmRegisterCounter.beforeRegisterCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterCounter.afterRegisterCounterCounter, 1)

	mmRegisterCounter.t.Helper()

	if mmRegisterCounter.inspectFuncRegisterCounter != nil {
		mmRegisterCounter.inspectFuncRegisterCounter(metric, labels)
	}

	mm_params := StorageMockRegisterCounterParams{metric, labels}

	// Record call args
	mmRegisterCounter.RegisterCounterMock.mutex.Lock()
	mmRegisterCounter.RegisterCounterMock.callArgs = append(mmRegisterCounter.RegisterCounterMock.callArgs, &mm_params)
	mmRegisterCounter.RegisterCounterMock.mutex.Unlock()

	for _, e := range mmRegisterCounter.RegisterCounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1
		}
	}

	if mmRegisterCounter.RegisterCounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterCounter.RegisterCounterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterCounter.RegisterCounterMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterCounter.RegisterCounterMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRegisterCounterParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterCounter.t.Errorf("StorageMock.RegisterCounter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterCounter.RegisterCounterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterCounter.t.Fatal("No results are set for the StorageMock.RegisterCounter")
		}
		return (*mm_results).cp1
	}
	if mmRegisterCounter.funcRegisterCounter != nil {
		return mmRegisterCounter.funcRegisterCounter(metric, labels)
	}
	mmRegisterCounter.t.Fatalf("Unexpected call to StorageMock.RegisterCounter. %v %v", metric, labels)
	return
}

// RegisterCounterAfterCounter returns a count of finished StorageMock.RegisterCounter invocations
func (mmRegisterCounter *StorageMock) RegisterCounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCounter.afterRegisterCounterCounter)
}

// RegisterCounterBeforeCounter returns a count of StorageMock.RegisterCounter invocations
func (mmRegisterCounter *StorageMock) RegisterCounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCounter.beforeRegisterCounterCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RegisterCounter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterCounter *mStorageMockRegisterCounter) Calls() []*StorageMockRegisterCounterParams {
	mmRegisterCounter.mutex.RLock()

	argCopy := make([]*StorageMockRegisterCounterParams, len(mmRegisterCounter.callArgs))
	copy(argCopy, mmRegisterCounter.callArgs)

	mmRegisterCounter.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterCounterDone returns true if the count of the RegisterCounter invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRegisterCounterDone() bool {
	if m.RegisterCounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterCounterMock.invocationsDone()
}

// MinimockRegisterCounterInspect logs each unmet expectation
func (m *StorageMock) MinimockRegisterCounterInspect() {
	for _, e := range m.RegisterCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterCounterCounter := mm_atomic.LoadUint64(&m.afterRegisterCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterCounterMock.defaultExpectation != nil && afterRegisterCounterCounter < 1 {
		if m.RegisterCounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s", m.RegisterCounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s with params: %#v", m.RegisterCounterMock.defaultExpectation.expectationOrigins.origin, *m.RegisterCounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterCounter != nil && afterRegisterCounterCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RegisterCounter at\n%s", m.funcRegisterCounterOrigin)
	}

	if !m.RegisterCounterMock.invocationsDone() && afterRegisterCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RegisterCounter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterCounterMock.expectedInvocations), m.RegisterCounterMock.expectedInvocationsOrigin, afterRegisterCounterCounter)
	}
}

type mStorageMockRegisterGauge struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRegisterGaugeExpectation
	expectations       []*StorageMockRegisterGaugeExpectation

	callArgs []*StorageMockRegisterGaugeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRegisterGaugeExpectation specifies expectation struct of the Storage.RegisterGauge
type StorageMockRegisterGaugeExpectation struct {
	mock               *StorageMock
	params             *StorageMockRegisterGaugeParams
	paramPtrs          *StorageMockRegisterGaugeParamPtrs
	expectationOrigins StorageMockRegisterGaugeExpectationOrigins
	results            *StorageMockRegisterGaugeResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRegisterGaugeParams contains parameters of the Storage.RegisterGauge
type StorageMockRegisterGaugeParams struct {
	metric string
	labels map[string]string
}

// StorageMockRegisterGaugeParamPtrs contains pointers to parameters of the Storage.RegisterGauge
type StorageMockRegisterGaugeParamPtrs struct {
	metric *string
	labels *map[string]string
}

// StorageMockRegisterGaugeResults contains results of the Storage.RegisterGauge
type StorageMockRegisterGaugeResults struct {
	gp1 *prometheus.GaugeVec
}

// StorageMockRegisterGaugeOrigins contains origins of expectations of the Storage.RegisterGauge
type StorageMockRegisterGaugeExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterGauge *mStorageMockRegisterGauge) Optional() *mStorageMockRegisterGauge {
	mmRegisterGauge.optional = true
	return mmRegisterGauge
}

// Expect sets up expected params for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) Expect(metric string, labels map[string]string) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by ExpectParams functions")
	}

	mmRegisterGauge.defaultExpectation.params = &StorageMockRegisterGaugeParams{metric, labels}
	mmRegisterGauge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterGauge.expectations {
		if minimock.Equal(e.params, mmRegisterGauge.defaultExpectation.params) {
			mmRegisterGauge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterGauge.defaultExpectation.params)
		}
	}

	return mmRegisterGauge
}

// ExpectMetricParam1 sets up expected param metric for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) ExpectMetricParam1(metric string) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.params != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Expect")
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs == nil {
		mmRegisterGauge.defaultExpectation.paramPtrs = &StorageMockRegisterGaugeParamPtrs{}
	}
	mmRegisterGauge.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterGauge.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterGauge
}

// ExpectLabelsParam2 sets up expected param labels for Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) ExpectLabelsParam2(labels map[string]string) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.params != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Expect")
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs == nil {
		mmRegisterGauge.defaultExpectation.paramPtrs = &StorageMockRegisterGaugeParamPtrs{}
	}
	mmRegisterGauge.defaultExpectation.paramPtrs.labels = &labels
	mmRegisterGauge.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmRegisterGauge
}

// Inspect accepts an inspector function that has same arguments as the Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) Inspect(f func(metric string, labels map[string]string)) *mStorageMockRegisterGauge {
	if mmRegisterGauge.mock.inspectFuncRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("Inspect function is already set for StorageMock.RegisterGauge")
	}

	mmRegisterGauge.mock.inspectFuncRegisterGauge = f

	return mmRegisterGauge
}

// Return sets up results that will be returned by Storage.RegisterGauge
func (mmRegisterGauge *mStorageMockRegisterGauge) Return(gp1 *prometheus.GaugeVec) *StorageMock {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &StorageMockRegisterGaugeExpectation{mock: mmRegisterGauge.mock}
	}
	mmRegisterGauge.defaultExpectation.results = &StorageMockRegisterGaugeResults{gp1}
	mmRegisterGauge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge.mock
}

// Set uses given function f to mock the Storage.RegisterGauge method
func (mmRegisterGauge *mStorageMockRegisterGauge) Set(f func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)) *StorageMock {
	if mmRegisterGauge.defaultExpectation != nil {
		mmRegisterGauge.mock.t.Fatalf("Default expectation is already set for the Storage.RegisterGauge method")
	}

	if len(mmRegisterGauge.expectations) > 0 {
		mmRegisterGauge.mock.t.Fatalf("Some expectations are already set for the Storage.RegisterGauge method")
	}

	mmRegisterGauge.mock.funcRegisterGauge = f
	mmRegisterGauge.mock.funcRegisterGaugeOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge.mock
}

// When sets expectation for the Storage.RegisterGauge which will trigger the result defined by the following
// Then helper
func (mmRegisterGauge *mStorageMockRegisterGauge) When(metric string, labels map[string]string) *StorageMockRegisterGaugeExpectation {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("StorageMock.RegisterGauge mock is already set by Set")
	}

	expectation := &StorageMockRegisterGaugeExpectation{
		mock:               mmRegisterGauge.mock,
		params:             &StorageMockRegisterGaugeParams{metric, labels},
		expectationOrigins: StorageMockRegisterGaugeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterGauge.expectations = append(mmRegisterGauge.expectations, expectation)
	return expectation
}

// Then sets up Storage.RegisterGauge return parameters for the expectation previously defined by the When method
func (e *StorageMockRegisterGaugeExpectation) Then(gp1 *prometheus.GaugeVec) *StorageMock {
	e.results = &StorageMockRegisterGaugeResults{gp1}
	return e.mock
}

// Times sets number of times Storage.RegisterGauge should be invoked
func (mmRegisterGauge *mStorageMockRegisterGauge) Times(n uint64) *mStorageMockRegisterGauge {
	if n == 0 {
		mmRegisterGauge.mock.t.Fatalf("Times of StorageMock.RegisterGauge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterGauge.expectedInvocations, n)
	mmRegisterGauge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge
}

func (mmRegisterGauge *mStorageMockRegisterGauge) invocationsDone() bool {
	if len(mmRegisterGauge.expectations) == 0 && mmRegisterGauge.defaultExpectation == nil && mmRegisterGauge.mock.funcRegisterGauge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterGauge.mock.afterRegisterGaugeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterGauge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterGauge implements Storage
func (mmRegisterGauge *StorageMock) RegisterGauge(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec) {
	mm_atomic.AddUint64(&mmRegisterGauge.beforeRegisterGaugeCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterGauge.afterRegisterGaugeCounter, 1)

	mmRegisterGauge.t.Helper()

	if mmRegisterGauge.inspectFuncRegisterGauge != nil {
		mmRegisterGauge.inspectFuncRegisterGauge(metric, labels)
	}

	mm_params := StorageMockRegisterGaugeParams{metric, labels}

	// Record call args
	mmRegisterGauge.RegisterGaugeMock.mutex.Lock()
	mmRegisterGauge.RegisterGaugeMock.callArgs = append(mmRegisterGauge.RegisterGaugeMock.callArgs, &mm_params)
	mmRegisterGauge.RegisterGaugeMock.mutex.Unlock()

	for _, e := range mmRegisterGauge.RegisterGaugeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1
		}
	}

	if mmRegisterGauge.RegisterGaugeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterGauge.RegisterGaugeMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRegisterGaugeParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterGauge.t.Errorf("StorageMock.RegisterGauge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterGauge.t.Fatal("No results are set for the StorageMock.RegisterGauge")
		}
		return (*mm_results).gp1
	}
	if mmRegisterGauge.funcRegisterGauge != nil {
		return mmRegisterGauge.funcRegisterGauge(metric, labels)
	}
	mmRegisterGauge.t.Fatalf("Unexpected call to StorageMock.RegisterGauge. %v %v", metric, labels)
	return
}

// RegisterGaugeAfterCounter returns a count of finished StorageMock.RegisterGauge invocations
func (mmRegisterGauge *StorageMock) RegisterGaugeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterGauge.afterRegisterGaugeCounter)
}

// RegisterGaugeBeforeCounter returns a count of StorageMock.RegisterGauge invocations
func (mmRegisterGauge *StorageMock) RegisterGaugeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterGauge.beforeRegisterGaugeCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RegisterGauge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterGauge *mStorageMockRegisterGauge) Calls() []*StorageMockRegisterGaugeParams {
	mmRegisterGauge.mutex.RLock()

	argCopy := make([]*StorageMockRegisterGaugeParams, len(mmRegisterGauge.callArgs))
	copy(argCopy, mmRegisterGauge.callArgs)

	mmRegisterGauge.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterGaugeDone returns true if the count of the RegisterGauge invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRegisterGaugeDone() bool {
	if m.RegisterGaugeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterGaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterGaugeMock.invocationsDone()
}

// MinimockRegisterGaugeInspect logs each unmet expectation
func (m *StorageMock) MinimockRegisterGaugeInspect() {
	for _, e := range m.RegisterGaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterGaugeCounter := mm_atomic.LoadUint64(&m.afterRegisterGaugeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterGaugeMock.defaultExpectation != nil && afterRegisterGaugeCounter < 1 {
		if m.RegisterGaugeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s", m.RegisterGaugeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s with params: %#v", m.RegisterGaugeMock.defaultExpectation.expectationOrigins.origin, *m.RegisterGaugeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterGauge != nil && afterRegisterGaugeCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RegisterGauge at\n%s", m.funcRegisterGaugeOrigin)
	}

	if !m.RegisterGaugeMock.invocationsDone() && afterRegisterGaugeCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RegisterGauge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterGaugeMock.expectedInvocations), m.RegisterGaugeMock.expectedInvocationsOrigin, afterRegisterGaugeCounter)
	}
}

type mStorageMockRegisterHistogram struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockRegisterHistogramExpectation
	expectations       []*StorageMockRegisterHistogramExpectation

	callArgs []*StorageMockRegisterHistogramParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockRegisterHistogramExpectation specifies expectation struct of the Storage.RegisterHistogram
type StorageMockRegisterHistogramExpectation struct {
	mock               *StorageMock
	params             *StorageMockRegisterHistogramParams
	paramPtrs          *StorageMockRegisterHistogramParamPtrs
	expectationOrigins StorageMockRegisterHistogramExpectationOrigins
	results            *StorageMockRegisterHistogramResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockRegisterHistogramParams contains parameters of the Storage.RegisterHistogram
type StorageMockRegisterHistogramParams struct {
	metric  string
	labels  map[string]string
	buckets []float64
}

// StorageMockRegisterHistogramParamPtrs contains pointers to parameters of the Storage.RegisterHistogram
type StorageMockRegisterHistogramParamPtrs struct {
	metric  *string
	labels  *map[string]string
	buckets *[]float64
}

// StorageMockRegisterHistogramResults contains results of the Storage.RegisterHistogram
type StorageMockRegisterHistogramResults struct {
	hp1 *prometheus.HistogramVec
}

// StorageMockRegisterHistogramOrigins contains origins of expectations of the Storage.RegisterHistogram
type StorageMockRegisterHistogramExpectationOrigins struct {
	origin        string
	originMetric  string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Optional() *mStorageMockRegisterHistogram {
	mmRegisterHistogram.optional = true
	return mmRegisterHistogram
}

// Expect sets up expected params for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Expect(metric string, labels map[string]string, buckets []float64) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by ExpectParams functions")
	}

	mmRegisterHistogram.defaultExpectation.params = &StorageMockRegisterHistogramParams{metric, labels, buckets}
	mmRegisterHistogram.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterHistogram.expectations {
		if minimock.Equal(e.params, mmRegisterHistogram.defaultExpectation.params) {
			mmRegisterHistogram.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterHistogram.defaultExpectation.params)
		}
	}

	return mmRegisterHistogram
}

// ExpectMetricParam1 sets up expected param metric for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectMetricParam1(metric string) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// ExpectLabelsParam2 sets up expected param labels for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectLabelsParam2(labels map[string]string) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.labels = &labels
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// ExpectBucketsParam3 sets up expected param buckets for Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) ExpectBucketsParam3(buckets []float64) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &StorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.buckets = &buckets
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// Inspect accepts an inspector function that has same arguments as the Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Inspect(f func(metric string, labels map[string]string, buckets []float64)) *mStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.inspectFuncRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("Inspect function is already set for StorageMock.RegisterHistogram")
	}

	mmRegisterHistogram.mock.inspectFuncRegisterHistogram = f

	return mmRegisterHistogram
}

// Return sets up results that will be returned by Storage.RegisterHistogram
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Return(hp1 *prometheus.HistogramVec) *StorageMock {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &StorageMockRegisterHistogramExpectation{mock: mmRegisterHistogram.mock}
	}
	mmRegisterHistogram.defaultExpectation.results = &StorageMockRegisterHistogramResults{hp1}
	mmRegisterHistogram.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram.mock
}

// Set uses given function f to mock the Storage.RegisterHistogram method
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Set(f func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)) *StorageMock {
	if mmRegisterHistogram.defaultExpectation != nil {
		mmRegisterHistogram.mock.t.Fatalf("Default expectation is already set for the Storage.RegisterHistogram method")
	}

	if len(mmRegisterHistogram.expectations) > 0 {
		mmRegisterHistogram.mock.t.Fatalf("Some expectations are already set for the Storage.RegisterHistogram method")
	}

	mmRegisterHistogram.mock.funcRegisterHistogram = f
	mmRegisterHistogram.mock.funcRegisterHistogramOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram.mock
}

// When sets expectation for the Storage.RegisterHistogram which will trigger the result defined by the following
// Then helper
func (mmRegisterHistogram *mStorageMockRegisterHistogram) When(metric string, labels map[string]string, buckets []float64) *StorageMockRegisterHistogramExpectation {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("StorageMock.RegisterHistogram mock is already set by Set")
	}

	expectation := &StorageMockRegisterHistogramExpectation{
		mock:               mmRegisterHistogram.mock,
		params:             &StorageMockRegisterHistogramParams{metric, labels, buckets},
		expectationOrigins: StorageMockRegisterHistogramExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterHistogram.expectations = append(mmRegisterHistogram.expectations, expectation)
	return expectation
}

// Then sets up Storage.RegisterHistogram return parameters for the expectation previously defined by the When method
func (e *StorageMockRegisterHistogramExpectation) Then(hp1 *prometheus.HistogramVec) *StorageMock {
	e.results = &StorageMockRegisterHistogramResults{hp1}
	return e.mock
}

// Times sets number of times Storage.RegisterHistogram should be invoked
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Times(n uint64) *mStorageMockRegisterHistogram {
	if n == 0 {
		mmRegisterHistogram.mock.t.Fatalf("Times of StorageMock.RegisterHistogram mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterHistogram.expectedInvocations, n)
	mmRegisterHistogram.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram
}

func (mmRegisterHistogram *mStorageMockRegisterHistogram) invocationsDone() bool {
	if len(mmRegisterHistogram.expectations) == 0 && mmRegisterHistogram.defaultExpectation == nil && mmRegisterHistogram.mock.funcRegisterHistogram == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterHistogram.mock.afterRegisterHistogramCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterHistogram.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterHistogram implements Storage
func (mmRegisterHistogram *StorageMock) RegisterHistogram(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec) {
	mm_atomic.AddUint64(&mmRegisterHistogram.beforeRegisterHistogramCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterHistogram.afterRegisterHistogramCounter, 1)

	mmRegisterHistogram.t.Helper()

	if mmRegisterHistogram.inspectFuncRegisterHistogram != nil {
		mmRegisterHistogram.inspectFuncRegisterHistogram(metric, labels, buckets)
	}

	mm_params := StorageMockRegisterHistogramParams{metric, labels, buckets}

	// Record call args
	mmRegisterHistogram.RegisterHistogramMock.mutex.Lock()
	mmRegisterHistogram.RegisterHistogramMock.callArgs = append(mmRegisterHistogram.RegisterHistogramMock.callArgs, &mm_params)
	mmRegisterHistogram.RegisterHistogramMock.mutex.Unlock()

	for _, e := range mmRegisterHistogram.RegisterHistogramMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1
		}
	}

	if mmRegisterHistogram.RegisterHistogramMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.paramPtrs

		mm_got := StorageMockRegisterHistogramParams{metric, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterHistogram.t.Errorf("StorageMock.RegisterHistogram got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterHistogram.t.Fatal("No results are set for the StorageMock.RegisterHistogram")
		}
		return (*mm_results).hp1
	}
	if mmRegisterHistogram.funcRegisterHistogram != nil {
		return mmRegisterHistogram.funcRegisterHistogram(metric, labels, buckets)
	}
	mmRegisterHistogram.t.Fatalf("Unexpected call to StorageMock.RegisterHistogram. %v %v %v", metric, labels, buckets)
	return
}

// RegisterHistogramAfterCounter returns a count of finished StorageMock.RegisterHistogram invocations
func (mmRegisterHistogram *StorageMock) RegisterHistogramAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterHistogram.afterRegisterHistogramCounter)
}

// RegisterHistogramBeforeCounter returns a count of StorageMock.RegisterHistogram invocations
func (mmRegisterHistogram *StorageMock) RegisterHistogramBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterHistogram.beforeRegisterHistogramCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.RegisterHistogram.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterHistogram *mStorageMockRegisterHistogram) Calls() []*StorageMockRegisterHistogramParams {
	mmRegisterHistogram.mutex.RLock()

	argCopy := make([]*StorageMockRegisterHistogramParams, len(mmRegisterHistogram.callArgs))
	copy(argCopy, mmRegisterHistogram.callArgs)

	mmRegisterHistogram.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterHistogramDone returns true if the count of the RegisterHistogram invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockRegisterHistogramDone() bool {
	if m.RegisterHistogramMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterHistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterHistogramMock.invocationsDone()
}

// MinimockRegisterHistogramInspect logs each unmet expectation
func (m *StorageMock) MinimockRegisterHistogramInspect() {
	for _, e := range m.RegisterHistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterHistogramCounter := mm_atomic.LoadUint64(&m.afterRegisterHistogramCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterHistogramMock.defaultExpectation != nil && afterRegisterHistogramCounter < 1 {
		if m.RegisterHistogramMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s", m.RegisterHistogramMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s with params: %#v", m.RegisterHistogramMock.defaultExpectation.expectationOrigins.origin, *m.RegisterHistogramMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterHistogram != nil && afterRegisterHistogramCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.RegisterHistogram at\n%s", m.funcRegisterHistogramOrigin)
	}

	if !m.RegisterHistogramMock.invocationsDone() && afterRegisterHistogramCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.RegisterHistogram at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterHistogramMock.expectedInvocations), m.RegisterHistogramMock.expectedInvocationsOrigin, afterRegisterHistogramCounter)
	}
}

type mStorageMockSendBatch struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockSendBatchExpectation
	expectations       []*StorageMockSendBatchExpectation

	callArgs []*StorageMockSendBatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockSendBatchExpectation specifies expectation struct of the Storage.SendBatch
type StorageMockSendBatchExpectation struct {
	mock               *StorageMock
	params             *StorageMockSendBatchParams
	paramPtrs          *StorageMockSendBatchParamPtrs
	expectationOrigins StorageMockSendBatchExpectationOrigins
	results            *StorageMockSendBatchResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockSendBatchParams contains parameters of the Storage.SendBatch
type StorageMockSendBatchParams struct {
	ops    []operation.MetricOperation
	labels map[string]string
}

// StorageMockSendBatchParamPtrs contains pointers to parameters of the Storage.SendBatch
type StorageMockSendBatchParamPtrs struct {
	ops    *[]operation.MetricOperation
	labels *map[string]string
}

// StorageMockSendBatchResults contains results of the Storage.SendBatch
type StorageMockSendBatchResults struct {
	err error
}

// StorageMockSendBatchOrigins contains origins of expectations of the Storage.SendBatch
type StorageMockSendBatchExpectationOrigins struct {
	origin       string
	originOps    string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendBatch *mStorageMockSendBatch) Optional() *mStorageMockSendBatch {
	mmSendBatch.optional = true
	return mmSendBatch
}

// Expect sets up expected params for Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) Expect(ops []operation.MetricOperation, labels map[string]string) *mStorageMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &StorageMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.paramPtrs != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by ExpectParams functions")
	}

	mmSendBatch.defaultExpectation.params = &StorageMockSendBatchParams{ops, labels}
	mmSendBatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// ExpectOpsParam1 sets up expected param ops for Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) ExpectOpsParam1(ops []operation.MetricOperation) *mStorageMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &StorageMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &StorageMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.ops = &ops
	mmSendBatch.defaultExpectation.expectationOrigins.originOps = minimock.CallerInfo(1)

	return mmSendBatch
}

// ExpectLabelsParam2 sets up expected param labels for Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) ExpectLabelsParam2(labels map[string]string) *mStorageMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &StorageMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &StorageMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.labels = &labels
	mmSendBatch.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) Inspect(f func(ops []operation.MetricOperation, labels map[string]string)) *mStorageMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for StorageMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by Storage.SendBatch
func (mmSendBatch *mStorageMockSendBatch) Return(err error) *StorageMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &StorageMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &StorageMockSendBatchResults{err}
	mmSendBatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// Set uses given function f to mock the Storage.SendBatch method
func (mmSendBatch *mStorageMockSendBatch) Set(f func(ops []operation.MetricOperation, labels map[string]string) (err error)) *StorageMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the Storage.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the Storage.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	mmSendBatch.mock.funcSendBatchOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// When sets expectation for the Storage.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mStorageMockSendBatch) When(ops []operation.MetricOperation, labels map[string]string) *StorageMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("StorageMock.SendBatch mock is already set by Set")
	}

	expectation := &StorageMockSendBatchExpectation{
		mock:               mmSendBatch.mock,
		params:             &StorageMockSendBatchParams{ops, labels},
		expectationOrigins: StorageMockSendBatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up Storage.SendBatch return parameters for the expectation previously defined by the When method
func (e *StorageMockSendBatchExpectation) Then(err error) *StorageMock {
	e.results = &StorageMockSendBatchResults{err}
	return e.mock
}

// Times sets number of times Storage.SendBatch should be invoked
func (mmSendBatch *mStorageMockSendBatch) Times(n uint64) *mStorageMockSendBatch {
	if n == 0 {
		mmSendBatch.mock.t.Fatalf("Times of StorageMock.SendBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendBatch.expectedInvocations, n)
	mmSendBatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendBatch
}

func (mmSendBatch *mStorageMockSendBatch) invocationsDone() bool {
	if len(mmSendBatch.expectations) == 0 && mmSendBatch.defaultExpectation == nil && mmSendBatch.mock.funcSendBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendBatch.mock.afterSendBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendBatch implements Storage
func (mmSendBatch *StorageMock) SendBatch(ops []operation.MetricOperation, labels map[string]string) (err error) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	mmSendBatch.t.Helper()

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ops, labels)
	}

	mm_params := StorageMockSendBatchParams{ops, labels}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, &mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_want_ptrs := mmSendBatch.SendBatchMock.defaultExpectation.paramPtrs

		mm_got := StorageMockSendBatchParams{ops, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ops != nil && !minimock.Equal(*mm_want_ptrs.ops, mm_got.ops) {
				mmSendBatch.t.Errorf("StorageMock.SendBatch got unexpected parameter ops, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originOps, *mm_want_ptrs.ops, mm_got.ops, minimock.Diff(*mm_want_ptrs.ops, mm_got.ops))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmSendBatch.t.Errorf("StorageMock.SendBatch got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("StorageMock.SendBatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the StorageMock.SendBatch")
		}
		return (*mm_results).err
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ops, labels)
	}
	mmSendBatch.t.Fatalf("Unexpected call to StorageMock.SendBatch. %v %v", ops, labels)
	return
}

// SendBatchAfterCounter returns a count of finished StorageMock.SendBatch invocations
func (mmSendBatch *StorageMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of StorageMock.SendBatch invocations
func (mmSendBatch *StorageMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mStorageMockSendBatch) Calls() []*StorageMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*StorageMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockSendBatchDone() bool {
	if m.SendBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendBatchMock.invocationsDone()
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *StorageMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.SendBatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendBatchCounter := mm_atomic.LoadUint64(&m.afterSendBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && afterSendBatchCounter < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.SendBatch at\n%s", m.SendBatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.SendBatch at\n%s with params: %#v", m.SendBatchMock.defaultExpectation.expectationOrigins.origin, *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && afterSendBatchCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.SendBatch at\n%s", m.funcSendBatchOrigin)
	}

	if !m.SendBatchMock.invocationsDone() && afterSendBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.SendBatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendBatchMock.expectedInvocations), m.SendBatchMock.expectedInvocationsOrigin, afterSendBatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockApplyOperationInspect()

			m.MinimockCounterInspect()

			m.MinimockCounterAddInspect()

			m.MinimockGaugeInspect()

			m.MinimockGaugeAddInspect()

			m.MinimockGaugeSetInspect()

			m.MinimockGroupedInspect()

			m.MinimockHistogramInspect()

			m.MinimockHistogramObserveInspect()

			m.MinimockRegisterCounterInspect()

			m.MinimockRegisterGaugeInspect()

			m.MinimockRegisterHistogramInspect()

			m.MinimockSendBatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockApplyOperationDone() &&
		m.MinimockCounterDone() &&
		m.MinimockCounterAddDone() &&
		m.MinimockGaugeDone() &&
		m.MinimockGaugeAddDone() &&
		m.MinimockGaugeSetDone() &&
		m.MinimockGroupedDone() &&
		m.MinimockHistogramDone() &&
		m.MinimockHistogramObserveDone() &&
		m.MinimockRegisterCounterDone() &&
		m.MinimockRegisterGaugeDone() &&
		m.MinimockRegisterHistogramDone() &&
		m.MinimockSendBatchDone()
}
