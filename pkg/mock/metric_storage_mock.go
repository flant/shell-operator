// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package mock

//go:generate minimock -i github.com/flant/shell-operator/pkg.MetricStorage -o metric_storage_mock.go -n MetricStorageMock -p mock

import (
	"net/http"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/flant/shell-operator/pkg/metric"
	"github.com/flant/shell-operator/pkg/metric_storage/operation"
	"github.com/gojuno/minimock/v3"
	"github.com/prometheus/client_golang/prometheus"
)

// MetricStorageMock implements mm_pkg.MetricStorage
type MetricStorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcApplyOperation          func(op operation.MetricOperation, commonLabels map[string]string)
	funcApplyOperationOrigin    string
	inspectFuncApplyOperation   func(op operation.MetricOperation, commonLabels map[string]string)
	afterApplyOperationCounter  uint64
	beforeApplyOperationCounter uint64
	ApplyOperationMock          mMetricStorageMockApplyOperation

	funcCounter          func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)
	funcCounterOrigin    string
	inspectFuncCounter   func(metric string, labels map[string]string)
	afterCounterCounter  uint64
	beforeCounterCounter uint64
	CounterMock          mMetricStorageMockCounter

	funcCounterAdd          func(metric string, value float64, labels map[string]string)
	funcCounterAddOrigin    string
	inspectFuncCounterAdd   func(metric string, value float64, labels map[string]string)
	afterCounterAddCounter  uint64
	beforeCounterAddCounter uint64
	CounterAddMock          mMetricStorageMockCounterAdd

	funcGauge          func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)
	funcGaugeOrigin    string
	inspectFuncGauge   func(metric string, labels map[string]string)
	afterGaugeCounter  uint64
	beforeGaugeCounter uint64
	GaugeMock          mMetricStorageMockGauge

	funcGaugeAdd          func(metric string, value float64, labels map[string]string)
	funcGaugeAddOrigin    string
	inspectFuncGaugeAdd   func(metric string, value float64, labels map[string]string)
	afterGaugeAddCounter  uint64
	beforeGaugeAddCounter uint64
	GaugeAddMock          mMetricStorageMockGaugeAdd

	funcGaugeSet          func(metric string, value float64, labels map[string]string)
	funcGaugeSetOrigin    string
	inspectFuncGaugeSet   func(metric string, value float64, labels map[string]string)
	afterGaugeSetCounter  uint64
	beforeGaugeSetCounter uint64
	GaugeSetMock          mMetricStorageMockGaugeSet

	funcGrouped          func() (g1 metric.GroupedStorage)
	funcGroupedOrigin    string
	inspectFuncGrouped   func()
	afterGroupedCounter  uint64
	beforeGroupedCounter uint64
	GroupedMock          mMetricStorageMockGrouped

	funcHandler          func() (h1 http.Handler)
	funcHandlerOrigin    string
	inspectFuncHandler   func()
	afterHandlerCounter  uint64
	beforeHandlerCounter uint64
	HandlerMock          mMetricStorageMockHandler

	funcHistogram          func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)
	funcHistogramOrigin    string
	inspectFuncHistogram   func(metric string, labels map[string]string, buckets []float64)
	afterHistogramCounter  uint64
	beforeHistogramCounter uint64
	HistogramMock          mMetricStorageMockHistogram

	funcHistogramObserve          func(metric string, value float64, labels map[string]string, buckets []float64)
	funcHistogramObserveOrigin    string
	inspectFuncHistogramObserve   func(metric string, value float64, labels map[string]string, buckets []float64)
	afterHistogramObserveCounter  uint64
	beforeHistogramObserveCounter uint64
	HistogramObserveMock          mMetricStorageMockHistogramObserve

	funcRegisterCounter          func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)
	funcRegisterCounterOrigin    string
	inspectFuncRegisterCounter   func(metric string, labels map[string]string)
	afterRegisterCounterCounter  uint64
	beforeRegisterCounterCounter uint64
	RegisterCounterMock          mMetricStorageMockRegisterCounter

	funcRegisterGauge          func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)
	funcRegisterGaugeOrigin    string
	inspectFuncRegisterGauge   func(metric string, labels map[string]string)
	afterRegisterGaugeCounter  uint64
	beforeRegisterGaugeCounter uint64
	RegisterGaugeMock          mMetricStorageMockRegisterGauge

	funcRegisterHistogram          func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)
	funcRegisterHistogramOrigin    string
	inspectFuncRegisterHistogram   func(metric string, labels map[string]string, buckets []float64)
	afterRegisterHistogramCounter  uint64
	beforeRegisterHistogramCounter uint64
	RegisterHistogramMock          mMetricStorageMockRegisterHistogram

	funcSendBatch          func(ops []operation.MetricOperation, labels map[string]string) (err error)
	funcSendBatchOrigin    string
	inspectFuncSendBatch   func(ops []operation.MetricOperation, labels map[string]string)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mMetricStorageMockSendBatch
}

// NewMetricStorageMock returns a mock for mm_pkg.MetricStorage
func NewMetricStorageMock(t minimock.Tester) *MetricStorageMock {
	m := &MetricStorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ApplyOperationMock = mMetricStorageMockApplyOperation{mock: m}
	m.ApplyOperationMock.callArgs = []*MetricStorageMockApplyOperationParams{}

	m.CounterMock = mMetricStorageMockCounter{mock: m}
	m.CounterMock.callArgs = []*MetricStorageMockCounterParams{}

	m.CounterAddMock = mMetricStorageMockCounterAdd{mock: m}
	m.CounterAddMock.callArgs = []*MetricStorageMockCounterAddParams{}

	m.GaugeMock = mMetricStorageMockGauge{mock: m}
	m.GaugeMock.callArgs = []*MetricStorageMockGaugeParams{}

	m.GaugeAddMock = mMetricStorageMockGaugeAdd{mock: m}
	m.GaugeAddMock.callArgs = []*MetricStorageMockGaugeAddParams{}

	m.GaugeSetMock = mMetricStorageMockGaugeSet{mock: m}
	m.GaugeSetMock.callArgs = []*MetricStorageMockGaugeSetParams{}

	m.GroupedMock = mMetricStorageMockGrouped{mock: m}

	m.HandlerMock = mMetricStorageMockHandler{mock: m}

	m.HistogramMock = mMetricStorageMockHistogram{mock: m}
	m.HistogramMock.callArgs = []*MetricStorageMockHistogramParams{}

	m.HistogramObserveMock = mMetricStorageMockHistogramObserve{mock: m}
	m.HistogramObserveMock.callArgs = []*MetricStorageMockHistogramObserveParams{}

	m.RegisterCounterMock = mMetricStorageMockRegisterCounter{mock: m}
	m.RegisterCounterMock.callArgs = []*MetricStorageMockRegisterCounterParams{}

	m.RegisterGaugeMock = mMetricStorageMockRegisterGauge{mock: m}
	m.RegisterGaugeMock.callArgs = []*MetricStorageMockRegisterGaugeParams{}

	m.RegisterHistogramMock = mMetricStorageMockRegisterHistogram{mock: m}
	m.RegisterHistogramMock.callArgs = []*MetricStorageMockRegisterHistogramParams{}

	m.SendBatchMock = mMetricStorageMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*MetricStorageMockSendBatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMetricStorageMockApplyOperation struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockApplyOperationExpectation
	expectations       []*MetricStorageMockApplyOperationExpectation

	callArgs []*MetricStorageMockApplyOperationParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockApplyOperationExpectation specifies expectation struct of the MetricStorage.ApplyOperation
type MetricStorageMockApplyOperationExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockApplyOperationParams
	paramPtrs          *MetricStorageMockApplyOperationParamPtrs
	expectationOrigins MetricStorageMockApplyOperationExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// MetricStorageMockApplyOperationParams contains parameters of the MetricStorage.ApplyOperation
type MetricStorageMockApplyOperationParams struct {
	op           operation.MetricOperation
	commonLabels map[string]string
}

// MetricStorageMockApplyOperationParamPtrs contains pointers to parameters of the MetricStorage.ApplyOperation
type MetricStorageMockApplyOperationParamPtrs struct {
	op           *operation.MetricOperation
	commonLabels *map[string]string
}

// MetricStorageMockApplyOperationOrigins contains origins of expectations of the MetricStorage.ApplyOperation
type MetricStorageMockApplyOperationExpectationOrigins struct {
	origin             string
	originOp           string
	originCommonLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmApplyOperation *mMetricStorageMockApplyOperation) Optional() *mMetricStorageMockApplyOperation {
	mmApplyOperation.optional = true
	return mmApplyOperation
}

// Expect sets up expected params for MetricStorage.ApplyOperation
func (mmApplyOperation *mMetricStorageMockApplyOperation) Expect(op operation.MetricOperation, commonLabels map[string]string) *mMetricStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("MetricStorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &MetricStorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.paramPtrs != nil {
		mmApplyOperation.mock.t.Fatalf("MetricStorageMock.ApplyOperation mock is already set by ExpectParams functions")
	}

	mmApplyOperation.defaultExpectation.params = &MetricStorageMockApplyOperationParams{op, commonLabels}
	mmApplyOperation.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmApplyOperation.expectations {
		if minimock.Equal(e.params, mmApplyOperation.defaultExpectation.params) {
			mmApplyOperation.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmApplyOperation.defaultExpectation.params)
		}
	}

	return mmApplyOperation
}

// ExpectOpParam1 sets up expected param op for MetricStorage.ApplyOperation
func (mmApplyOperation *mMetricStorageMockApplyOperation) ExpectOpParam1(op operation.MetricOperation) *mMetricStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("MetricStorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &MetricStorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.params != nil {
		mmApplyOperation.mock.t.Fatalf("MetricStorageMock.ApplyOperation mock is already set by Expect")
	}

	if mmApplyOperation.defaultExpectation.paramPtrs == nil {
		mmApplyOperation.defaultExpectation.paramPtrs = &MetricStorageMockApplyOperationParamPtrs{}
	}
	mmApplyOperation.defaultExpectation.paramPtrs.op = &op
	mmApplyOperation.defaultExpectation.expectationOrigins.originOp = minimock.CallerInfo(1)

	return mmApplyOperation
}

// ExpectCommonLabelsParam2 sets up expected param commonLabels for MetricStorage.ApplyOperation
func (mmApplyOperation *mMetricStorageMockApplyOperation) ExpectCommonLabelsParam2(commonLabels map[string]string) *mMetricStorageMockApplyOperation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("MetricStorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &MetricStorageMockApplyOperationExpectation{}
	}

	if mmApplyOperation.defaultExpectation.params != nil {
		mmApplyOperation.mock.t.Fatalf("MetricStorageMock.ApplyOperation mock is already set by Expect")
	}

	if mmApplyOperation.defaultExpectation.paramPtrs == nil {
		mmApplyOperation.defaultExpectation.paramPtrs = &MetricStorageMockApplyOperationParamPtrs{}
	}
	mmApplyOperation.defaultExpectation.paramPtrs.commonLabels = &commonLabels
	mmApplyOperation.defaultExpectation.expectationOrigins.originCommonLabels = minimock.CallerInfo(1)

	return mmApplyOperation
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.ApplyOperation
func (mmApplyOperation *mMetricStorageMockApplyOperation) Inspect(f func(op operation.MetricOperation, commonLabels map[string]string)) *mMetricStorageMockApplyOperation {
	if mmApplyOperation.mock.inspectFuncApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.ApplyOperation")
	}

	mmApplyOperation.mock.inspectFuncApplyOperation = f

	return mmApplyOperation
}

// Return sets up results that will be returned by MetricStorage.ApplyOperation
func (mmApplyOperation *mMetricStorageMockApplyOperation) Return() *MetricStorageMock {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("MetricStorageMock.ApplyOperation mock is already set by Set")
	}

	if mmApplyOperation.defaultExpectation == nil {
		mmApplyOperation.defaultExpectation = &MetricStorageMockApplyOperationExpectation{mock: mmApplyOperation.mock}
	}

	mmApplyOperation.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmApplyOperation.mock
}

// Set uses given function f to mock the MetricStorage.ApplyOperation method
func (mmApplyOperation *mMetricStorageMockApplyOperation) Set(f func(op operation.MetricOperation, commonLabels map[string]string)) *MetricStorageMock {
	if mmApplyOperation.defaultExpectation != nil {
		mmApplyOperation.mock.t.Fatalf("Default expectation is already set for the MetricStorage.ApplyOperation method")
	}

	if len(mmApplyOperation.expectations) > 0 {
		mmApplyOperation.mock.t.Fatalf("Some expectations are already set for the MetricStorage.ApplyOperation method")
	}

	mmApplyOperation.mock.funcApplyOperation = f
	mmApplyOperation.mock.funcApplyOperationOrigin = minimock.CallerInfo(1)
	return mmApplyOperation.mock
}

// When sets expectation for the MetricStorage.ApplyOperation which will trigger the result defined by the following
// Then helper
func (mmApplyOperation *mMetricStorageMockApplyOperation) When(op operation.MetricOperation, commonLabels map[string]string) *MetricStorageMockApplyOperationExpectation {
	if mmApplyOperation.mock.funcApplyOperation != nil {
		mmApplyOperation.mock.t.Fatalf("MetricStorageMock.ApplyOperation mock is already set by Set")
	}

	expectation := &MetricStorageMockApplyOperationExpectation{
		mock:               mmApplyOperation.mock,
		params:             &MetricStorageMockApplyOperationParams{op, commonLabels},
		expectationOrigins: MetricStorageMockApplyOperationExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmApplyOperation.expectations = append(mmApplyOperation.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.ApplyOperation return parameters for the expectation previously defined by the When method

func (e *MetricStorageMockApplyOperationExpectation) Then() *MetricStorageMock {
	return e.mock
}

// Times sets number of times MetricStorage.ApplyOperation should be invoked
func (mmApplyOperation *mMetricStorageMockApplyOperation) Times(n uint64) *mMetricStorageMockApplyOperation {
	if n == 0 {
		mmApplyOperation.mock.t.Fatalf("Times of MetricStorageMock.ApplyOperation mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmApplyOperation.expectedInvocations, n)
	mmApplyOperation.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmApplyOperation
}

func (mmApplyOperation *mMetricStorageMockApplyOperation) invocationsDone() bool {
	if len(mmApplyOperation.expectations) == 0 && mmApplyOperation.defaultExpectation == nil && mmApplyOperation.mock.funcApplyOperation == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmApplyOperation.mock.afterApplyOperationCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmApplyOperation.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ApplyOperation implements mm_pkg.MetricStorage
func (mmApplyOperation *MetricStorageMock) ApplyOperation(op operation.MetricOperation, commonLabels map[string]string) {
	mm_atomic.AddUint64(&mmApplyOperation.beforeApplyOperationCounter, 1)
	defer mm_atomic.AddUint64(&mmApplyOperation.afterApplyOperationCounter, 1)

	mmApplyOperation.t.Helper()

	if mmApplyOperation.inspectFuncApplyOperation != nil {
		mmApplyOperation.inspectFuncApplyOperation(op, commonLabels)
	}

	mm_params := MetricStorageMockApplyOperationParams{op, commonLabels}

	// Record call args
	mmApplyOperation.ApplyOperationMock.mutex.Lock()
	mmApplyOperation.ApplyOperationMock.callArgs = append(mmApplyOperation.ApplyOperationMock.callArgs, &mm_params)
	mmApplyOperation.ApplyOperationMock.mutex.Unlock()

	for _, e := range mmApplyOperation.ApplyOperationMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmApplyOperation.ApplyOperationMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmApplyOperation.ApplyOperationMock.defaultExpectation.Counter, 1)
		mm_want := mmApplyOperation.ApplyOperationMock.defaultExpectation.params
		mm_want_ptrs := mmApplyOperation.ApplyOperationMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockApplyOperationParams{op, commonLabels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.op != nil && !minimock.Equal(*mm_want_ptrs.op, mm_got.op) {
				mmApplyOperation.t.Errorf("MetricStorageMock.ApplyOperation got unexpected parameter op, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.originOp, *mm_want_ptrs.op, mm_got.op, minimock.Diff(*mm_want_ptrs.op, mm_got.op))
			}

			if mm_want_ptrs.commonLabels != nil && !minimock.Equal(*mm_want_ptrs.commonLabels, mm_got.commonLabels) {
				mmApplyOperation.t.Errorf("MetricStorageMock.ApplyOperation got unexpected parameter commonLabels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.originCommonLabels, *mm_want_ptrs.commonLabels, mm_got.commonLabels, minimock.Diff(*mm_want_ptrs.commonLabels, mm_got.commonLabels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmApplyOperation.t.Errorf("MetricStorageMock.ApplyOperation got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmApplyOperation.ApplyOperationMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmApplyOperation.funcApplyOperation != nil {
		mmApplyOperation.funcApplyOperation(op, commonLabels)
		return
	}
	mmApplyOperation.t.Fatalf("Unexpected call to MetricStorageMock.ApplyOperation. %v %v", op, commonLabels)

}

// ApplyOperationAfterCounter returns a count of finished MetricStorageMock.ApplyOperation invocations
func (mmApplyOperation *MetricStorageMock) ApplyOperationAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOperation.afterApplyOperationCounter)
}

// ApplyOperationBeforeCounter returns a count of MetricStorageMock.ApplyOperation invocations
func (mmApplyOperation *MetricStorageMock) ApplyOperationBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmApplyOperation.beforeApplyOperationCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.ApplyOperation.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmApplyOperation *mMetricStorageMockApplyOperation) Calls() []*MetricStorageMockApplyOperationParams {
	mmApplyOperation.mutex.RLock()

	argCopy := make([]*MetricStorageMockApplyOperationParams, len(mmApplyOperation.callArgs))
	copy(argCopy, mmApplyOperation.callArgs)

	mmApplyOperation.mutex.RUnlock()

	return argCopy
}

// MinimockApplyOperationDone returns true if the count of the ApplyOperation invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockApplyOperationDone() bool {
	if m.ApplyOperationMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ApplyOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ApplyOperationMock.invocationsDone()
}

// MinimockApplyOperationInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockApplyOperationInspect() {
	for _, e := range m.ApplyOperationMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.ApplyOperation at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterApplyOperationCounter := mm_atomic.LoadUint64(&m.afterApplyOperationCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ApplyOperationMock.defaultExpectation != nil && afterApplyOperationCounter < 1 {
		if m.ApplyOperationMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.ApplyOperation at\n%s", m.ApplyOperationMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.ApplyOperation at\n%s with params: %#v", m.ApplyOperationMock.defaultExpectation.expectationOrigins.origin, *m.ApplyOperationMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcApplyOperation != nil && afterApplyOperationCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.ApplyOperation at\n%s", m.funcApplyOperationOrigin)
	}

	if !m.ApplyOperationMock.invocationsDone() && afterApplyOperationCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.ApplyOperation at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ApplyOperationMock.expectedInvocations), m.ApplyOperationMock.expectedInvocationsOrigin, afterApplyOperationCounter)
	}
}

type mMetricStorageMockCounter struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockCounterExpectation
	expectations       []*MetricStorageMockCounterExpectation

	callArgs []*MetricStorageMockCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockCounterExpectation specifies expectation struct of the MetricStorage.Counter
type MetricStorageMockCounterExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockCounterParams
	paramPtrs          *MetricStorageMockCounterParamPtrs
	expectationOrigins MetricStorageMockCounterExpectationOrigins
	results            *MetricStorageMockCounterResults
	returnOrigin       string
	Counter            uint64
}

// MetricStorageMockCounterParams contains parameters of the MetricStorage.Counter
type MetricStorageMockCounterParams struct {
	metric string
	labels map[string]string
}

// MetricStorageMockCounterParamPtrs contains pointers to parameters of the MetricStorage.Counter
type MetricStorageMockCounterParamPtrs struct {
	metric *string
	labels *map[string]string
}

// MetricStorageMockCounterResults contains results of the MetricStorage.Counter
type MetricStorageMockCounterResults struct {
	cp1 *prometheus.CounterVec
}

// MetricStorageMockCounterOrigins contains origins of expectations of the MetricStorage.Counter
type MetricStorageMockCounterExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounter *mMetricStorageMockCounter) Optional() *mMetricStorageMockCounter {
	mmCounter.optional = true
	return mmCounter
}

// Expect sets up expected params for MetricStorage.Counter
func (mmCounter *mMetricStorageMockCounter) Expect(metric string, labels map[string]string) *mMetricStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("MetricStorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &MetricStorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.paramPtrs != nil {
		mmCounter.mock.t.Fatalf("MetricStorageMock.Counter mock is already set by ExpectParams functions")
	}

	mmCounter.defaultExpectation.params = &MetricStorageMockCounterParams{metric, labels}
	mmCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounter.expectations {
		if minimock.Equal(e.params, mmCounter.defaultExpectation.params) {
			mmCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounter.defaultExpectation.params)
		}
	}

	return mmCounter
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.Counter
func (mmCounter *mMetricStorageMockCounter) ExpectMetricParam1(metric string) *mMetricStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("MetricStorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &MetricStorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.params != nil {
		mmCounter.mock.t.Fatalf("MetricStorageMock.Counter mock is already set by Expect")
	}

	if mmCounter.defaultExpectation.paramPtrs == nil {
		mmCounter.defaultExpectation.paramPtrs = &MetricStorageMockCounterParamPtrs{}
	}
	mmCounter.defaultExpectation.paramPtrs.metric = &metric
	mmCounter.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmCounter
}

// ExpectLabelsParam2 sets up expected param labels for MetricStorage.Counter
func (mmCounter *mMetricStorageMockCounter) ExpectLabelsParam2(labels map[string]string) *mMetricStorageMockCounter {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("MetricStorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &MetricStorageMockCounterExpectation{}
	}

	if mmCounter.defaultExpectation.params != nil {
		mmCounter.mock.t.Fatalf("MetricStorageMock.Counter mock is already set by Expect")
	}

	if mmCounter.defaultExpectation.paramPtrs == nil {
		mmCounter.defaultExpectation.paramPtrs = &MetricStorageMockCounterParamPtrs{}
	}
	mmCounter.defaultExpectation.paramPtrs.labels = &labels
	mmCounter.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounter
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.Counter
func (mmCounter *mMetricStorageMockCounter) Inspect(f func(metric string, labels map[string]string)) *mMetricStorageMockCounter {
	if mmCounter.mock.inspectFuncCounter != nil {
		mmCounter.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.Counter")
	}

	mmCounter.mock.inspectFuncCounter = f

	return mmCounter
}

// Return sets up results that will be returned by MetricStorage.Counter
func (mmCounter *mMetricStorageMockCounter) Return(cp1 *prometheus.CounterVec) *MetricStorageMock {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("MetricStorageMock.Counter mock is already set by Set")
	}

	if mmCounter.defaultExpectation == nil {
		mmCounter.defaultExpectation = &MetricStorageMockCounterExpectation{mock: mmCounter.mock}
	}
	mmCounter.defaultExpectation.results = &MetricStorageMockCounterResults{cp1}
	mmCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounter.mock
}

// Set uses given function f to mock the MetricStorage.Counter method
func (mmCounter *mMetricStorageMockCounter) Set(f func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)) *MetricStorageMock {
	if mmCounter.defaultExpectation != nil {
		mmCounter.mock.t.Fatalf("Default expectation is already set for the MetricStorage.Counter method")
	}

	if len(mmCounter.expectations) > 0 {
		mmCounter.mock.t.Fatalf("Some expectations are already set for the MetricStorage.Counter method")
	}

	mmCounter.mock.funcCounter = f
	mmCounter.mock.funcCounterOrigin = minimock.CallerInfo(1)
	return mmCounter.mock
}

// When sets expectation for the MetricStorage.Counter which will trigger the result defined by the following
// Then helper
func (mmCounter *mMetricStorageMockCounter) When(metric string, labels map[string]string) *MetricStorageMockCounterExpectation {
	if mmCounter.mock.funcCounter != nil {
		mmCounter.mock.t.Fatalf("MetricStorageMock.Counter mock is already set by Set")
	}

	expectation := &MetricStorageMockCounterExpectation{
		mock:               mmCounter.mock,
		params:             &MetricStorageMockCounterParams{metric, labels},
		expectationOrigins: MetricStorageMockCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCounter.expectations = append(mmCounter.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.Counter return parameters for the expectation previously defined by the When method
func (e *MetricStorageMockCounterExpectation) Then(cp1 *prometheus.CounterVec) *MetricStorageMock {
	e.results = &MetricStorageMockCounterResults{cp1}
	return e.mock
}

// Times sets number of times MetricStorage.Counter should be invoked
func (mmCounter *mMetricStorageMockCounter) Times(n uint64) *mMetricStorageMockCounter {
	if n == 0 {
		mmCounter.mock.t.Fatalf("Times of MetricStorageMock.Counter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounter.expectedInvocations, n)
	mmCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounter
}

func (mmCounter *mMetricStorageMockCounter) invocationsDone() bool {
	if len(mmCounter.expectations) == 0 && mmCounter.defaultExpectation == nil && mmCounter.mock.funcCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounter.mock.afterCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Counter implements mm_pkg.MetricStorage
func (mmCounter *MetricStorageMock) Counter(metric string, labels map[string]string) (cp1 *prometheus.CounterVec) {
	mm_atomic.AddUint64(&mmCounter.beforeCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmCounter.afterCounterCounter, 1)

	mmCounter.t.Helper()

	if mmCounter.inspectFuncCounter != nil {
		mmCounter.inspectFuncCounter(metric, labels)
	}

	mm_params := MetricStorageMockCounterParams{metric, labels}

	// Record call args
	mmCounter.CounterMock.mutex.Lock()
	mmCounter.CounterMock.callArgs = append(mmCounter.CounterMock.callArgs, &mm_params)
	mmCounter.CounterMock.mutex.Unlock()

	for _, e := range mmCounter.CounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1
		}
	}

	if mmCounter.CounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounter.CounterMock.defaultExpectation.Counter, 1)
		mm_want := mmCounter.CounterMock.defaultExpectation.params
		mm_want_ptrs := mmCounter.CounterMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockCounterParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmCounter.t.Errorf("MetricStorageMock.Counter got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounter.CounterMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounter.t.Errorf("MetricStorageMock.Counter got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounter.CounterMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounter.t.Errorf("MetricStorageMock.Counter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounter.CounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCounter.CounterMock.defaultExpectation.results
		if mm_results == nil {
			mmCounter.t.Fatal("No results are set for the MetricStorageMock.Counter")
		}
		return (*mm_results).cp1
	}
	if mmCounter.funcCounter != nil {
		return mmCounter.funcCounter(metric, labels)
	}
	mmCounter.t.Fatalf("Unexpected call to MetricStorageMock.Counter. %v %v", metric, labels)
	return
}

// CounterAfterCounter returns a count of finished MetricStorageMock.Counter invocations
func (mmCounter *MetricStorageMock) CounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounter.afterCounterCounter)
}

// CounterBeforeCounter returns a count of MetricStorageMock.Counter invocations
func (mmCounter *MetricStorageMock) CounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounter.beforeCounterCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.Counter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounter *mMetricStorageMockCounter) Calls() []*MetricStorageMockCounterParams {
	mmCounter.mutex.RLock()

	argCopy := make([]*MetricStorageMockCounterParams, len(mmCounter.callArgs))
	copy(argCopy, mmCounter.callArgs)

	mmCounter.mutex.RUnlock()

	return argCopy
}

// MinimockCounterDone returns true if the count of the Counter invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockCounterDone() bool {
	if m.CounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterMock.invocationsDone()
}

// MinimockCounterInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockCounterInspect() {
	for _, e := range m.CounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.Counter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterCounter := mm_atomic.LoadUint64(&m.afterCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterMock.defaultExpectation != nil && afterCounterCounter < 1 {
		if m.CounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.Counter at\n%s", m.CounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.Counter at\n%s with params: %#v", m.CounterMock.defaultExpectation.expectationOrigins.origin, *m.CounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounter != nil && afterCounterCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.Counter at\n%s", m.funcCounterOrigin)
	}

	if !m.CounterMock.invocationsDone() && afterCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.Counter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterMock.expectedInvocations), m.CounterMock.expectedInvocationsOrigin, afterCounterCounter)
	}
}

type mMetricStorageMockCounterAdd struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockCounterAddExpectation
	expectations       []*MetricStorageMockCounterAddExpectation

	callArgs []*MetricStorageMockCounterAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockCounterAddExpectation specifies expectation struct of the MetricStorage.CounterAdd
type MetricStorageMockCounterAddExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockCounterAddParams
	paramPtrs          *MetricStorageMockCounterAddParamPtrs
	expectationOrigins MetricStorageMockCounterAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// MetricStorageMockCounterAddParams contains parameters of the MetricStorage.CounterAdd
type MetricStorageMockCounterAddParams struct {
	metric string
	value  float64
	labels map[string]string
}

// MetricStorageMockCounterAddParamPtrs contains pointers to parameters of the MetricStorage.CounterAdd
type MetricStorageMockCounterAddParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// MetricStorageMockCounterAddOrigins contains origins of expectations of the MetricStorage.CounterAdd
type MetricStorageMockCounterAddExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCounterAdd *mMetricStorageMockCounterAdd) Optional() *mMetricStorageMockCounterAdd {
	mmCounterAdd.optional = true
	return mmCounterAdd
}

// Expect sets up expected params for MetricStorage.CounterAdd
func (mmCounterAdd *mMetricStorageMockCounterAdd) Expect(metric string, value float64, labels map[string]string) *mMetricStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &MetricStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.paramPtrs != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by ExpectParams functions")
	}

	mmCounterAdd.defaultExpectation.params = &MetricStorageMockCounterAddParams{metric, value, labels}
	mmCounterAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCounterAdd.expectations {
		if minimock.Equal(e.params, mmCounterAdd.defaultExpectation.params) {
			mmCounterAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCounterAdd.defaultExpectation.params)
		}
	}

	return mmCounterAdd
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.CounterAdd
func (mmCounterAdd *mMetricStorageMockCounterAdd) ExpectMetricParam1(metric string) *mMetricStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &MetricStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &MetricStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.metric = &metric
	mmCounterAdd.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectValueParam2 sets up expected param value for MetricStorage.CounterAdd
func (mmCounterAdd *mMetricStorageMockCounterAdd) ExpectValueParam2(value float64) *mMetricStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &MetricStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &MetricStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.value = &value
	mmCounterAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmCounterAdd
}

// ExpectLabelsParam3 sets up expected param labels for MetricStorage.CounterAdd
func (mmCounterAdd *mMetricStorageMockCounterAdd) ExpectLabelsParam3(labels map[string]string) *mMetricStorageMockCounterAdd {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &MetricStorageMockCounterAddExpectation{}
	}

	if mmCounterAdd.defaultExpectation.params != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by Expect")
	}

	if mmCounterAdd.defaultExpectation.paramPtrs == nil {
		mmCounterAdd.defaultExpectation.paramPtrs = &MetricStorageMockCounterAddParamPtrs{}
	}
	mmCounterAdd.defaultExpectation.paramPtrs.labels = &labels
	mmCounterAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmCounterAdd
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.CounterAdd
func (mmCounterAdd *mMetricStorageMockCounterAdd) Inspect(f func(metric string, value float64, labels map[string]string)) *mMetricStorageMockCounterAdd {
	if mmCounterAdd.mock.inspectFuncCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.CounterAdd")
	}

	mmCounterAdd.mock.inspectFuncCounterAdd = f

	return mmCounterAdd
}

// Return sets up results that will be returned by MetricStorage.CounterAdd
func (mmCounterAdd *mMetricStorageMockCounterAdd) Return() *MetricStorageMock {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by Set")
	}

	if mmCounterAdd.defaultExpectation == nil {
		mmCounterAdd.defaultExpectation = &MetricStorageMockCounterAddExpectation{mock: mmCounterAdd.mock}
	}

	mmCounterAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// Set uses given function f to mock the MetricStorage.CounterAdd method
func (mmCounterAdd *mMetricStorageMockCounterAdd) Set(f func(metric string, value float64, labels map[string]string)) *MetricStorageMock {
	if mmCounterAdd.defaultExpectation != nil {
		mmCounterAdd.mock.t.Fatalf("Default expectation is already set for the MetricStorage.CounterAdd method")
	}

	if len(mmCounterAdd.expectations) > 0 {
		mmCounterAdd.mock.t.Fatalf("Some expectations are already set for the MetricStorage.CounterAdd method")
	}

	mmCounterAdd.mock.funcCounterAdd = f
	mmCounterAdd.mock.funcCounterAddOrigin = minimock.CallerInfo(1)
	return mmCounterAdd.mock
}

// When sets expectation for the MetricStorage.CounterAdd which will trigger the result defined by the following
// Then helper
func (mmCounterAdd *mMetricStorageMockCounterAdd) When(metric string, value float64, labels map[string]string) *MetricStorageMockCounterAddExpectation {
	if mmCounterAdd.mock.funcCounterAdd != nil {
		mmCounterAdd.mock.t.Fatalf("MetricStorageMock.CounterAdd mock is already set by Set")
	}

	expectation := &MetricStorageMockCounterAddExpectation{
		mock:               mmCounterAdd.mock,
		params:             &MetricStorageMockCounterAddParams{metric, value, labels},
		expectationOrigins: MetricStorageMockCounterAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCounterAdd.expectations = append(mmCounterAdd.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.CounterAdd return parameters for the expectation previously defined by the When method

func (e *MetricStorageMockCounterAddExpectation) Then() *MetricStorageMock {
	return e.mock
}

// Times sets number of times MetricStorage.CounterAdd should be invoked
func (mmCounterAdd *mMetricStorageMockCounterAdd) Times(n uint64) *mMetricStorageMockCounterAdd {
	if n == 0 {
		mmCounterAdd.mock.t.Fatalf("Times of MetricStorageMock.CounterAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCounterAdd.expectedInvocations, n)
	mmCounterAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCounterAdd
}

func (mmCounterAdd *mMetricStorageMockCounterAdd) invocationsDone() bool {
	if len(mmCounterAdd.expectations) == 0 && mmCounterAdd.defaultExpectation == nil && mmCounterAdd.mock.funcCounterAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCounterAdd.mock.afterCounterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCounterAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CounterAdd implements mm_pkg.MetricStorage
func (mmCounterAdd *MetricStorageMock) CounterAdd(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmCounterAdd.beforeCounterAddCounter, 1)
	defer mm_atomic.AddUint64(&mmCounterAdd.afterCounterAddCounter, 1)

	mmCounterAdd.t.Helper()

	if mmCounterAdd.inspectFuncCounterAdd != nil {
		mmCounterAdd.inspectFuncCounterAdd(metric, value, labels)
	}

	mm_params := MetricStorageMockCounterAddParams{metric, value, labels}

	// Record call args
	mmCounterAdd.CounterAddMock.mutex.Lock()
	mmCounterAdd.CounterAddMock.callArgs = append(mmCounterAdd.CounterAddMock.callArgs, &mm_params)
	mmCounterAdd.CounterAddMock.mutex.Unlock()

	for _, e := range mmCounterAdd.CounterAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmCounterAdd.CounterAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCounterAdd.CounterAddMock.defaultExpectation.Counter, 1)
		mm_want := mmCounterAdd.CounterAddMock.defaultExpectation.params
		mm_want_ptrs := mmCounterAdd.CounterAddMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockCounterAddParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmCounterAdd.t.Errorf("MetricStorageMock.CounterAdd got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmCounterAdd.t.Errorf("MetricStorageMock.CounterAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmCounterAdd.t.Errorf("MetricStorageMock.CounterAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCounterAdd.t.Errorf("MetricStorageMock.CounterAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCounterAdd.CounterAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmCounterAdd.funcCounterAdd != nil {
		mmCounterAdd.funcCounterAdd(metric, value, labels)
		return
	}
	mmCounterAdd.t.Fatalf("Unexpected call to MetricStorageMock.CounterAdd. %v %v %v", metric, value, labels)

}

// CounterAddAfterCounter returns a count of finished MetricStorageMock.CounterAdd invocations
func (mmCounterAdd *MetricStorageMock) CounterAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.afterCounterAddCounter)
}

// CounterAddBeforeCounter returns a count of MetricStorageMock.CounterAdd invocations
func (mmCounterAdd *MetricStorageMock) CounterAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCounterAdd.beforeCounterAddCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.CounterAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCounterAdd *mMetricStorageMockCounterAdd) Calls() []*MetricStorageMockCounterAddParams {
	mmCounterAdd.mutex.RLock()

	argCopy := make([]*MetricStorageMockCounterAddParams, len(mmCounterAdd.callArgs))
	copy(argCopy, mmCounterAdd.callArgs)

	mmCounterAdd.mutex.RUnlock()

	return argCopy
}

// MinimockCounterAddDone returns true if the count of the CounterAdd invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockCounterAddDone() bool {
	if m.CounterAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CounterAddMock.invocationsDone()
}

// MinimockCounterAddInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockCounterAddInspect() {
	for _, e := range m.CounterAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.CounterAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCounterAddCounter := mm_atomic.LoadUint64(&m.afterCounterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CounterAddMock.defaultExpectation != nil && afterCounterAddCounter < 1 {
		if m.CounterAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.CounterAdd at\n%s", m.CounterAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.CounterAdd at\n%s with params: %#v", m.CounterAddMock.defaultExpectation.expectationOrigins.origin, *m.CounterAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCounterAdd != nil && afterCounterAddCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.CounterAdd at\n%s", m.funcCounterAddOrigin)
	}

	if !m.CounterAddMock.invocationsDone() && afterCounterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.CounterAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CounterAddMock.expectedInvocations), m.CounterAddMock.expectedInvocationsOrigin, afterCounterAddCounter)
	}
}

type mMetricStorageMockGauge struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockGaugeExpectation
	expectations       []*MetricStorageMockGaugeExpectation

	callArgs []*MetricStorageMockGaugeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockGaugeExpectation specifies expectation struct of the MetricStorage.Gauge
type MetricStorageMockGaugeExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockGaugeParams
	paramPtrs          *MetricStorageMockGaugeParamPtrs
	expectationOrigins MetricStorageMockGaugeExpectationOrigins
	results            *MetricStorageMockGaugeResults
	returnOrigin       string
	Counter            uint64
}

// MetricStorageMockGaugeParams contains parameters of the MetricStorage.Gauge
type MetricStorageMockGaugeParams struct {
	metric string
	labels map[string]string
}

// MetricStorageMockGaugeParamPtrs contains pointers to parameters of the MetricStorage.Gauge
type MetricStorageMockGaugeParamPtrs struct {
	metric *string
	labels *map[string]string
}

// MetricStorageMockGaugeResults contains results of the MetricStorage.Gauge
type MetricStorageMockGaugeResults struct {
	gp1 *prometheus.GaugeVec
}

// MetricStorageMockGaugeOrigins contains origins of expectations of the MetricStorage.Gauge
type MetricStorageMockGaugeExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGauge *mMetricStorageMockGauge) Optional() *mMetricStorageMockGauge {
	mmGauge.optional = true
	return mmGauge
}

// Expect sets up expected params for MetricStorage.Gauge
func (mmGauge *mMetricStorageMockGauge) Expect(metric string, labels map[string]string) *mMetricStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("MetricStorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &MetricStorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.paramPtrs != nil {
		mmGauge.mock.t.Fatalf("MetricStorageMock.Gauge mock is already set by ExpectParams functions")
	}

	mmGauge.defaultExpectation.params = &MetricStorageMockGaugeParams{metric, labels}
	mmGauge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGauge.expectations {
		if minimock.Equal(e.params, mmGauge.defaultExpectation.params) {
			mmGauge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGauge.defaultExpectation.params)
		}
	}

	return mmGauge
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.Gauge
func (mmGauge *mMetricStorageMockGauge) ExpectMetricParam1(metric string) *mMetricStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("MetricStorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &MetricStorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.params != nil {
		mmGauge.mock.t.Fatalf("MetricStorageMock.Gauge mock is already set by Expect")
	}

	if mmGauge.defaultExpectation.paramPtrs == nil {
		mmGauge.defaultExpectation.paramPtrs = &MetricStorageMockGaugeParamPtrs{}
	}
	mmGauge.defaultExpectation.paramPtrs.metric = &metric
	mmGauge.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGauge
}

// ExpectLabelsParam2 sets up expected param labels for MetricStorage.Gauge
func (mmGauge *mMetricStorageMockGauge) ExpectLabelsParam2(labels map[string]string) *mMetricStorageMockGauge {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("MetricStorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &MetricStorageMockGaugeExpectation{}
	}

	if mmGauge.defaultExpectation.params != nil {
		mmGauge.mock.t.Fatalf("MetricStorageMock.Gauge mock is already set by Expect")
	}

	if mmGauge.defaultExpectation.paramPtrs == nil {
		mmGauge.defaultExpectation.paramPtrs = &MetricStorageMockGaugeParamPtrs{}
	}
	mmGauge.defaultExpectation.paramPtrs.labels = &labels
	mmGauge.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGauge
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.Gauge
func (mmGauge *mMetricStorageMockGauge) Inspect(f func(metric string, labels map[string]string)) *mMetricStorageMockGauge {
	if mmGauge.mock.inspectFuncGauge != nil {
		mmGauge.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.Gauge")
	}

	mmGauge.mock.inspectFuncGauge = f

	return mmGauge
}

// Return sets up results that will be returned by MetricStorage.Gauge
func (mmGauge *mMetricStorageMockGauge) Return(gp1 *prometheus.GaugeVec) *MetricStorageMock {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("MetricStorageMock.Gauge mock is already set by Set")
	}

	if mmGauge.defaultExpectation == nil {
		mmGauge.defaultExpectation = &MetricStorageMockGaugeExpectation{mock: mmGauge.mock}
	}
	mmGauge.defaultExpectation.results = &MetricStorageMockGaugeResults{gp1}
	mmGauge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGauge.mock
}

// Set uses given function f to mock the MetricStorage.Gauge method
func (mmGauge *mMetricStorageMockGauge) Set(f func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)) *MetricStorageMock {
	if mmGauge.defaultExpectation != nil {
		mmGauge.mock.t.Fatalf("Default expectation is already set for the MetricStorage.Gauge method")
	}

	if len(mmGauge.expectations) > 0 {
		mmGauge.mock.t.Fatalf("Some expectations are already set for the MetricStorage.Gauge method")
	}

	mmGauge.mock.funcGauge = f
	mmGauge.mock.funcGaugeOrigin = minimock.CallerInfo(1)
	return mmGauge.mock
}

// When sets expectation for the MetricStorage.Gauge which will trigger the result defined by the following
// Then helper
func (mmGauge *mMetricStorageMockGauge) When(metric string, labels map[string]string) *MetricStorageMockGaugeExpectation {
	if mmGauge.mock.funcGauge != nil {
		mmGauge.mock.t.Fatalf("MetricStorageMock.Gauge mock is already set by Set")
	}

	expectation := &MetricStorageMockGaugeExpectation{
		mock:               mmGauge.mock,
		params:             &MetricStorageMockGaugeParams{metric, labels},
		expectationOrigins: MetricStorageMockGaugeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGauge.expectations = append(mmGauge.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.Gauge return parameters for the expectation previously defined by the When method
func (e *MetricStorageMockGaugeExpectation) Then(gp1 *prometheus.GaugeVec) *MetricStorageMock {
	e.results = &MetricStorageMockGaugeResults{gp1}
	return e.mock
}

// Times sets number of times MetricStorage.Gauge should be invoked
func (mmGauge *mMetricStorageMockGauge) Times(n uint64) *mMetricStorageMockGauge {
	if n == 0 {
		mmGauge.mock.t.Fatalf("Times of MetricStorageMock.Gauge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGauge.expectedInvocations, n)
	mmGauge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGauge
}

func (mmGauge *mMetricStorageMockGauge) invocationsDone() bool {
	if len(mmGauge.expectations) == 0 && mmGauge.defaultExpectation == nil && mmGauge.mock.funcGauge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGauge.mock.afterGaugeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGauge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Gauge implements mm_pkg.MetricStorage
func (mmGauge *MetricStorageMock) Gauge(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec) {
	mm_atomic.AddUint64(&mmGauge.beforeGaugeCounter, 1)
	defer mm_atomic.AddUint64(&mmGauge.afterGaugeCounter, 1)

	mmGauge.t.Helper()

	if mmGauge.inspectFuncGauge != nil {
		mmGauge.inspectFuncGauge(metric, labels)
	}

	mm_params := MetricStorageMockGaugeParams{metric, labels}

	// Record call args
	mmGauge.GaugeMock.mutex.Lock()
	mmGauge.GaugeMock.callArgs = append(mmGauge.GaugeMock.callArgs, &mm_params)
	mmGauge.GaugeMock.mutex.Unlock()

	for _, e := range mmGauge.GaugeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1
		}
	}

	if mmGauge.GaugeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGauge.GaugeMock.defaultExpectation.Counter, 1)
		mm_want := mmGauge.GaugeMock.defaultExpectation.params
		mm_want_ptrs := mmGauge.GaugeMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockGaugeParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGauge.t.Errorf("MetricStorageMock.Gauge got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGauge.GaugeMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGauge.t.Errorf("MetricStorageMock.Gauge got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGauge.GaugeMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGauge.t.Errorf("MetricStorageMock.Gauge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGauge.GaugeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGauge.GaugeMock.defaultExpectation.results
		if mm_results == nil {
			mmGauge.t.Fatal("No results are set for the MetricStorageMock.Gauge")
		}
		return (*mm_results).gp1
	}
	if mmGauge.funcGauge != nil {
		return mmGauge.funcGauge(metric, labels)
	}
	mmGauge.t.Fatalf("Unexpected call to MetricStorageMock.Gauge. %v %v", metric, labels)
	return
}

// GaugeAfterCounter returns a count of finished MetricStorageMock.Gauge invocations
func (mmGauge *MetricStorageMock) GaugeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGauge.afterGaugeCounter)
}

// GaugeBeforeCounter returns a count of MetricStorageMock.Gauge invocations
func (mmGauge *MetricStorageMock) GaugeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGauge.beforeGaugeCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.Gauge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGauge *mMetricStorageMockGauge) Calls() []*MetricStorageMockGaugeParams {
	mmGauge.mutex.RLock()

	argCopy := make([]*MetricStorageMockGaugeParams, len(mmGauge.callArgs))
	copy(argCopy, mmGauge.callArgs)

	mmGauge.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeDone returns true if the count of the Gauge invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockGaugeDone() bool {
	if m.GaugeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeMock.invocationsDone()
}

// MinimockGaugeInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockGaugeInspect() {
	for _, e := range m.GaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.Gauge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeCounter := mm_atomic.LoadUint64(&m.afterGaugeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeMock.defaultExpectation != nil && afterGaugeCounter < 1 {
		if m.GaugeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.Gauge at\n%s", m.GaugeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.Gauge at\n%s with params: %#v", m.GaugeMock.defaultExpectation.expectationOrigins.origin, *m.GaugeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGauge != nil && afterGaugeCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.Gauge at\n%s", m.funcGaugeOrigin)
	}

	if !m.GaugeMock.invocationsDone() && afterGaugeCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.Gauge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeMock.expectedInvocations), m.GaugeMock.expectedInvocationsOrigin, afterGaugeCounter)
	}
}

type mMetricStorageMockGaugeAdd struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockGaugeAddExpectation
	expectations       []*MetricStorageMockGaugeAddExpectation

	callArgs []*MetricStorageMockGaugeAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockGaugeAddExpectation specifies expectation struct of the MetricStorage.GaugeAdd
type MetricStorageMockGaugeAddExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockGaugeAddParams
	paramPtrs          *MetricStorageMockGaugeAddParamPtrs
	expectationOrigins MetricStorageMockGaugeAddExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// MetricStorageMockGaugeAddParams contains parameters of the MetricStorage.GaugeAdd
type MetricStorageMockGaugeAddParams struct {
	metric string
	value  float64
	labels map[string]string
}

// MetricStorageMockGaugeAddParamPtrs contains pointers to parameters of the MetricStorage.GaugeAdd
type MetricStorageMockGaugeAddParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// MetricStorageMockGaugeAddOrigins contains origins of expectations of the MetricStorage.GaugeAdd
type MetricStorageMockGaugeAddExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) Optional() *mMetricStorageMockGaugeAdd {
	mmGaugeAdd.optional = true
	return mmGaugeAdd
}

// Expect sets up expected params for MetricStorage.GaugeAdd
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) Expect(metric string, value float64, labels map[string]string) *mMetricStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &MetricStorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by ExpectParams functions")
	}

	mmGaugeAdd.defaultExpectation.params = &MetricStorageMockGaugeAddParams{metric, value, labels}
	mmGaugeAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeAdd.expectations {
		if minimock.Equal(e.params, mmGaugeAdd.defaultExpectation.params) {
			mmGaugeAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeAdd.defaultExpectation.params)
		}
	}

	return mmGaugeAdd
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.GaugeAdd
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) ExpectMetricParam1(metric string) *mMetricStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &MetricStorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &MetricStorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.metric = &metric
	mmGaugeAdd.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// ExpectValueParam2 sets up expected param value for MetricStorage.GaugeAdd
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) ExpectValueParam2(value float64) *mMetricStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &MetricStorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &MetricStorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.value = &value
	mmGaugeAdd.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// ExpectLabelsParam3 sets up expected param labels for MetricStorage.GaugeAdd
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) ExpectLabelsParam3(labels map[string]string) *mMetricStorageMockGaugeAdd {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &MetricStorageMockGaugeAddExpectation{}
	}

	if mmGaugeAdd.defaultExpectation.params != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by Expect")
	}

	if mmGaugeAdd.defaultExpectation.paramPtrs == nil {
		mmGaugeAdd.defaultExpectation.paramPtrs = &MetricStorageMockGaugeAddParamPtrs{}
	}
	mmGaugeAdd.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeAdd.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeAdd
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.GaugeAdd
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) Inspect(f func(metric string, value float64, labels map[string]string)) *mMetricStorageMockGaugeAdd {
	if mmGaugeAdd.mock.inspectFuncGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.GaugeAdd")
	}

	mmGaugeAdd.mock.inspectFuncGaugeAdd = f

	return mmGaugeAdd
}

// Return sets up results that will be returned by MetricStorage.GaugeAdd
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) Return() *MetricStorageMock {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by Set")
	}

	if mmGaugeAdd.defaultExpectation == nil {
		mmGaugeAdd.defaultExpectation = &MetricStorageMockGaugeAddExpectation{mock: mmGaugeAdd.mock}
	}

	mmGaugeAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd.mock
}

// Set uses given function f to mock the MetricStorage.GaugeAdd method
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) Set(f func(metric string, value float64, labels map[string]string)) *MetricStorageMock {
	if mmGaugeAdd.defaultExpectation != nil {
		mmGaugeAdd.mock.t.Fatalf("Default expectation is already set for the MetricStorage.GaugeAdd method")
	}

	if len(mmGaugeAdd.expectations) > 0 {
		mmGaugeAdd.mock.t.Fatalf("Some expectations are already set for the MetricStorage.GaugeAdd method")
	}

	mmGaugeAdd.mock.funcGaugeAdd = f
	mmGaugeAdd.mock.funcGaugeAddOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd.mock
}

// When sets expectation for the MetricStorage.GaugeAdd which will trigger the result defined by the following
// Then helper
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) When(metric string, value float64, labels map[string]string) *MetricStorageMockGaugeAddExpectation {
	if mmGaugeAdd.mock.funcGaugeAdd != nil {
		mmGaugeAdd.mock.t.Fatalf("MetricStorageMock.GaugeAdd mock is already set by Set")
	}

	expectation := &MetricStorageMockGaugeAddExpectation{
		mock:               mmGaugeAdd.mock,
		params:             &MetricStorageMockGaugeAddParams{metric, value, labels},
		expectationOrigins: MetricStorageMockGaugeAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGaugeAdd.expectations = append(mmGaugeAdd.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.GaugeAdd return parameters for the expectation previously defined by the When method

func (e *MetricStorageMockGaugeAddExpectation) Then() *MetricStorageMock {
	return e.mock
}

// Times sets number of times MetricStorage.GaugeAdd should be invoked
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) Times(n uint64) *mMetricStorageMockGaugeAdd {
	if n == 0 {
		mmGaugeAdd.mock.t.Fatalf("Times of MetricStorageMock.GaugeAdd mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeAdd.expectedInvocations, n)
	mmGaugeAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeAdd
}

func (mmGaugeAdd *mMetricStorageMockGaugeAdd) invocationsDone() bool {
	if len(mmGaugeAdd.expectations) == 0 && mmGaugeAdd.defaultExpectation == nil && mmGaugeAdd.mock.funcGaugeAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeAdd.mock.afterGaugeAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeAdd implements mm_pkg.MetricStorage
func (mmGaugeAdd *MetricStorageMock) GaugeAdd(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeAdd.beforeGaugeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeAdd.afterGaugeAddCounter, 1)

	mmGaugeAdd.t.Helper()

	if mmGaugeAdd.inspectFuncGaugeAdd != nil {
		mmGaugeAdd.inspectFuncGaugeAdd(metric, value, labels)
	}

	mm_params := MetricStorageMockGaugeAddParams{metric, value, labels}

	// Record call args
	mmGaugeAdd.GaugeAddMock.mutex.Lock()
	mmGaugeAdd.GaugeAddMock.callArgs = append(mmGaugeAdd.GaugeAddMock.callArgs, &mm_params)
	mmGaugeAdd.GaugeAddMock.mutex.Unlock()

	for _, e := range mmGaugeAdd.GaugeAddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeAdd.GaugeAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeAdd.GaugeAddMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeAdd.GaugeAddMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeAdd.GaugeAddMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockGaugeAddParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGaugeAdd.t.Errorf("MetricStorageMock.GaugeAdd got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeAdd.t.Errorf("MetricStorageMock.GaugeAdd got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeAdd.t.Errorf("MetricStorageMock.GaugeAdd got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeAdd.t.Errorf("MetricStorageMock.GaugeAdd got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeAdd.GaugeAddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeAdd.funcGaugeAdd != nil {
		mmGaugeAdd.funcGaugeAdd(metric, value, labels)
		return
	}
	mmGaugeAdd.t.Fatalf("Unexpected call to MetricStorageMock.GaugeAdd. %v %v %v", metric, value, labels)

}

// GaugeAddAfterCounter returns a count of finished MetricStorageMock.GaugeAdd invocations
func (mmGaugeAdd *MetricStorageMock) GaugeAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeAdd.afterGaugeAddCounter)
}

// GaugeAddBeforeCounter returns a count of MetricStorageMock.GaugeAdd invocations
func (mmGaugeAdd *MetricStorageMock) GaugeAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeAdd.beforeGaugeAddCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.GaugeAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeAdd *mMetricStorageMockGaugeAdd) Calls() []*MetricStorageMockGaugeAddParams {
	mmGaugeAdd.mutex.RLock()

	argCopy := make([]*MetricStorageMockGaugeAddParams, len(mmGaugeAdd.callArgs))
	copy(argCopy, mmGaugeAdd.callArgs)

	mmGaugeAdd.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeAddDone returns true if the count of the GaugeAdd invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockGaugeAddDone() bool {
	if m.GaugeAddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeAddMock.invocationsDone()
}

// MinimockGaugeAddInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockGaugeAddInspect() {
	for _, e := range m.GaugeAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.GaugeAdd at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeAddCounter := mm_atomic.LoadUint64(&m.afterGaugeAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeAddMock.defaultExpectation != nil && afterGaugeAddCounter < 1 {
		if m.GaugeAddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.GaugeAdd at\n%s", m.GaugeAddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.GaugeAdd at\n%s with params: %#v", m.GaugeAddMock.defaultExpectation.expectationOrigins.origin, *m.GaugeAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeAdd != nil && afterGaugeAddCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.GaugeAdd at\n%s", m.funcGaugeAddOrigin)
	}

	if !m.GaugeAddMock.invocationsDone() && afterGaugeAddCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.GaugeAdd at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeAddMock.expectedInvocations), m.GaugeAddMock.expectedInvocationsOrigin, afterGaugeAddCounter)
	}
}

type mMetricStorageMockGaugeSet struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockGaugeSetExpectation
	expectations       []*MetricStorageMockGaugeSetExpectation

	callArgs []*MetricStorageMockGaugeSetParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockGaugeSetExpectation specifies expectation struct of the MetricStorage.GaugeSet
type MetricStorageMockGaugeSetExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockGaugeSetParams
	paramPtrs          *MetricStorageMockGaugeSetParamPtrs
	expectationOrigins MetricStorageMockGaugeSetExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// MetricStorageMockGaugeSetParams contains parameters of the MetricStorage.GaugeSet
type MetricStorageMockGaugeSetParams struct {
	metric string
	value  float64
	labels map[string]string
}

// MetricStorageMockGaugeSetParamPtrs contains pointers to parameters of the MetricStorage.GaugeSet
type MetricStorageMockGaugeSetParamPtrs struct {
	metric *string
	value  *float64
	labels *map[string]string
}

// MetricStorageMockGaugeSetOrigins contains origins of expectations of the MetricStorage.GaugeSet
type MetricStorageMockGaugeSetExpectationOrigins struct {
	origin       string
	originMetric string
	originValue  string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGaugeSet *mMetricStorageMockGaugeSet) Optional() *mMetricStorageMockGaugeSet {
	mmGaugeSet.optional = true
	return mmGaugeSet
}

// Expect sets up expected params for MetricStorage.GaugeSet
func (mmGaugeSet *mMetricStorageMockGaugeSet) Expect(metric string, value float64, labels map[string]string) *mMetricStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &MetricStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.paramPtrs != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by ExpectParams functions")
	}

	mmGaugeSet.defaultExpectation.params = &MetricStorageMockGaugeSetParams{metric, value, labels}
	mmGaugeSet.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGaugeSet.expectations {
		if minimock.Equal(e.params, mmGaugeSet.defaultExpectation.params) {
			mmGaugeSet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGaugeSet.defaultExpectation.params)
		}
	}

	return mmGaugeSet
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.GaugeSet
func (mmGaugeSet *mMetricStorageMockGaugeSet) ExpectMetricParam1(metric string) *mMetricStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &MetricStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &MetricStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.metric = &metric
	mmGaugeSet.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectValueParam2 sets up expected param value for MetricStorage.GaugeSet
func (mmGaugeSet *mMetricStorageMockGaugeSet) ExpectValueParam2(value float64) *mMetricStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &MetricStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &MetricStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.value = &value
	mmGaugeSet.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmGaugeSet
}

// ExpectLabelsParam3 sets up expected param labels for MetricStorage.GaugeSet
func (mmGaugeSet *mMetricStorageMockGaugeSet) ExpectLabelsParam3(labels map[string]string) *mMetricStorageMockGaugeSet {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &MetricStorageMockGaugeSetExpectation{}
	}

	if mmGaugeSet.defaultExpectation.params != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by Expect")
	}

	if mmGaugeSet.defaultExpectation.paramPtrs == nil {
		mmGaugeSet.defaultExpectation.paramPtrs = &MetricStorageMockGaugeSetParamPtrs{}
	}
	mmGaugeSet.defaultExpectation.paramPtrs.labels = &labels
	mmGaugeSet.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmGaugeSet
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.GaugeSet
func (mmGaugeSet *mMetricStorageMockGaugeSet) Inspect(f func(metric string, value float64, labels map[string]string)) *mMetricStorageMockGaugeSet {
	if mmGaugeSet.mock.inspectFuncGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.GaugeSet")
	}

	mmGaugeSet.mock.inspectFuncGaugeSet = f

	return mmGaugeSet
}

// Return sets up results that will be returned by MetricStorage.GaugeSet
func (mmGaugeSet *mMetricStorageMockGaugeSet) Return() *MetricStorageMock {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by Set")
	}

	if mmGaugeSet.defaultExpectation == nil {
		mmGaugeSet.defaultExpectation = &MetricStorageMockGaugeSetExpectation{mock: mmGaugeSet.mock}
	}

	mmGaugeSet.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// Set uses given function f to mock the MetricStorage.GaugeSet method
func (mmGaugeSet *mMetricStorageMockGaugeSet) Set(f func(metric string, value float64, labels map[string]string)) *MetricStorageMock {
	if mmGaugeSet.defaultExpectation != nil {
		mmGaugeSet.mock.t.Fatalf("Default expectation is already set for the MetricStorage.GaugeSet method")
	}

	if len(mmGaugeSet.expectations) > 0 {
		mmGaugeSet.mock.t.Fatalf("Some expectations are already set for the MetricStorage.GaugeSet method")
	}

	mmGaugeSet.mock.funcGaugeSet = f
	mmGaugeSet.mock.funcGaugeSetOrigin = minimock.CallerInfo(1)
	return mmGaugeSet.mock
}

// When sets expectation for the MetricStorage.GaugeSet which will trigger the result defined by the following
// Then helper
func (mmGaugeSet *mMetricStorageMockGaugeSet) When(metric string, value float64, labels map[string]string) *MetricStorageMockGaugeSetExpectation {
	if mmGaugeSet.mock.funcGaugeSet != nil {
		mmGaugeSet.mock.t.Fatalf("MetricStorageMock.GaugeSet mock is already set by Set")
	}

	expectation := &MetricStorageMockGaugeSetExpectation{
		mock:               mmGaugeSet.mock,
		params:             &MetricStorageMockGaugeSetParams{metric, value, labels},
		expectationOrigins: MetricStorageMockGaugeSetExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGaugeSet.expectations = append(mmGaugeSet.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.GaugeSet return parameters for the expectation previously defined by the When method

func (e *MetricStorageMockGaugeSetExpectation) Then() *MetricStorageMock {
	return e.mock
}

// Times sets number of times MetricStorage.GaugeSet should be invoked
func (mmGaugeSet *mMetricStorageMockGaugeSet) Times(n uint64) *mMetricStorageMockGaugeSet {
	if n == 0 {
		mmGaugeSet.mock.t.Fatalf("Times of MetricStorageMock.GaugeSet mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGaugeSet.expectedInvocations, n)
	mmGaugeSet.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGaugeSet
}

func (mmGaugeSet *mMetricStorageMockGaugeSet) invocationsDone() bool {
	if len(mmGaugeSet.expectations) == 0 && mmGaugeSet.defaultExpectation == nil && mmGaugeSet.mock.funcGaugeSet == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGaugeSet.mock.afterGaugeSetCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGaugeSet.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GaugeSet implements mm_pkg.MetricStorage
func (mmGaugeSet *MetricStorageMock) GaugeSet(metric string, value float64, labels map[string]string) {
	mm_atomic.AddUint64(&mmGaugeSet.beforeGaugeSetCounter, 1)
	defer mm_atomic.AddUint64(&mmGaugeSet.afterGaugeSetCounter, 1)

	mmGaugeSet.t.Helper()

	if mmGaugeSet.inspectFuncGaugeSet != nil {
		mmGaugeSet.inspectFuncGaugeSet(metric, value, labels)
	}

	mm_params := MetricStorageMockGaugeSetParams{metric, value, labels}

	// Record call args
	mmGaugeSet.GaugeSetMock.mutex.Lock()
	mmGaugeSet.GaugeSetMock.callArgs = append(mmGaugeSet.GaugeSetMock.callArgs, &mm_params)
	mmGaugeSet.GaugeSetMock.mutex.Unlock()

	for _, e := range mmGaugeSet.GaugeSetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmGaugeSet.GaugeSetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGaugeSet.GaugeSetMock.defaultExpectation.Counter, 1)
		mm_want := mmGaugeSet.GaugeSetMock.defaultExpectation.params
		mm_want_ptrs := mmGaugeSet.GaugeSetMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockGaugeSetParams{metric, value, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmGaugeSet.t.Errorf("MetricStorageMock.GaugeSet got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmGaugeSet.t.Errorf("MetricStorageMock.GaugeSet got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmGaugeSet.t.Errorf("MetricStorageMock.GaugeSet got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGaugeSet.t.Errorf("MetricStorageMock.GaugeSet got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGaugeSet.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmGaugeSet.funcGaugeSet != nil {
		mmGaugeSet.funcGaugeSet(metric, value, labels)
		return
	}
	mmGaugeSet.t.Fatalf("Unexpected call to MetricStorageMock.GaugeSet. %v %v %v", metric, value, labels)

}

// GaugeSetAfterCounter returns a count of finished MetricStorageMock.GaugeSet invocations
func (mmGaugeSet *MetricStorageMock) GaugeSetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.afterGaugeSetCounter)
}

// GaugeSetBeforeCounter returns a count of MetricStorageMock.GaugeSet invocations
func (mmGaugeSet *MetricStorageMock) GaugeSetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGaugeSet.beforeGaugeSetCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.GaugeSet.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGaugeSet *mMetricStorageMockGaugeSet) Calls() []*MetricStorageMockGaugeSetParams {
	mmGaugeSet.mutex.RLock()

	argCopy := make([]*MetricStorageMockGaugeSetParams, len(mmGaugeSet.callArgs))
	copy(argCopy, mmGaugeSet.callArgs)

	mmGaugeSet.mutex.RUnlock()

	return argCopy
}

// MinimockGaugeSetDone returns true if the count of the GaugeSet invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockGaugeSetDone() bool {
	if m.GaugeSetMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GaugeSetMock.invocationsDone()
}

// MinimockGaugeSetInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockGaugeSetInspect() {
	for _, e := range m.GaugeSetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.GaugeSet at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGaugeSetCounter := mm_atomic.LoadUint64(&m.afterGaugeSetCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GaugeSetMock.defaultExpectation != nil && afterGaugeSetCounter < 1 {
		if m.GaugeSetMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.GaugeSet at\n%s", m.GaugeSetMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.GaugeSet at\n%s with params: %#v", m.GaugeSetMock.defaultExpectation.expectationOrigins.origin, *m.GaugeSetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGaugeSet != nil && afterGaugeSetCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.GaugeSet at\n%s", m.funcGaugeSetOrigin)
	}

	if !m.GaugeSetMock.invocationsDone() && afterGaugeSetCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.GaugeSet at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GaugeSetMock.expectedInvocations), m.GaugeSetMock.expectedInvocationsOrigin, afterGaugeSetCounter)
	}
}

type mMetricStorageMockGrouped struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockGroupedExpectation
	expectations       []*MetricStorageMockGroupedExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockGroupedExpectation specifies expectation struct of the MetricStorage.Grouped
type MetricStorageMockGroupedExpectation struct {
	mock *MetricStorageMock

	results      *MetricStorageMockGroupedResults
	returnOrigin string
	Counter      uint64
}

// MetricStorageMockGroupedResults contains results of the MetricStorage.Grouped
type MetricStorageMockGroupedResults struct {
	g1 metric.GroupedStorage
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGrouped *mMetricStorageMockGrouped) Optional() *mMetricStorageMockGrouped {
	mmGrouped.optional = true
	return mmGrouped
}

// Expect sets up expected params for MetricStorage.Grouped
func (mmGrouped *mMetricStorageMockGrouped) Expect() *mMetricStorageMockGrouped {
	if mmGrouped.mock.funcGrouped != nil {
		mmGrouped.mock.t.Fatalf("MetricStorageMock.Grouped mock is already set by Set")
	}

	if mmGrouped.defaultExpectation == nil {
		mmGrouped.defaultExpectation = &MetricStorageMockGroupedExpectation{}
	}

	return mmGrouped
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.Grouped
func (mmGrouped *mMetricStorageMockGrouped) Inspect(f func()) *mMetricStorageMockGrouped {
	if mmGrouped.mock.inspectFuncGrouped != nil {
		mmGrouped.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.Grouped")
	}

	mmGrouped.mock.inspectFuncGrouped = f

	return mmGrouped
}

// Return sets up results that will be returned by MetricStorage.Grouped
func (mmGrouped *mMetricStorageMockGrouped) Return(g1 metric.GroupedStorage) *MetricStorageMock {
	if mmGrouped.mock.funcGrouped != nil {
		mmGrouped.mock.t.Fatalf("MetricStorageMock.Grouped mock is already set by Set")
	}

	if mmGrouped.defaultExpectation == nil {
		mmGrouped.defaultExpectation = &MetricStorageMockGroupedExpectation{mock: mmGrouped.mock}
	}
	mmGrouped.defaultExpectation.results = &MetricStorageMockGroupedResults{g1}
	mmGrouped.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGrouped.mock
}

// Set uses given function f to mock the MetricStorage.Grouped method
func (mmGrouped *mMetricStorageMockGrouped) Set(f func() (g1 metric.GroupedStorage)) *MetricStorageMock {
	if mmGrouped.defaultExpectation != nil {
		mmGrouped.mock.t.Fatalf("Default expectation is already set for the MetricStorage.Grouped method")
	}

	if len(mmGrouped.expectations) > 0 {
		mmGrouped.mock.t.Fatalf("Some expectations are already set for the MetricStorage.Grouped method")
	}

	mmGrouped.mock.funcGrouped = f
	mmGrouped.mock.funcGroupedOrigin = minimock.CallerInfo(1)
	return mmGrouped.mock
}

// Times sets number of times MetricStorage.Grouped should be invoked
func (mmGrouped *mMetricStorageMockGrouped) Times(n uint64) *mMetricStorageMockGrouped {
	if n == 0 {
		mmGrouped.mock.t.Fatalf("Times of MetricStorageMock.Grouped mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGrouped.expectedInvocations, n)
	mmGrouped.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGrouped
}

func (mmGrouped *mMetricStorageMockGrouped) invocationsDone() bool {
	if len(mmGrouped.expectations) == 0 && mmGrouped.defaultExpectation == nil && mmGrouped.mock.funcGrouped == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGrouped.mock.afterGroupedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGrouped.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Grouped implements mm_pkg.MetricStorage
func (mmGrouped *MetricStorageMock) Grouped() (g1 metric.GroupedStorage) {
	mm_atomic.AddUint64(&mmGrouped.beforeGroupedCounter, 1)
	defer mm_atomic.AddUint64(&mmGrouped.afterGroupedCounter, 1)

	mmGrouped.t.Helper()

	if mmGrouped.inspectFuncGrouped != nil {
		mmGrouped.inspectFuncGrouped()
	}

	if mmGrouped.GroupedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGrouped.GroupedMock.defaultExpectation.Counter, 1)

		mm_results := mmGrouped.GroupedMock.defaultExpectation.results
		if mm_results == nil {
			mmGrouped.t.Fatal("No results are set for the MetricStorageMock.Grouped")
		}
		return (*mm_results).g1
	}
	if mmGrouped.funcGrouped != nil {
		return mmGrouped.funcGrouped()
	}
	mmGrouped.t.Fatalf("Unexpected call to MetricStorageMock.Grouped.")
	return
}

// GroupedAfterCounter returns a count of finished MetricStorageMock.Grouped invocations
func (mmGrouped *MetricStorageMock) GroupedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrouped.afterGroupedCounter)
}

// GroupedBeforeCounter returns a count of MetricStorageMock.Grouped invocations
func (mmGrouped *MetricStorageMock) GroupedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGrouped.beforeGroupedCounter)
}

// MinimockGroupedDone returns true if the count of the Grouped invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockGroupedDone() bool {
	if m.GroupedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GroupedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GroupedMock.invocationsDone()
}

// MinimockGroupedInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockGroupedInspect() {
	for _, e := range m.GroupedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MetricStorageMock.Grouped")
		}
	}

	afterGroupedCounter := mm_atomic.LoadUint64(&m.afterGroupedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GroupedMock.defaultExpectation != nil && afterGroupedCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.Grouped at\n%s", m.GroupedMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGrouped != nil && afterGroupedCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.Grouped at\n%s", m.funcGroupedOrigin)
	}

	if !m.GroupedMock.invocationsDone() && afterGroupedCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.Grouped at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GroupedMock.expectedInvocations), m.GroupedMock.expectedInvocationsOrigin, afterGroupedCounter)
	}
}

type mMetricStorageMockHandler struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockHandlerExpectation
	expectations       []*MetricStorageMockHandlerExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockHandlerExpectation specifies expectation struct of the MetricStorage.Handler
type MetricStorageMockHandlerExpectation struct {
	mock *MetricStorageMock

	results      *MetricStorageMockHandlerResults
	returnOrigin string
	Counter      uint64
}

// MetricStorageMockHandlerResults contains results of the MetricStorage.Handler
type MetricStorageMockHandlerResults struct {
	h1 http.Handler
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHandler *mMetricStorageMockHandler) Optional() *mMetricStorageMockHandler {
	mmHandler.optional = true
	return mmHandler
}

// Expect sets up expected params for MetricStorage.Handler
func (mmHandler *mMetricStorageMockHandler) Expect() *mMetricStorageMockHandler {
	if mmHandler.mock.funcHandler != nil {
		mmHandler.mock.t.Fatalf("MetricStorageMock.Handler mock is already set by Set")
	}

	if mmHandler.defaultExpectation == nil {
		mmHandler.defaultExpectation = &MetricStorageMockHandlerExpectation{}
	}

	return mmHandler
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.Handler
func (mmHandler *mMetricStorageMockHandler) Inspect(f func()) *mMetricStorageMockHandler {
	if mmHandler.mock.inspectFuncHandler != nil {
		mmHandler.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.Handler")
	}

	mmHandler.mock.inspectFuncHandler = f

	return mmHandler
}

// Return sets up results that will be returned by MetricStorage.Handler
func (mmHandler *mMetricStorageMockHandler) Return(h1 http.Handler) *MetricStorageMock {
	if mmHandler.mock.funcHandler != nil {
		mmHandler.mock.t.Fatalf("MetricStorageMock.Handler mock is already set by Set")
	}

	if mmHandler.defaultExpectation == nil {
		mmHandler.defaultExpectation = &MetricStorageMockHandlerExpectation{mock: mmHandler.mock}
	}
	mmHandler.defaultExpectation.results = &MetricStorageMockHandlerResults{h1}
	mmHandler.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHandler.mock
}

// Set uses given function f to mock the MetricStorage.Handler method
func (mmHandler *mMetricStorageMockHandler) Set(f func() (h1 http.Handler)) *MetricStorageMock {
	if mmHandler.defaultExpectation != nil {
		mmHandler.mock.t.Fatalf("Default expectation is already set for the MetricStorage.Handler method")
	}

	if len(mmHandler.expectations) > 0 {
		mmHandler.mock.t.Fatalf("Some expectations are already set for the MetricStorage.Handler method")
	}

	mmHandler.mock.funcHandler = f
	mmHandler.mock.funcHandlerOrigin = minimock.CallerInfo(1)
	return mmHandler.mock
}

// Times sets number of times MetricStorage.Handler should be invoked
func (mmHandler *mMetricStorageMockHandler) Times(n uint64) *mMetricStorageMockHandler {
	if n == 0 {
		mmHandler.mock.t.Fatalf("Times of MetricStorageMock.Handler mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHandler.expectedInvocations, n)
	mmHandler.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHandler
}

func (mmHandler *mMetricStorageMockHandler) invocationsDone() bool {
	if len(mmHandler.expectations) == 0 && mmHandler.defaultExpectation == nil && mmHandler.mock.funcHandler == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHandler.mock.afterHandlerCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHandler.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Handler implements mm_pkg.MetricStorage
func (mmHandler *MetricStorageMock) Handler() (h1 http.Handler) {
	mm_atomic.AddUint64(&mmHandler.beforeHandlerCounter, 1)
	defer mm_atomic.AddUint64(&mmHandler.afterHandlerCounter, 1)

	mmHandler.t.Helper()

	if mmHandler.inspectFuncHandler != nil {
		mmHandler.inspectFuncHandler()
	}

	if mmHandler.HandlerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHandler.HandlerMock.defaultExpectation.Counter, 1)

		mm_results := mmHandler.HandlerMock.defaultExpectation.results
		if mm_results == nil {
			mmHandler.t.Fatal("No results are set for the MetricStorageMock.Handler")
		}
		return (*mm_results).h1
	}
	if mmHandler.funcHandler != nil {
		return mmHandler.funcHandler()
	}
	mmHandler.t.Fatalf("Unexpected call to MetricStorageMock.Handler.")
	return
}

// HandlerAfterCounter returns a count of finished MetricStorageMock.Handler invocations
func (mmHandler *MetricStorageMock) HandlerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandler.afterHandlerCounter)
}

// HandlerBeforeCounter returns a count of MetricStorageMock.Handler invocations
func (mmHandler *MetricStorageMock) HandlerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHandler.beforeHandlerCounter)
}

// MinimockHandlerDone returns true if the count of the Handler invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockHandlerDone() bool {
	if m.HandlerMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HandlerMock.invocationsDone()
}

// MinimockHandlerInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockHandlerInspect() {
	for _, e := range m.HandlerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MetricStorageMock.Handler")
		}
	}

	afterHandlerCounter := mm_atomic.LoadUint64(&m.afterHandlerCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HandlerMock.defaultExpectation != nil && afterHandlerCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.Handler at\n%s", m.HandlerMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHandler != nil && afterHandlerCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.Handler at\n%s", m.funcHandlerOrigin)
	}

	if !m.HandlerMock.invocationsDone() && afterHandlerCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.Handler at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HandlerMock.expectedInvocations), m.HandlerMock.expectedInvocationsOrigin, afterHandlerCounter)
	}
}

type mMetricStorageMockHistogram struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockHistogramExpectation
	expectations       []*MetricStorageMockHistogramExpectation

	callArgs []*MetricStorageMockHistogramParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockHistogramExpectation specifies expectation struct of the MetricStorage.Histogram
type MetricStorageMockHistogramExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockHistogramParams
	paramPtrs          *MetricStorageMockHistogramParamPtrs
	expectationOrigins MetricStorageMockHistogramExpectationOrigins
	results            *MetricStorageMockHistogramResults
	returnOrigin       string
	Counter            uint64
}

// MetricStorageMockHistogramParams contains parameters of the MetricStorage.Histogram
type MetricStorageMockHistogramParams struct {
	metric  string
	labels  map[string]string
	buckets []float64
}

// MetricStorageMockHistogramParamPtrs contains pointers to parameters of the MetricStorage.Histogram
type MetricStorageMockHistogramParamPtrs struct {
	metric  *string
	labels  *map[string]string
	buckets *[]float64
}

// MetricStorageMockHistogramResults contains results of the MetricStorage.Histogram
type MetricStorageMockHistogramResults struct {
	hp1 *prometheus.HistogramVec
}

// MetricStorageMockHistogramOrigins contains origins of expectations of the MetricStorage.Histogram
type MetricStorageMockHistogramExpectationOrigins struct {
	origin        string
	originMetric  string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistogram *mMetricStorageMockHistogram) Optional() *mMetricStorageMockHistogram {
	mmHistogram.optional = true
	return mmHistogram
}

// Expect sets up expected params for MetricStorage.Histogram
func (mmHistogram *mMetricStorageMockHistogram) Expect(metric string, labels map[string]string, buckets []float64) *mMetricStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &MetricStorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.paramPtrs != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by ExpectParams functions")
	}

	mmHistogram.defaultExpectation.params = &MetricStorageMockHistogramParams{metric, labels, buckets}
	mmHistogram.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistogram.expectations {
		if minimock.Equal(e.params, mmHistogram.defaultExpectation.params) {
			mmHistogram.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistogram.defaultExpectation.params)
		}
	}

	return mmHistogram
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.Histogram
func (mmHistogram *mMetricStorageMockHistogram) ExpectMetricParam1(metric string) *mMetricStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &MetricStorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &MetricStorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.metric = &metric
	mmHistogram.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmHistogram
}

// ExpectLabelsParam2 sets up expected param labels for MetricStorage.Histogram
func (mmHistogram *mMetricStorageMockHistogram) ExpectLabelsParam2(labels map[string]string) *mMetricStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &MetricStorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &MetricStorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.labels = &labels
	mmHistogram.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmHistogram
}

// ExpectBucketsParam3 sets up expected param buckets for MetricStorage.Histogram
func (mmHistogram *mMetricStorageMockHistogram) ExpectBucketsParam3(buckets []float64) *mMetricStorageMockHistogram {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &MetricStorageMockHistogramExpectation{}
	}

	if mmHistogram.defaultExpectation.params != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by Expect")
	}

	if mmHistogram.defaultExpectation.paramPtrs == nil {
		mmHistogram.defaultExpectation.paramPtrs = &MetricStorageMockHistogramParamPtrs{}
	}
	mmHistogram.defaultExpectation.paramPtrs.buckets = &buckets
	mmHistogram.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmHistogram
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.Histogram
func (mmHistogram *mMetricStorageMockHistogram) Inspect(f func(metric string, labels map[string]string, buckets []float64)) *mMetricStorageMockHistogram {
	if mmHistogram.mock.inspectFuncHistogram != nil {
		mmHistogram.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.Histogram")
	}

	mmHistogram.mock.inspectFuncHistogram = f

	return mmHistogram
}

// Return sets up results that will be returned by MetricStorage.Histogram
func (mmHistogram *mMetricStorageMockHistogram) Return(hp1 *prometheus.HistogramVec) *MetricStorageMock {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by Set")
	}

	if mmHistogram.defaultExpectation == nil {
		mmHistogram.defaultExpectation = &MetricStorageMockHistogramExpectation{mock: mmHistogram.mock}
	}
	mmHistogram.defaultExpectation.results = &MetricStorageMockHistogramResults{hp1}
	mmHistogram.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistogram.mock
}

// Set uses given function f to mock the MetricStorage.Histogram method
func (mmHistogram *mMetricStorageMockHistogram) Set(f func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)) *MetricStorageMock {
	if mmHistogram.defaultExpectation != nil {
		mmHistogram.mock.t.Fatalf("Default expectation is already set for the MetricStorage.Histogram method")
	}

	if len(mmHistogram.expectations) > 0 {
		mmHistogram.mock.t.Fatalf("Some expectations are already set for the MetricStorage.Histogram method")
	}

	mmHistogram.mock.funcHistogram = f
	mmHistogram.mock.funcHistogramOrigin = minimock.CallerInfo(1)
	return mmHistogram.mock
}

// When sets expectation for the MetricStorage.Histogram which will trigger the result defined by the following
// Then helper
func (mmHistogram *mMetricStorageMockHistogram) When(metric string, labels map[string]string, buckets []float64) *MetricStorageMockHistogramExpectation {
	if mmHistogram.mock.funcHistogram != nil {
		mmHistogram.mock.t.Fatalf("MetricStorageMock.Histogram mock is already set by Set")
	}

	expectation := &MetricStorageMockHistogramExpectation{
		mock:               mmHistogram.mock,
		params:             &MetricStorageMockHistogramParams{metric, labels, buckets},
		expectationOrigins: MetricStorageMockHistogramExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistogram.expectations = append(mmHistogram.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.Histogram return parameters for the expectation previously defined by the When method
func (e *MetricStorageMockHistogramExpectation) Then(hp1 *prometheus.HistogramVec) *MetricStorageMock {
	e.results = &MetricStorageMockHistogramResults{hp1}
	return e.mock
}

// Times sets number of times MetricStorage.Histogram should be invoked
func (mmHistogram *mMetricStorageMockHistogram) Times(n uint64) *mMetricStorageMockHistogram {
	if n == 0 {
		mmHistogram.mock.t.Fatalf("Times of MetricStorageMock.Histogram mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistogram.expectedInvocations, n)
	mmHistogram.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistogram
}

func (mmHistogram *mMetricStorageMockHistogram) invocationsDone() bool {
	if len(mmHistogram.expectations) == 0 && mmHistogram.defaultExpectation == nil && mmHistogram.mock.funcHistogram == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistogram.mock.afterHistogramCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistogram.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Histogram implements mm_pkg.MetricStorage
func (mmHistogram *MetricStorageMock) Histogram(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec) {
	mm_atomic.AddUint64(&mmHistogram.beforeHistogramCounter, 1)
	defer mm_atomic.AddUint64(&mmHistogram.afterHistogramCounter, 1)

	mmHistogram.t.Helper()

	if mmHistogram.inspectFuncHistogram != nil {
		mmHistogram.inspectFuncHistogram(metric, labels, buckets)
	}

	mm_params := MetricStorageMockHistogramParams{metric, labels, buckets}

	// Record call args
	mmHistogram.HistogramMock.mutex.Lock()
	mmHistogram.HistogramMock.callArgs = append(mmHistogram.HistogramMock.callArgs, &mm_params)
	mmHistogram.HistogramMock.mutex.Unlock()

	for _, e := range mmHistogram.HistogramMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1
		}
	}

	if mmHistogram.HistogramMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistogram.HistogramMock.defaultExpectation.Counter, 1)
		mm_want := mmHistogram.HistogramMock.defaultExpectation.params
		mm_want_ptrs := mmHistogram.HistogramMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockHistogramParams{metric, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmHistogram.t.Errorf("MetricStorageMock.Histogram got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmHistogram.t.Errorf("MetricStorageMock.Histogram got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmHistogram.t.Errorf("MetricStorageMock.Histogram got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistogram.t.Errorf("MetricStorageMock.Histogram got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistogram.HistogramMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHistogram.HistogramMock.defaultExpectation.results
		if mm_results == nil {
			mmHistogram.t.Fatal("No results are set for the MetricStorageMock.Histogram")
		}
		return (*mm_results).hp1
	}
	if mmHistogram.funcHistogram != nil {
		return mmHistogram.funcHistogram(metric, labels, buckets)
	}
	mmHistogram.t.Fatalf("Unexpected call to MetricStorageMock.Histogram. %v %v %v", metric, labels, buckets)
	return
}

// HistogramAfterCounter returns a count of finished MetricStorageMock.Histogram invocations
func (mmHistogram *MetricStorageMock) HistogramAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogram.afterHistogramCounter)
}

// HistogramBeforeCounter returns a count of MetricStorageMock.Histogram invocations
func (mmHistogram *MetricStorageMock) HistogramBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogram.beforeHistogramCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.Histogram.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistogram *mMetricStorageMockHistogram) Calls() []*MetricStorageMockHistogramParams {
	mmHistogram.mutex.RLock()

	argCopy := make([]*MetricStorageMockHistogramParams, len(mmHistogram.callArgs))
	copy(argCopy, mmHistogram.callArgs)

	mmHistogram.mutex.RUnlock()

	return argCopy
}

// MinimockHistogramDone returns true if the count of the Histogram invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockHistogramDone() bool {
	if m.HistogramMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistogramMock.invocationsDone()
}

// MinimockHistogramInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockHistogramInspect() {
	for _, e := range m.HistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.Histogram at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistogramCounter := mm_atomic.LoadUint64(&m.afterHistogramCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistogramMock.defaultExpectation != nil && afterHistogramCounter < 1 {
		if m.HistogramMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.Histogram at\n%s", m.HistogramMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.Histogram at\n%s with params: %#v", m.HistogramMock.defaultExpectation.expectationOrigins.origin, *m.HistogramMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistogram != nil && afterHistogramCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.Histogram at\n%s", m.funcHistogramOrigin)
	}

	if !m.HistogramMock.invocationsDone() && afterHistogramCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.Histogram at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistogramMock.expectedInvocations), m.HistogramMock.expectedInvocationsOrigin, afterHistogramCounter)
	}
}

type mMetricStorageMockHistogramObserve struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockHistogramObserveExpectation
	expectations       []*MetricStorageMockHistogramObserveExpectation

	callArgs []*MetricStorageMockHistogramObserveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockHistogramObserveExpectation specifies expectation struct of the MetricStorage.HistogramObserve
type MetricStorageMockHistogramObserveExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockHistogramObserveParams
	paramPtrs          *MetricStorageMockHistogramObserveParamPtrs
	expectationOrigins MetricStorageMockHistogramObserveExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// MetricStorageMockHistogramObserveParams contains parameters of the MetricStorage.HistogramObserve
type MetricStorageMockHistogramObserveParams struct {
	metric  string
	value   float64
	labels  map[string]string
	buckets []float64
}

// MetricStorageMockHistogramObserveParamPtrs contains pointers to parameters of the MetricStorage.HistogramObserve
type MetricStorageMockHistogramObserveParamPtrs struct {
	metric  *string
	value   *float64
	labels  *map[string]string
	buckets *[]float64
}

// MetricStorageMockHistogramObserveOrigins contains origins of expectations of the MetricStorage.HistogramObserve
type MetricStorageMockHistogramObserveExpectationOrigins struct {
	origin        string
	originMetric  string
	originValue   string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) Optional() *mMetricStorageMockHistogramObserve {
	mmHistogramObserve.optional = true
	return mmHistogramObserve
}

// Expect sets up expected params for MetricStorage.HistogramObserve
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) Expect(metric string, value float64, labels map[string]string, buckets []float64) *mMetricStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &MetricStorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by ExpectParams functions")
	}

	mmHistogramObserve.defaultExpectation.params = &MetricStorageMockHistogramObserveParams{metric, value, labels, buckets}
	mmHistogramObserve.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmHistogramObserve.expectations {
		if minimock.Equal(e.params, mmHistogramObserve.defaultExpectation.params) {
			mmHistogramObserve.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHistogramObserve.defaultExpectation.params)
		}
	}

	return mmHistogramObserve
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.HistogramObserve
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) ExpectMetricParam1(metric string) *mMetricStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &MetricStorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &MetricStorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.metric = &metric
	mmHistogramObserve.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectValueParam2 sets up expected param value for MetricStorage.HistogramObserve
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) ExpectValueParam2(value float64) *mMetricStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &MetricStorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &MetricStorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.value = &value
	mmHistogramObserve.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectLabelsParam3 sets up expected param labels for MetricStorage.HistogramObserve
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) ExpectLabelsParam3(labels map[string]string) *mMetricStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &MetricStorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &MetricStorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.labels = &labels
	mmHistogramObserve.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// ExpectBucketsParam4 sets up expected param buckets for MetricStorage.HistogramObserve
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) ExpectBucketsParam4(buckets []float64) *mMetricStorageMockHistogramObserve {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &MetricStorageMockHistogramObserveExpectation{}
	}

	if mmHistogramObserve.defaultExpectation.params != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Expect")
	}

	if mmHistogramObserve.defaultExpectation.paramPtrs == nil {
		mmHistogramObserve.defaultExpectation.paramPtrs = &MetricStorageMockHistogramObserveParamPtrs{}
	}
	mmHistogramObserve.defaultExpectation.paramPtrs.buckets = &buckets
	mmHistogramObserve.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmHistogramObserve
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.HistogramObserve
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) Inspect(f func(metric string, value float64, labels map[string]string, buckets []float64)) *mMetricStorageMockHistogramObserve {
	if mmHistogramObserve.mock.inspectFuncHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.HistogramObserve")
	}

	mmHistogramObserve.mock.inspectFuncHistogramObserve = f

	return mmHistogramObserve
}

// Return sets up results that will be returned by MetricStorage.HistogramObserve
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) Return() *MetricStorageMock {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Set")
	}

	if mmHistogramObserve.defaultExpectation == nil {
		mmHistogramObserve.defaultExpectation = &MetricStorageMockHistogramObserveExpectation{mock: mmHistogramObserve.mock}
	}

	mmHistogramObserve.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve.mock
}

// Set uses given function f to mock the MetricStorage.HistogramObserve method
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) Set(f func(metric string, value float64, labels map[string]string, buckets []float64)) *MetricStorageMock {
	if mmHistogramObserve.defaultExpectation != nil {
		mmHistogramObserve.mock.t.Fatalf("Default expectation is already set for the MetricStorage.HistogramObserve method")
	}

	if len(mmHistogramObserve.expectations) > 0 {
		mmHistogramObserve.mock.t.Fatalf("Some expectations are already set for the MetricStorage.HistogramObserve method")
	}

	mmHistogramObserve.mock.funcHistogramObserve = f
	mmHistogramObserve.mock.funcHistogramObserveOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve.mock
}

// When sets expectation for the MetricStorage.HistogramObserve which will trigger the result defined by the following
// Then helper
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) When(metric string, value float64, labels map[string]string, buckets []float64) *MetricStorageMockHistogramObserveExpectation {
	if mmHistogramObserve.mock.funcHistogramObserve != nil {
		mmHistogramObserve.mock.t.Fatalf("MetricStorageMock.HistogramObserve mock is already set by Set")
	}

	expectation := &MetricStorageMockHistogramObserveExpectation{
		mock:               mmHistogramObserve.mock,
		params:             &MetricStorageMockHistogramObserveParams{metric, value, labels, buckets},
		expectationOrigins: MetricStorageMockHistogramObserveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmHistogramObserve.expectations = append(mmHistogramObserve.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.HistogramObserve return parameters for the expectation previously defined by the When method

func (e *MetricStorageMockHistogramObserveExpectation) Then() *MetricStorageMock {
	return e.mock
}

// Times sets number of times MetricStorage.HistogramObserve should be invoked
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) Times(n uint64) *mMetricStorageMockHistogramObserve {
	if n == 0 {
		mmHistogramObserve.mock.t.Fatalf("Times of MetricStorageMock.HistogramObserve mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmHistogramObserve.expectedInvocations, n)
	mmHistogramObserve.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmHistogramObserve
}

func (mmHistogramObserve *mMetricStorageMockHistogramObserve) invocationsDone() bool {
	if len(mmHistogramObserve.expectations) == 0 && mmHistogramObserve.defaultExpectation == nil && mmHistogramObserve.mock.funcHistogramObserve == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmHistogramObserve.mock.afterHistogramObserveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmHistogramObserve.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// HistogramObserve implements mm_pkg.MetricStorage
func (mmHistogramObserve *MetricStorageMock) HistogramObserve(metric string, value float64, labels map[string]string, buckets []float64) {
	mm_atomic.AddUint64(&mmHistogramObserve.beforeHistogramObserveCounter, 1)
	defer mm_atomic.AddUint64(&mmHistogramObserve.afterHistogramObserveCounter, 1)

	mmHistogramObserve.t.Helper()

	if mmHistogramObserve.inspectFuncHistogramObserve != nil {
		mmHistogramObserve.inspectFuncHistogramObserve(metric, value, labels, buckets)
	}

	mm_params := MetricStorageMockHistogramObserveParams{metric, value, labels, buckets}

	// Record call args
	mmHistogramObserve.HistogramObserveMock.mutex.Lock()
	mmHistogramObserve.HistogramObserveMock.callArgs = append(mmHistogramObserve.HistogramObserveMock.callArgs, &mm_params)
	mmHistogramObserve.HistogramObserveMock.mutex.Unlock()

	for _, e := range mmHistogramObserve.HistogramObserveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmHistogramObserve.HistogramObserveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHistogramObserve.HistogramObserveMock.defaultExpectation.Counter, 1)
		mm_want := mmHistogramObserve.HistogramObserveMock.defaultExpectation.params
		mm_want_ptrs := mmHistogramObserve.HistogramObserveMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockHistogramObserveParams{metric, value, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmHistogramObserve.t.Errorf("MetricStorageMock.HistogramObserve got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmHistogramObserve.t.Errorf("MetricStorageMock.HistogramObserve got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmHistogramObserve.t.Errorf("MetricStorageMock.HistogramObserve got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmHistogramObserve.t.Errorf("MetricStorageMock.HistogramObserve got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHistogramObserve.t.Errorf("MetricStorageMock.HistogramObserve got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmHistogramObserve.HistogramObserveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmHistogramObserve.funcHistogramObserve != nil {
		mmHistogramObserve.funcHistogramObserve(metric, value, labels, buckets)
		return
	}
	mmHistogramObserve.t.Fatalf("Unexpected call to MetricStorageMock.HistogramObserve. %v %v %v %v", metric, value, labels, buckets)

}

// HistogramObserveAfterCounter returns a count of finished MetricStorageMock.HistogramObserve invocations
func (mmHistogramObserve *MetricStorageMock) HistogramObserveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogramObserve.afterHistogramObserveCounter)
}

// HistogramObserveBeforeCounter returns a count of MetricStorageMock.HistogramObserve invocations
func (mmHistogramObserve *MetricStorageMock) HistogramObserveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHistogramObserve.beforeHistogramObserveCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.HistogramObserve.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHistogramObserve *mMetricStorageMockHistogramObserve) Calls() []*MetricStorageMockHistogramObserveParams {
	mmHistogramObserve.mutex.RLock()

	argCopy := make([]*MetricStorageMockHistogramObserveParams, len(mmHistogramObserve.callArgs))
	copy(argCopy, mmHistogramObserve.callArgs)

	mmHistogramObserve.mutex.RUnlock()

	return argCopy
}

// MinimockHistogramObserveDone returns true if the count of the HistogramObserve invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockHistogramObserveDone() bool {
	if m.HistogramObserveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.HistogramObserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.HistogramObserveMock.invocationsDone()
}

// MinimockHistogramObserveInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockHistogramObserveInspect() {
	for _, e := range m.HistogramObserveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.HistogramObserve at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterHistogramObserveCounter := mm_atomic.LoadUint64(&m.afterHistogramObserveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.HistogramObserveMock.defaultExpectation != nil && afterHistogramObserveCounter < 1 {
		if m.HistogramObserveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.HistogramObserve at\n%s", m.HistogramObserveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.HistogramObserve at\n%s with params: %#v", m.HistogramObserveMock.defaultExpectation.expectationOrigins.origin, *m.HistogramObserveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHistogramObserve != nil && afterHistogramObserveCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.HistogramObserve at\n%s", m.funcHistogramObserveOrigin)
	}

	if !m.HistogramObserveMock.invocationsDone() && afterHistogramObserveCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.HistogramObserve at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.HistogramObserveMock.expectedInvocations), m.HistogramObserveMock.expectedInvocationsOrigin, afterHistogramObserveCounter)
	}
}

type mMetricStorageMockRegisterCounter struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockRegisterCounterExpectation
	expectations       []*MetricStorageMockRegisterCounterExpectation

	callArgs []*MetricStorageMockRegisterCounterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockRegisterCounterExpectation specifies expectation struct of the MetricStorage.RegisterCounter
type MetricStorageMockRegisterCounterExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockRegisterCounterParams
	paramPtrs          *MetricStorageMockRegisterCounterParamPtrs
	expectationOrigins MetricStorageMockRegisterCounterExpectationOrigins
	results            *MetricStorageMockRegisterCounterResults
	returnOrigin       string
	Counter            uint64
}

// MetricStorageMockRegisterCounterParams contains parameters of the MetricStorage.RegisterCounter
type MetricStorageMockRegisterCounterParams struct {
	metric string
	labels map[string]string
}

// MetricStorageMockRegisterCounterParamPtrs contains pointers to parameters of the MetricStorage.RegisterCounter
type MetricStorageMockRegisterCounterParamPtrs struct {
	metric *string
	labels *map[string]string
}

// MetricStorageMockRegisterCounterResults contains results of the MetricStorage.RegisterCounter
type MetricStorageMockRegisterCounterResults struct {
	cp1 *prometheus.CounterVec
}

// MetricStorageMockRegisterCounterOrigins contains origins of expectations of the MetricStorage.RegisterCounter
type MetricStorageMockRegisterCounterExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) Optional() *mMetricStorageMockRegisterCounter {
	mmRegisterCounter.optional = true
	return mmRegisterCounter
}

// Expect sets up expected params for MetricStorage.RegisterCounter
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) Expect(metric string, labels map[string]string) *mMetricStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("MetricStorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &MetricStorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs != nil {
		mmRegisterCounter.mock.t.Fatalf("MetricStorageMock.RegisterCounter mock is already set by ExpectParams functions")
	}

	mmRegisterCounter.defaultExpectation.params = &MetricStorageMockRegisterCounterParams{metric, labels}
	mmRegisterCounter.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterCounter.expectations {
		if minimock.Equal(e.params, mmRegisterCounter.defaultExpectation.params) {
			mmRegisterCounter.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterCounter.defaultExpectation.params)
		}
	}

	return mmRegisterCounter
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.RegisterCounter
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) ExpectMetricParam1(metric string) *mMetricStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("MetricStorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &MetricStorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.params != nil {
		mmRegisterCounter.mock.t.Fatalf("MetricStorageMock.RegisterCounter mock is already set by Expect")
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs == nil {
		mmRegisterCounter.defaultExpectation.paramPtrs = &MetricStorageMockRegisterCounterParamPtrs{}
	}
	mmRegisterCounter.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterCounter.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterCounter
}

// ExpectLabelsParam2 sets up expected param labels for MetricStorage.RegisterCounter
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) ExpectLabelsParam2(labels map[string]string) *mMetricStorageMockRegisterCounter {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("MetricStorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &MetricStorageMockRegisterCounterExpectation{}
	}

	if mmRegisterCounter.defaultExpectation.params != nil {
		mmRegisterCounter.mock.t.Fatalf("MetricStorageMock.RegisterCounter mock is already set by Expect")
	}

	if mmRegisterCounter.defaultExpectation.paramPtrs == nil {
		mmRegisterCounter.defaultExpectation.paramPtrs = &MetricStorageMockRegisterCounterParamPtrs{}
	}
	mmRegisterCounter.defaultExpectation.paramPtrs.labels = &labels
	mmRegisterCounter.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmRegisterCounter
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.RegisterCounter
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) Inspect(f func(metric string, labels map[string]string)) *mMetricStorageMockRegisterCounter {
	if mmRegisterCounter.mock.inspectFuncRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.RegisterCounter")
	}

	mmRegisterCounter.mock.inspectFuncRegisterCounter = f

	return mmRegisterCounter
}

// Return sets up results that will be returned by MetricStorage.RegisterCounter
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) Return(cp1 *prometheus.CounterVec) *MetricStorageMock {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("MetricStorageMock.RegisterCounter mock is already set by Set")
	}

	if mmRegisterCounter.defaultExpectation == nil {
		mmRegisterCounter.defaultExpectation = &MetricStorageMockRegisterCounterExpectation{mock: mmRegisterCounter.mock}
	}
	mmRegisterCounter.defaultExpectation.results = &MetricStorageMockRegisterCounterResults{cp1}
	mmRegisterCounter.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter.mock
}

// Set uses given function f to mock the MetricStorage.RegisterCounter method
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) Set(f func(metric string, labels map[string]string) (cp1 *prometheus.CounterVec)) *MetricStorageMock {
	if mmRegisterCounter.defaultExpectation != nil {
		mmRegisterCounter.mock.t.Fatalf("Default expectation is already set for the MetricStorage.RegisterCounter method")
	}

	if len(mmRegisterCounter.expectations) > 0 {
		mmRegisterCounter.mock.t.Fatalf("Some expectations are already set for the MetricStorage.RegisterCounter method")
	}

	mmRegisterCounter.mock.funcRegisterCounter = f
	mmRegisterCounter.mock.funcRegisterCounterOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter.mock
}

// When sets expectation for the MetricStorage.RegisterCounter which will trigger the result defined by the following
// Then helper
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) When(metric string, labels map[string]string) *MetricStorageMockRegisterCounterExpectation {
	if mmRegisterCounter.mock.funcRegisterCounter != nil {
		mmRegisterCounter.mock.t.Fatalf("MetricStorageMock.RegisterCounter mock is already set by Set")
	}

	expectation := &MetricStorageMockRegisterCounterExpectation{
		mock:               mmRegisterCounter.mock,
		params:             &MetricStorageMockRegisterCounterParams{metric, labels},
		expectationOrigins: MetricStorageMockRegisterCounterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterCounter.expectations = append(mmRegisterCounter.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.RegisterCounter return parameters for the expectation previously defined by the When method
func (e *MetricStorageMockRegisterCounterExpectation) Then(cp1 *prometheus.CounterVec) *MetricStorageMock {
	e.results = &MetricStorageMockRegisterCounterResults{cp1}
	return e.mock
}

// Times sets number of times MetricStorage.RegisterCounter should be invoked
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) Times(n uint64) *mMetricStorageMockRegisterCounter {
	if n == 0 {
		mmRegisterCounter.mock.t.Fatalf("Times of MetricStorageMock.RegisterCounter mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterCounter.expectedInvocations, n)
	mmRegisterCounter.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterCounter
}

func (mmRegisterCounter *mMetricStorageMockRegisterCounter) invocationsDone() bool {
	if len(mmRegisterCounter.expectations) == 0 && mmRegisterCounter.defaultExpectation == nil && mmRegisterCounter.mock.funcRegisterCounter == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterCounter.mock.afterRegisterCounterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterCounter.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterCounter implements mm_pkg.MetricStorage
func (mmRegisterCounter *MetricStorageMock) RegisterCounter(metric string, labels map[string]string) (cp1 *prometheus.CounterVec) {
	mm_atomic.AddUint64(&mmRegisterCounter.beforeRegisterCounterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterCounter.afterRegisterCounterCounter, 1)

	mmRegisterCounter.t.Helper()

	if mmRegisterCounter.inspectFuncRegisterCounter != nil {
		mmRegisterCounter.inspectFuncRegisterCounter(metric, labels)
	}

	mm_params := MetricStorageMockRegisterCounterParams{metric, labels}

	// Record call args
	mmRegisterCounter.RegisterCounterMock.mutex.Lock()
	mmRegisterCounter.RegisterCounterMock.callArgs = append(mmRegisterCounter.RegisterCounterMock.callArgs, &mm_params)
	mmRegisterCounter.RegisterCounterMock.mutex.Unlock()

	for _, e := range mmRegisterCounter.RegisterCounterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1
		}
	}

	if mmRegisterCounter.RegisterCounterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterCounter.RegisterCounterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterCounter.RegisterCounterMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterCounter.RegisterCounterMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockRegisterCounterParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterCounter.t.Errorf("MetricStorageMock.RegisterCounter got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmRegisterCounter.t.Errorf("MetricStorageMock.RegisterCounter got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterCounter.t.Errorf("MetricStorageMock.RegisterCounter got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterCounter.RegisterCounterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterCounter.RegisterCounterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterCounter.t.Fatal("No results are set for the MetricStorageMock.RegisterCounter")
		}
		return (*mm_results).cp1
	}
	if mmRegisterCounter.funcRegisterCounter != nil {
		return mmRegisterCounter.funcRegisterCounter(metric, labels)
	}
	mmRegisterCounter.t.Fatalf("Unexpected call to MetricStorageMock.RegisterCounter. %v %v", metric, labels)
	return
}

// RegisterCounterAfterCounter returns a count of finished MetricStorageMock.RegisterCounter invocations
func (mmRegisterCounter *MetricStorageMock) RegisterCounterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCounter.afterRegisterCounterCounter)
}

// RegisterCounterBeforeCounter returns a count of MetricStorageMock.RegisterCounter invocations
func (mmRegisterCounter *MetricStorageMock) RegisterCounterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterCounter.beforeRegisterCounterCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.RegisterCounter.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterCounter *mMetricStorageMockRegisterCounter) Calls() []*MetricStorageMockRegisterCounterParams {
	mmRegisterCounter.mutex.RLock()

	argCopy := make([]*MetricStorageMockRegisterCounterParams, len(mmRegisterCounter.callArgs))
	copy(argCopy, mmRegisterCounter.callArgs)

	mmRegisterCounter.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterCounterDone returns true if the count of the RegisterCounter invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockRegisterCounterDone() bool {
	if m.RegisterCounterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterCounterMock.invocationsDone()
}

// MinimockRegisterCounterInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockRegisterCounterInspect() {
	for _, e := range m.RegisterCounterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.RegisterCounter at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterCounterCounter := mm_atomic.LoadUint64(&m.afterRegisterCounterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterCounterMock.defaultExpectation != nil && afterRegisterCounterCounter < 1 {
		if m.RegisterCounterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.RegisterCounter at\n%s", m.RegisterCounterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.RegisterCounter at\n%s with params: %#v", m.RegisterCounterMock.defaultExpectation.expectationOrigins.origin, *m.RegisterCounterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterCounter != nil && afterRegisterCounterCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.RegisterCounter at\n%s", m.funcRegisterCounterOrigin)
	}

	if !m.RegisterCounterMock.invocationsDone() && afterRegisterCounterCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.RegisterCounter at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterCounterMock.expectedInvocations), m.RegisterCounterMock.expectedInvocationsOrigin, afterRegisterCounterCounter)
	}
}

type mMetricStorageMockRegisterGauge struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockRegisterGaugeExpectation
	expectations       []*MetricStorageMockRegisterGaugeExpectation

	callArgs []*MetricStorageMockRegisterGaugeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockRegisterGaugeExpectation specifies expectation struct of the MetricStorage.RegisterGauge
type MetricStorageMockRegisterGaugeExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockRegisterGaugeParams
	paramPtrs          *MetricStorageMockRegisterGaugeParamPtrs
	expectationOrigins MetricStorageMockRegisterGaugeExpectationOrigins
	results            *MetricStorageMockRegisterGaugeResults
	returnOrigin       string
	Counter            uint64
}

// MetricStorageMockRegisterGaugeParams contains parameters of the MetricStorage.RegisterGauge
type MetricStorageMockRegisterGaugeParams struct {
	metric string
	labels map[string]string
}

// MetricStorageMockRegisterGaugeParamPtrs contains pointers to parameters of the MetricStorage.RegisterGauge
type MetricStorageMockRegisterGaugeParamPtrs struct {
	metric *string
	labels *map[string]string
}

// MetricStorageMockRegisterGaugeResults contains results of the MetricStorage.RegisterGauge
type MetricStorageMockRegisterGaugeResults struct {
	gp1 *prometheus.GaugeVec
}

// MetricStorageMockRegisterGaugeOrigins contains origins of expectations of the MetricStorage.RegisterGauge
type MetricStorageMockRegisterGaugeExpectationOrigins struct {
	origin       string
	originMetric string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) Optional() *mMetricStorageMockRegisterGauge {
	mmRegisterGauge.optional = true
	return mmRegisterGauge
}

// Expect sets up expected params for MetricStorage.RegisterGauge
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) Expect(metric string, labels map[string]string) *mMetricStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("MetricStorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &MetricStorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs != nil {
		mmRegisterGauge.mock.t.Fatalf("MetricStorageMock.RegisterGauge mock is already set by ExpectParams functions")
	}

	mmRegisterGauge.defaultExpectation.params = &MetricStorageMockRegisterGaugeParams{metric, labels}
	mmRegisterGauge.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterGauge.expectations {
		if minimock.Equal(e.params, mmRegisterGauge.defaultExpectation.params) {
			mmRegisterGauge.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterGauge.defaultExpectation.params)
		}
	}

	return mmRegisterGauge
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.RegisterGauge
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) ExpectMetricParam1(metric string) *mMetricStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("MetricStorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &MetricStorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.params != nil {
		mmRegisterGauge.mock.t.Fatalf("MetricStorageMock.RegisterGauge mock is already set by Expect")
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs == nil {
		mmRegisterGauge.defaultExpectation.paramPtrs = &MetricStorageMockRegisterGaugeParamPtrs{}
	}
	mmRegisterGauge.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterGauge.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterGauge
}

// ExpectLabelsParam2 sets up expected param labels for MetricStorage.RegisterGauge
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) ExpectLabelsParam2(labels map[string]string) *mMetricStorageMockRegisterGauge {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("MetricStorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &MetricStorageMockRegisterGaugeExpectation{}
	}

	if mmRegisterGauge.defaultExpectation.params != nil {
		mmRegisterGauge.mock.t.Fatalf("MetricStorageMock.RegisterGauge mock is already set by Expect")
	}

	if mmRegisterGauge.defaultExpectation.paramPtrs == nil {
		mmRegisterGauge.defaultExpectation.paramPtrs = &MetricStorageMockRegisterGaugeParamPtrs{}
	}
	mmRegisterGauge.defaultExpectation.paramPtrs.labels = &labels
	mmRegisterGauge.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmRegisterGauge
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.RegisterGauge
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) Inspect(f func(metric string, labels map[string]string)) *mMetricStorageMockRegisterGauge {
	if mmRegisterGauge.mock.inspectFuncRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.RegisterGauge")
	}

	mmRegisterGauge.mock.inspectFuncRegisterGauge = f

	return mmRegisterGauge
}

// Return sets up results that will be returned by MetricStorage.RegisterGauge
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) Return(gp1 *prometheus.GaugeVec) *MetricStorageMock {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("MetricStorageMock.RegisterGauge mock is already set by Set")
	}

	if mmRegisterGauge.defaultExpectation == nil {
		mmRegisterGauge.defaultExpectation = &MetricStorageMockRegisterGaugeExpectation{mock: mmRegisterGauge.mock}
	}
	mmRegisterGauge.defaultExpectation.results = &MetricStorageMockRegisterGaugeResults{gp1}
	mmRegisterGauge.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge.mock
}

// Set uses given function f to mock the MetricStorage.RegisterGauge method
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) Set(f func(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec)) *MetricStorageMock {
	if mmRegisterGauge.defaultExpectation != nil {
		mmRegisterGauge.mock.t.Fatalf("Default expectation is already set for the MetricStorage.RegisterGauge method")
	}

	if len(mmRegisterGauge.expectations) > 0 {
		mmRegisterGauge.mock.t.Fatalf("Some expectations are already set for the MetricStorage.RegisterGauge method")
	}

	mmRegisterGauge.mock.funcRegisterGauge = f
	mmRegisterGauge.mock.funcRegisterGaugeOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge.mock
}

// When sets expectation for the MetricStorage.RegisterGauge which will trigger the result defined by the following
// Then helper
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) When(metric string, labels map[string]string) *MetricStorageMockRegisterGaugeExpectation {
	if mmRegisterGauge.mock.funcRegisterGauge != nil {
		mmRegisterGauge.mock.t.Fatalf("MetricStorageMock.RegisterGauge mock is already set by Set")
	}

	expectation := &MetricStorageMockRegisterGaugeExpectation{
		mock:               mmRegisterGauge.mock,
		params:             &MetricStorageMockRegisterGaugeParams{metric, labels},
		expectationOrigins: MetricStorageMockRegisterGaugeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterGauge.expectations = append(mmRegisterGauge.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.RegisterGauge return parameters for the expectation previously defined by the When method
func (e *MetricStorageMockRegisterGaugeExpectation) Then(gp1 *prometheus.GaugeVec) *MetricStorageMock {
	e.results = &MetricStorageMockRegisterGaugeResults{gp1}
	return e.mock
}

// Times sets number of times MetricStorage.RegisterGauge should be invoked
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) Times(n uint64) *mMetricStorageMockRegisterGauge {
	if n == 0 {
		mmRegisterGauge.mock.t.Fatalf("Times of MetricStorageMock.RegisterGauge mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterGauge.expectedInvocations, n)
	mmRegisterGauge.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterGauge
}

func (mmRegisterGauge *mMetricStorageMockRegisterGauge) invocationsDone() bool {
	if len(mmRegisterGauge.expectations) == 0 && mmRegisterGauge.defaultExpectation == nil && mmRegisterGauge.mock.funcRegisterGauge == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterGauge.mock.afterRegisterGaugeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterGauge.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterGauge implements mm_pkg.MetricStorage
func (mmRegisterGauge *MetricStorageMock) RegisterGauge(metric string, labels map[string]string) (gp1 *prometheus.GaugeVec) {
	mm_atomic.AddUint64(&mmRegisterGauge.beforeRegisterGaugeCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterGauge.afterRegisterGaugeCounter, 1)

	mmRegisterGauge.t.Helper()

	if mmRegisterGauge.inspectFuncRegisterGauge != nil {
		mmRegisterGauge.inspectFuncRegisterGauge(metric, labels)
	}

	mm_params := MetricStorageMockRegisterGaugeParams{metric, labels}

	// Record call args
	mmRegisterGauge.RegisterGaugeMock.mutex.Lock()
	mmRegisterGauge.RegisterGaugeMock.callArgs = append(mmRegisterGauge.RegisterGaugeMock.callArgs, &mm_params)
	mmRegisterGauge.RegisterGaugeMock.mutex.Unlock()

	for _, e := range mmRegisterGauge.RegisterGaugeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1
		}
	}

	if mmRegisterGauge.RegisterGaugeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterGauge.RegisterGaugeMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockRegisterGaugeParams{metric, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterGauge.t.Errorf("MetricStorageMock.RegisterGauge got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmRegisterGauge.t.Errorf("MetricStorageMock.RegisterGauge got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterGauge.t.Errorf("MetricStorageMock.RegisterGauge got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterGauge.RegisterGaugeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterGauge.RegisterGaugeMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterGauge.t.Fatal("No results are set for the MetricStorageMock.RegisterGauge")
		}
		return (*mm_results).gp1
	}
	if mmRegisterGauge.funcRegisterGauge != nil {
		return mmRegisterGauge.funcRegisterGauge(metric, labels)
	}
	mmRegisterGauge.t.Fatalf("Unexpected call to MetricStorageMock.RegisterGauge. %v %v", metric, labels)
	return
}

// RegisterGaugeAfterCounter returns a count of finished MetricStorageMock.RegisterGauge invocations
func (mmRegisterGauge *MetricStorageMock) RegisterGaugeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterGauge.afterRegisterGaugeCounter)
}

// RegisterGaugeBeforeCounter returns a count of MetricStorageMock.RegisterGauge invocations
func (mmRegisterGauge *MetricStorageMock) RegisterGaugeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterGauge.beforeRegisterGaugeCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.RegisterGauge.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterGauge *mMetricStorageMockRegisterGauge) Calls() []*MetricStorageMockRegisterGaugeParams {
	mmRegisterGauge.mutex.RLock()

	argCopy := make([]*MetricStorageMockRegisterGaugeParams, len(mmRegisterGauge.callArgs))
	copy(argCopy, mmRegisterGauge.callArgs)

	mmRegisterGauge.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterGaugeDone returns true if the count of the RegisterGauge invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockRegisterGaugeDone() bool {
	if m.RegisterGaugeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterGaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterGaugeMock.invocationsDone()
}

// MinimockRegisterGaugeInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockRegisterGaugeInspect() {
	for _, e := range m.RegisterGaugeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.RegisterGauge at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterGaugeCounter := mm_atomic.LoadUint64(&m.afterRegisterGaugeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterGaugeMock.defaultExpectation != nil && afterRegisterGaugeCounter < 1 {
		if m.RegisterGaugeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.RegisterGauge at\n%s", m.RegisterGaugeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.RegisterGauge at\n%s with params: %#v", m.RegisterGaugeMock.defaultExpectation.expectationOrigins.origin, *m.RegisterGaugeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterGauge != nil && afterRegisterGaugeCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.RegisterGauge at\n%s", m.funcRegisterGaugeOrigin)
	}

	if !m.RegisterGaugeMock.invocationsDone() && afterRegisterGaugeCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.RegisterGauge at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterGaugeMock.expectedInvocations), m.RegisterGaugeMock.expectedInvocationsOrigin, afterRegisterGaugeCounter)
	}
}

type mMetricStorageMockRegisterHistogram struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockRegisterHistogramExpectation
	expectations       []*MetricStorageMockRegisterHistogramExpectation

	callArgs []*MetricStorageMockRegisterHistogramParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockRegisterHistogramExpectation specifies expectation struct of the MetricStorage.RegisterHistogram
type MetricStorageMockRegisterHistogramExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockRegisterHistogramParams
	paramPtrs          *MetricStorageMockRegisterHistogramParamPtrs
	expectationOrigins MetricStorageMockRegisterHistogramExpectationOrigins
	results            *MetricStorageMockRegisterHistogramResults
	returnOrigin       string
	Counter            uint64
}

// MetricStorageMockRegisterHistogramParams contains parameters of the MetricStorage.RegisterHistogram
type MetricStorageMockRegisterHistogramParams struct {
	metric  string
	labels  map[string]string
	buckets []float64
}

// MetricStorageMockRegisterHistogramParamPtrs contains pointers to parameters of the MetricStorage.RegisterHistogram
type MetricStorageMockRegisterHistogramParamPtrs struct {
	metric  *string
	labels  *map[string]string
	buckets *[]float64
}

// MetricStorageMockRegisterHistogramResults contains results of the MetricStorage.RegisterHistogram
type MetricStorageMockRegisterHistogramResults struct {
	hp1 *prometheus.HistogramVec
}

// MetricStorageMockRegisterHistogramOrigins contains origins of expectations of the MetricStorage.RegisterHistogram
type MetricStorageMockRegisterHistogramExpectationOrigins struct {
	origin        string
	originMetric  string
	originLabels  string
	originBuckets string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) Optional() *mMetricStorageMockRegisterHistogram {
	mmRegisterHistogram.optional = true
	return mmRegisterHistogram
}

// Expect sets up expected params for MetricStorage.RegisterHistogram
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) Expect(metric string, labels map[string]string, buckets []float64) *mMetricStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &MetricStorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by ExpectParams functions")
	}

	mmRegisterHistogram.defaultExpectation.params = &MetricStorageMockRegisterHistogramParams{metric, labels, buckets}
	mmRegisterHistogram.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegisterHistogram.expectations {
		if minimock.Equal(e.params, mmRegisterHistogram.defaultExpectation.params) {
			mmRegisterHistogram.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegisterHistogram.defaultExpectation.params)
		}
	}

	return mmRegisterHistogram
}

// ExpectMetricParam1 sets up expected param metric for MetricStorage.RegisterHistogram
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) ExpectMetricParam1(metric string) *mMetricStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &MetricStorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &MetricStorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.metric = &metric
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originMetric = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// ExpectLabelsParam2 sets up expected param labels for MetricStorage.RegisterHistogram
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) ExpectLabelsParam2(labels map[string]string) *mMetricStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &MetricStorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &MetricStorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.labels = &labels
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// ExpectBucketsParam3 sets up expected param buckets for MetricStorage.RegisterHistogram
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) ExpectBucketsParam3(buckets []float64) *mMetricStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &MetricStorageMockRegisterHistogramExpectation{}
	}

	if mmRegisterHistogram.defaultExpectation.params != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by Expect")
	}

	if mmRegisterHistogram.defaultExpectation.paramPtrs == nil {
		mmRegisterHistogram.defaultExpectation.paramPtrs = &MetricStorageMockRegisterHistogramParamPtrs{}
	}
	mmRegisterHistogram.defaultExpectation.paramPtrs.buckets = &buckets
	mmRegisterHistogram.defaultExpectation.expectationOrigins.originBuckets = minimock.CallerInfo(1)

	return mmRegisterHistogram
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.RegisterHistogram
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) Inspect(f func(metric string, labels map[string]string, buckets []float64)) *mMetricStorageMockRegisterHistogram {
	if mmRegisterHistogram.mock.inspectFuncRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.RegisterHistogram")
	}

	mmRegisterHistogram.mock.inspectFuncRegisterHistogram = f

	return mmRegisterHistogram
}

// Return sets up results that will be returned by MetricStorage.RegisterHistogram
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) Return(hp1 *prometheus.HistogramVec) *MetricStorageMock {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by Set")
	}

	if mmRegisterHistogram.defaultExpectation == nil {
		mmRegisterHistogram.defaultExpectation = &MetricStorageMockRegisterHistogramExpectation{mock: mmRegisterHistogram.mock}
	}
	mmRegisterHistogram.defaultExpectation.results = &MetricStorageMockRegisterHistogramResults{hp1}
	mmRegisterHistogram.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram.mock
}

// Set uses given function f to mock the MetricStorage.RegisterHistogram method
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) Set(f func(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec)) *MetricStorageMock {
	if mmRegisterHistogram.defaultExpectation != nil {
		mmRegisterHistogram.mock.t.Fatalf("Default expectation is already set for the MetricStorage.RegisterHistogram method")
	}

	if len(mmRegisterHistogram.expectations) > 0 {
		mmRegisterHistogram.mock.t.Fatalf("Some expectations are already set for the MetricStorage.RegisterHistogram method")
	}

	mmRegisterHistogram.mock.funcRegisterHistogram = f
	mmRegisterHistogram.mock.funcRegisterHistogramOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram.mock
}

// When sets expectation for the MetricStorage.RegisterHistogram which will trigger the result defined by the following
// Then helper
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) When(metric string, labels map[string]string, buckets []float64) *MetricStorageMockRegisterHistogramExpectation {
	if mmRegisterHistogram.mock.funcRegisterHistogram != nil {
		mmRegisterHistogram.mock.t.Fatalf("MetricStorageMock.RegisterHistogram mock is already set by Set")
	}

	expectation := &MetricStorageMockRegisterHistogramExpectation{
		mock:               mmRegisterHistogram.mock,
		params:             &MetricStorageMockRegisterHistogramParams{metric, labels, buckets},
		expectationOrigins: MetricStorageMockRegisterHistogramExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegisterHistogram.expectations = append(mmRegisterHistogram.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.RegisterHistogram return parameters for the expectation previously defined by the When method
func (e *MetricStorageMockRegisterHistogramExpectation) Then(hp1 *prometheus.HistogramVec) *MetricStorageMock {
	e.results = &MetricStorageMockRegisterHistogramResults{hp1}
	return e.mock
}

// Times sets number of times MetricStorage.RegisterHistogram should be invoked
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) Times(n uint64) *mMetricStorageMockRegisterHistogram {
	if n == 0 {
		mmRegisterHistogram.mock.t.Fatalf("Times of MetricStorageMock.RegisterHistogram mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegisterHistogram.expectedInvocations, n)
	mmRegisterHistogram.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegisterHistogram
}

func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) invocationsDone() bool {
	if len(mmRegisterHistogram.expectations) == 0 && mmRegisterHistogram.defaultExpectation == nil && mmRegisterHistogram.mock.funcRegisterHistogram == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegisterHistogram.mock.afterRegisterHistogramCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegisterHistogram.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RegisterHistogram implements mm_pkg.MetricStorage
func (mmRegisterHistogram *MetricStorageMock) RegisterHistogram(metric string, labels map[string]string, buckets []float64) (hp1 *prometheus.HistogramVec) {
	mm_atomic.AddUint64(&mmRegisterHistogram.beforeRegisterHistogramCounter, 1)
	defer mm_atomic.AddUint64(&mmRegisterHistogram.afterRegisterHistogramCounter, 1)

	mmRegisterHistogram.t.Helper()

	if mmRegisterHistogram.inspectFuncRegisterHistogram != nil {
		mmRegisterHistogram.inspectFuncRegisterHistogram(metric, labels, buckets)
	}

	mm_params := MetricStorageMockRegisterHistogramParams{metric, labels, buckets}

	// Record call args
	mmRegisterHistogram.RegisterHistogramMock.mutex.Lock()
	mmRegisterHistogram.RegisterHistogramMock.callArgs = append(mmRegisterHistogram.RegisterHistogramMock.callArgs, &mm_params)
	mmRegisterHistogram.RegisterHistogramMock.mutex.Unlock()

	for _, e := range mmRegisterHistogram.RegisterHistogramMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1
		}
	}

	if mmRegisterHistogram.RegisterHistogramMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.Counter, 1)
		mm_want := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.params
		mm_want_ptrs := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockRegisterHistogramParams{metric, labels, buckets}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.metric != nil && !minimock.Equal(*mm_want_ptrs.metric, mm_got.metric) {
				mmRegisterHistogram.t.Errorf("MetricStorageMock.RegisterHistogram got unexpected parameter metric, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originMetric, *mm_want_ptrs.metric, mm_got.metric, minimock.Diff(*mm_want_ptrs.metric, mm_got.metric))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmRegisterHistogram.t.Errorf("MetricStorageMock.RegisterHistogram got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

			if mm_want_ptrs.buckets != nil && !minimock.Equal(*mm_want_ptrs.buckets, mm_got.buckets) {
				mmRegisterHistogram.t.Errorf("MetricStorageMock.RegisterHistogram got unexpected parameter buckets, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.originBuckets, *mm_want_ptrs.buckets, mm_got.buckets, minimock.Diff(*mm_want_ptrs.buckets, mm_got.buckets))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegisterHistogram.t.Errorf("MetricStorageMock.RegisterHistogram got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegisterHistogram.RegisterHistogramMock.defaultExpectation.results
		if mm_results == nil {
			mmRegisterHistogram.t.Fatal("No results are set for the MetricStorageMock.RegisterHistogram")
		}
		return (*mm_results).hp1
	}
	if mmRegisterHistogram.funcRegisterHistogram != nil {
		return mmRegisterHistogram.funcRegisterHistogram(metric, labels, buckets)
	}
	mmRegisterHistogram.t.Fatalf("Unexpected call to MetricStorageMock.RegisterHistogram. %v %v %v", metric, labels, buckets)
	return
}

// RegisterHistogramAfterCounter returns a count of finished MetricStorageMock.RegisterHistogram invocations
func (mmRegisterHistogram *MetricStorageMock) RegisterHistogramAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterHistogram.afterRegisterHistogramCounter)
}

// RegisterHistogramBeforeCounter returns a count of MetricStorageMock.RegisterHistogram invocations
func (mmRegisterHistogram *MetricStorageMock) RegisterHistogramBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegisterHistogram.beforeRegisterHistogramCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.RegisterHistogram.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegisterHistogram *mMetricStorageMockRegisterHistogram) Calls() []*MetricStorageMockRegisterHistogramParams {
	mmRegisterHistogram.mutex.RLock()

	argCopy := make([]*MetricStorageMockRegisterHistogramParams, len(mmRegisterHistogram.callArgs))
	copy(argCopy, mmRegisterHistogram.callArgs)

	mmRegisterHistogram.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterHistogramDone returns true if the count of the RegisterHistogram invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockRegisterHistogramDone() bool {
	if m.RegisterHistogramMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterHistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterHistogramMock.invocationsDone()
}

// MinimockRegisterHistogramInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockRegisterHistogramInspect() {
	for _, e := range m.RegisterHistogramMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.RegisterHistogram at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterHistogramCounter := mm_atomic.LoadUint64(&m.afterRegisterHistogramCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterHistogramMock.defaultExpectation != nil && afterRegisterHistogramCounter < 1 {
		if m.RegisterHistogramMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.RegisterHistogram at\n%s", m.RegisterHistogramMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.RegisterHistogram at\n%s with params: %#v", m.RegisterHistogramMock.defaultExpectation.expectationOrigins.origin, *m.RegisterHistogramMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegisterHistogram != nil && afterRegisterHistogramCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.RegisterHistogram at\n%s", m.funcRegisterHistogramOrigin)
	}

	if !m.RegisterHistogramMock.invocationsDone() && afterRegisterHistogramCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.RegisterHistogram at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterHistogramMock.expectedInvocations), m.RegisterHistogramMock.expectedInvocationsOrigin, afterRegisterHistogramCounter)
	}
}

type mMetricStorageMockSendBatch struct {
	optional           bool
	mock               *MetricStorageMock
	defaultExpectation *MetricStorageMockSendBatchExpectation
	expectations       []*MetricStorageMockSendBatchExpectation

	callArgs []*MetricStorageMockSendBatchParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MetricStorageMockSendBatchExpectation specifies expectation struct of the MetricStorage.SendBatch
type MetricStorageMockSendBatchExpectation struct {
	mock               *MetricStorageMock
	params             *MetricStorageMockSendBatchParams
	paramPtrs          *MetricStorageMockSendBatchParamPtrs
	expectationOrigins MetricStorageMockSendBatchExpectationOrigins
	results            *MetricStorageMockSendBatchResults
	returnOrigin       string
	Counter            uint64
}

// MetricStorageMockSendBatchParams contains parameters of the MetricStorage.SendBatch
type MetricStorageMockSendBatchParams struct {
	ops    []operation.MetricOperation
	labels map[string]string
}

// MetricStorageMockSendBatchParamPtrs contains pointers to parameters of the MetricStorage.SendBatch
type MetricStorageMockSendBatchParamPtrs struct {
	ops    *[]operation.MetricOperation
	labels *map[string]string
}

// MetricStorageMockSendBatchResults contains results of the MetricStorage.SendBatch
type MetricStorageMockSendBatchResults struct {
	err error
}

// MetricStorageMockSendBatchOrigins contains origins of expectations of the MetricStorage.SendBatch
type MetricStorageMockSendBatchExpectationOrigins struct {
	origin       string
	originOps    string
	originLabels string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSendBatch *mMetricStorageMockSendBatch) Optional() *mMetricStorageMockSendBatch {
	mmSendBatch.optional = true
	return mmSendBatch
}

// Expect sets up expected params for MetricStorage.SendBatch
func (mmSendBatch *mMetricStorageMockSendBatch) Expect(ops []operation.MetricOperation, labels map[string]string) *mMetricStorageMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("MetricStorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &MetricStorageMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.paramPtrs != nil {
		mmSendBatch.mock.t.Fatalf("MetricStorageMock.SendBatch mock is already set by ExpectParams functions")
	}

	mmSendBatch.defaultExpectation.params = &MetricStorageMockSendBatchParams{ops, labels}
	mmSendBatch.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// ExpectOpsParam1 sets up expected param ops for MetricStorage.SendBatch
func (mmSendBatch *mMetricStorageMockSendBatch) ExpectOpsParam1(ops []operation.MetricOperation) *mMetricStorageMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("MetricStorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &MetricStorageMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("MetricStorageMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &MetricStorageMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.ops = &ops
	mmSendBatch.defaultExpectation.expectationOrigins.originOps = minimock.CallerInfo(1)

	return mmSendBatch
}

// ExpectLabelsParam2 sets up expected param labels for MetricStorage.SendBatch
func (mmSendBatch *mMetricStorageMockSendBatch) ExpectLabelsParam2(labels map[string]string) *mMetricStorageMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("MetricStorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &MetricStorageMockSendBatchExpectation{}
	}

	if mmSendBatch.defaultExpectation.params != nil {
		mmSendBatch.mock.t.Fatalf("MetricStorageMock.SendBatch mock is already set by Expect")
	}

	if mmSendBatch.defaultExpectation.paramPtrs == nil {
		mmSendBatch.defaultExpectation.paramPtrs = &MetricStorageMockSendBatchParamPtrs{}
	}
	mmSendBatch.defaultExpectation.paramPtrs.labels = &labels
	mmSendBatch.defaultExpectation.expectationOrigins.originLabels = minimock.CallerInfo(1)

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the MetricStorage.SendBatch
func (mmSendBatch *mMetricStorageMockSendBatch) Inspect(f func(ops []operation.MetricOperation, labels map[string]string)) *mMetricStorageMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for MetricStorageMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by MetricStorage.SendBatch
func (mmSendBatch *mMetricStorageMockSendBatch) Return(err error) *MetricStorageMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("MetricStorageMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &MetricStorageMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &MetricStorageMockSendBatchResults{err}
	mmSendBatch.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// Set uses given function f to mock the MetricStorage.SendBatch method
func (mmSendBatch *mMetricStorageMockSendBatch) Set(f func(ops []operation.MetricOperation, labels map[string]string) (err error)) *MetricStorageMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the MetricStorage.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the MetricStorage.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	mmSendBatch.mock.funcSendBatchOrigin = minimock.CallerInfo(1)
	return mmSendBatch.mock
}

// When sets expectation for the MetricStorage.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mMetricStorageMockSendBatch) When(ops []operation.MetricOperation, labels map[string]string) *MetricStorageMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("MetricStorageMock.SendBatch mock is already set by Set")
	}

	expectation := &MetricStorageMockSendBatchExpectation{
		mock:               mmSendBatch.mock,
		params:             &MetricStorageMockSendBatchParams{ops, labels},
		expectationOrigins: MetricStorageMockSendBatchExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up MetricStorage.SendBatch return parameters for the expectation previously defined by the When method
func (e *MetricStorageMockSendBatchExpectation) Then(err error) *MetricStorageMock {
	e.results = &MetricStorageMockSendBatchResults{err}
	return e.mock
}

// Times sets number of times MetricStorage.SendBatch should be invoked
func (mmSendBatch *mMetricStorageMockSendBatch) Times(n uint64) *mMetricStorageMockSendBatch {
	if n == 0 {
		mmSendBatch.mock.t.Fatalf("Times of MetricStorageMock.SendBatch mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSendBatch.expectedInvocations, n)
	mmSendBatch.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSendBatch
}

func (mmSendBatch *mMetricStorageMockSendBatch) invocationsDone() bool {
	if len(mmSendBatch.expectations) == 0 && mmSendBatch.defaultExpectation == nil && mmSendBatch.mock.funcSendBatch == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSendBatch.mock.afterSendBatchCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSendBatch.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SendBatch implements mm_pkg.MetricStorage
func (mmSendBatch *MetricStorageMock) SendBatch(ops []operation.MetricOperation, labels map[string]string) (err error) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	mmSendBatch.t.Helper()

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ops, labels)
	}

	mm_params := MetricStorageMockSendBatchParams{ops, labels}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, &mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_want_ptrs := mmSendBatch.SendBatchMock.defaultExpectation.paramPtrs

		mm_got := MetricStorageMockSendBatchParams{ops, labels}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ops != nil && !minimock.Equal(*mm_want_ptrs.ops, mm_got.ops) {
				mmSendBatch.t.Errorf("MetricStorageMock.SendBatch got unexpected parameter ops, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originOps, *mm_want_ptrs.ops, mm_got.ops, minimock.Diff(*mm_want_ptrs.ops, mm_got.ops))
			}

			if mm_want_ptrs.labels != nil && !minimock.Equal(*mm_want_ptrs.labels, mm_got.labels) {
				mmSendBatch.t.Errorf("MetricStorageMock.SendBatch got unexpected parameter labels, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.originLabels, *mm_want_ptrs.labels, mm_got.labels, minimock.Diff(*mm_want_ptrs.labels, mm_got.labels))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("MetricStorageMock.SendBatch got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSendBatch.SendBatchMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the MetricStorageMock.SendBatch")
		}
		return (*mm_results).err
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ops, labels)
	}
	mmSendBatch.t.Fatalf("Unexpected call to MetricStorageMock.SendBatch. %v %v", ops, labels)
	return
}

// SendBatchAfterCounter returns a count of finished MetricStorageMock.SendBatch invocations
func (mmSendBatch *MetricStorageMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of MetricStorageMock.SendBatch invocations
func (mmSendBatch *MetricStorageMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to MetricStorageMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mMetricStorageMockSendBatch) Calls() []*MetricStorageMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*MetricStorageMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *MetricStorageMock) MinimockSendBatchDone() bool {
	if m.SendBatchMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SendBatchMock.invocationsDone()
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *MetricStorageMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MetricStorageMock.SendBatch at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSendBatchCounter := mm_atomic.LoadUint64(&m.afterSendBatchCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && afterSendBatchCounter < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to MetricStorageMock.SendBatch at\n%s", m.SendBatchMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to MetricStorageMock.SendBatch at\n%s with params: %#v", m.SendBatchMock.defaultExpectation.expectationOrigins.origin, *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && afterSendBatchCounter < 1 {
		m.t.Errorf("Expected call to MetricStorageMock.SendBatch at\n%s", m.funcSendBatchOrigin)
	}

	if !m.SendBatchMock.invocationsDone() && afterSendBatchCounter > 0 {
		m.t.Errorf("Expected %d calls to MetricStorageMock.SendBatch at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SendBatchMock.expectedInvocations), m.SendBatchMock.expectedInvocationsOrigin, afterSendBatchCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MetricStorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockApplyOperationInspect()

			m.MinimockCounterInspect()

			m.MinimockCounterAddInspect()

			m.MinimockGaugeInspect()

			m.MinimockGaugeAddInspect()

			m.MinimockGaugeSetInspect()

			m.MinimockGroupedInspect()

			m.MinimockHandlerInspect()

			m.MinimockHistogramInspect()

			m.MinimockHistogramObserveInspect()

			m.MinimockRegisterCounterInspect()

			m.MinimockRegisterGaugeInspect()

			m.MinimockRegisterHistogramInspect()

			m.MinimockSendBatchInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MetricStorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MetricStorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockApplyOperationDone() &&
		m.MinimockCounterDone() &&
		m.MinimockCounterAddDone() &&
		m.MinimockGaugeDone() &&
		m.MinimockGaugeAddDone() &&
		m.MinimockGaugeSetDone() &&
		m.MinimockGroupedDone() &&
		m.MinimockHandlerDone() &&
		m.MinimockHistogramDone() &&
		m.MinimockHistogramObserveDone() &&
		m.MinimockRegisterCounterDone() &&
		m.MinimockRegisterGaugeDone() &&
		m.MinimockRegisterHistogramDone() &&
		m.MinimockSendBatchDone()
}
